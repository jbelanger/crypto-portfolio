===== ./package.json =====
{
  "name": "@crypto/import",
  "version": "0.1.0",
  "license": "AGPL-3.0",
  "private": true,
  "description": "Cryptocurrency transaction import package with multi-provider support",
  "type": "module",
  "main": "src/index.ts",
  "types": "src/index.ts",
  "scripts": {
    "build": "tsc",
    "clean": "rm -rf node_modules dist",
    "lint": "eslint \"src/**/*.ts*\"",
    "prettier": "prettier --check .",
    "prettier:fix": "prettier --write .",
    "test": "jest --detectOpenHandles --forceExit --passWithNoTests",
    "typecheck": "tsc --noEmit",
    "blockchain-providers:list": "tsx src/scripts/list-providers.ts",
    "blockchain-providers:validate": "tsx src/scripts/validate-providers.ts",
    "blockchain-config:generate": "tsx src/scripts/generate-config.ts",
    "blockchain-config:validate": "tsx src/scripts/validate-config.ts",
    "exchanges:list": "tsx src/scripts/list-exchange-adapters.ts",
    "exchanges:generate": "tsx src/scripts/generate-exchange-config.ts",
    "exchanges:validate": "tsx src/scripts/validate-exchange-registry.ts",
    "exchanges:validate-config": "tsx src/scripts/validate-exchange-config.ts"
  },
  "dependencies": {
    "@scure/base": "^1.2.6",
    "@scure/bip32": "^1.7.0",
    "bitcoinjs-lib": "^6.1.7",
    "ccxt": "^4.5.1",
    "csv-parse": "^6.1.0",
    "decimal.js": "^10.6.0",
    "reflect-metadata": "^0.2.2"
  },
  "devDependencies": {
    "@jest/globals": "^30.0.5",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.3.0",
    "jest": "^30.0.5",
    "ts-jest": "^29.4.1",
    "tsconfig": "workspace:*",
    "tsx": "^4.20.4",
    "typescript": "^5.9.2"
  },
  "peerDependencies": {
    "@crypto/core": "workspace:*",
    "@crypto/data": "workspace:*",
    "@crypto/shared-logger": "workspace:*",
    "@crypto/shared-utils": "workspace:*"
  }
}===== ./tsconfig.json =====
{
   "extends": "tsconfig/tsconfig.json",
   "compilerOptions": {
      "allowImportingTsExtensions": true,
      "noEmit": true
   },
   "include": ["src"]
}===== ./src/exchanges/ledgerlive/csv-adapter.ts =====
import type { CryptoTransaction, ExchangeInfo, TransactionStatus } from '@crypto/core';
import { createMoney, parseDecimal } from '@crypto/shared-utils';
import { BaseCSVAdapter, type CSVConfig } from '../base-csv-adapter.ts';
interface LedgerLiveCSVConfig extends CSVConfig { }

// Expected CSV headers for validation
const EXPECTED_HEADERS = {
  LEDGERLIVE_CSV: 'Operation Date,Status,Currency Ticker,Operation Type,Operation Amount,Operation Fees,Operation Hash,Account Name,Account xpub,Countervalue Ticker,Countervalue at Operation Date,Countervalue at CSV Export'
};

interface LedgerLiveOperationRow {
  'Operation Date': string;
  'Status': string;
  'Currency Ticker': string;
  'Operation Type': string;
  'Operation Amount': string;
  'Operation Fees': string;
  'Operation Hash': string;
  'Account Name': string;
  'Account xpub': string;
  'Countervalue Ticker': string;
  'Countervalue at Operation Date': string;
  'Countervalue at CSV Export': string;
}

export class LedgerLiveCSVAdapter extends BaseCSVAdapter {
  constructor(config: LedgerLiveCSVConfig) {
    super(config, 'LedgerLiveCSVAdapter');
  }

  protected getExpectedHeaders(): Record<string, string> {
    return {
      [EXPECTED_HEADERS.LEDGERLIVE_CSV]: 'operations'
    };
  }

  protected getFileTypeHandlers(): Record<string, (filePath: string) => Promise<CryptoTransaction[]>> {
    return {
      'operations': (filePath) => this.parseOperations(filePath)
    };
  }

  private mapStatus(status: string): TransactionStatus {
    switch (status.toLowerCase()) {
      case 'confirmed':
        return 'closed';
      case 'pending':
        return 'open';
      case 'failed':
        return 'canceled';
      default:
        return 'closed'; // Default to closed for unknown statuses
    }
  }

  private mapOperationType(operationType: string): 'trade' | 'deposit' | 'withdrawal' | null {
    switch (operationType.toUpperCase()) {
      case 'IN':
        return 'deposit';
      case 'OUT':
        return 'withdrawal';
      case 'FEES':
        return null; // Fee-only transactions will be handled separately
      case 'STAKE':
      case 'DELEGATE':
      case 'UNDELEGATE':
      case 'WITHDRAW_UNBONDED':
      case 'OPT_OUT':
        return null; // These are special operations, handled as metadata
      default:
        return null;
    }
  }

  public async getExchangeInfo(): Promise<ExchangeInfo> {
    return {
      id: 'ledgerlive',
      name: 'Ledger Live CSV',
      version: '1.0.0',
      capabilities: {
        fetchMyTrades: false, // LedgerLive doesn't have traditional trades
        fetchDeposits: true,
        fetchWithdrawals: true,
        fetchLedger: true,
        fetchClosedOrders: false,
        fetchBalance: false, // CSV doesn't provide current balances
        fetchOrderBook: false,
        fetchTicker: false
      }
    };
  }

  private async parseOperations(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<LedgerLiveOperationRow>(filePath);
    const transactions: CryptoTransaction[] = [];

    this.logger.info(`Processing ${rows.length} LedgerLive operations from ${filePath}`);

    for (const row of rows) {
      // Skip empty or invalid rows
      if (!row['Operation Date'] || !row['Currency Ticker'] || !row['Operation Amount']) {
        this.logger.warn(`Skipping invalid row with missing required fields - Row: ${JSON.stringify(row)}`);
        continue;
      }

      const transaction = this.convertOperationToTransaction(row);
      if (transaction) {
        transactions.push(transaction);
      }
    }

    this.logger.info(`Converted ${transactions.length} LedgerLive operations to transactions`);
    return transactions;
  }

  private convertOperationToTransaction(row: LedgerLiveOperationRow): CryptoTransaction | null {
    const operationType = this.mapOperationType(row['Operation Type']);

    // Skip transactions that don't map to standard types (like FEES, STAKE, etc.)
    if (!operationType) {
      this.logger.debug(`Skipping non-standard operation type - Type: ${row['Operation Type']}, Hash: ${row['Operation Hash']}`);
      return null;
    }

    const timestamp = new Date(row['Operation Date']).getTime();
    const amount = parseDecimal(row['Operation Amount']).abs(); // Ensure positive amount
    const fee = parseDecimal(row['Operation Fees'] || '0');
    const currency = row['Currency Ticker'];
    const status = this.mapStatus(row['Status']);

    // For LedgerLive, negative amounts in OUT operations are normal
    // The mapOperationType already determines if it's deposit/withdrawal
    const netAmount = amount.minus(fee);

    return {
      id: row['Operation Hash'],
      type: operationType,
      timestamp,
      datetime: row['Operation Date'],
      symbol: undefined, // LedgerLive operations are single-currency
      side: undefined,
      amount: createMoney(netAmount.toNumber(), currency),
      price: undefined,
      fee: createMoney(fee.toNumber(), currency),
      status,
      info: {
        originalRow: row,
        operationType: row['Operation Type'],
        accountName: row['Account Name'],
        accountXpub: row['Account xpub'],
        countervalueTicker: row['Countervalue Ticker'],
        countervalueAtOperation: row['Countervalue at Operation Date'],
        countervalueAtExport: row['Countervalue at CSV Export'],
        grossAmount: amount.toNumber() // Store original amount before fee deduction
      }
    };
  }
}===== ./src/exchanges/base-csv-adapter.ts =====
import type { CryptoTransaction, ExchangeInfo, IExchangeAdapter, TransactionType } from '@crypto/core';
import type { Logger } from '@crypto/shared-logger';
import { getLogger } from '@crypto/shared-logger';
import fs from 'fs/promises';
import path from 'path';
import { CsvFilters } from './csv-filters.ts';
import { CsvParser } from './csv-parser.ts';

export interface CSVConfig {
  csvDirectories: string[];
  uid?: string;
}

export interface FileTypeHandler {
  type: string;
  parser: (filePath: string) => Promise<CryptoTransaction[]>;
}

/**
 * Base class for CSV-based exchange adapters
 * Provides common functionality for parsing CSV files and managing transactions
 */
export abstract class BaseCSVAdapter implements IExchangeAdapter {
  protected logger: Logger;
  protected config: CSVConfig;
  private cachedTransactions: CryptoTransaction[] | null = null;

  constructor(config: CSVConfig, loggerName: string) {
    this.config = config;
    this.logger = getLogger(loggerName);
  }

  // Abstract methods that must be implemented by subclasses
  protected abstract getExpectedHeaders(): Record<string, string>;
  protected abstract getFileTypeHandlers(): Record<string, (filePath: string) => Promise<CryptoTransaction[]>>;
  public abstract getExchangeInfo(): Promise<ExchangeInfo>;

  /**
   * Parse a CSV file using the common parsing logic
   */
  protected async parseCsvFile<T>(filePath: string): Promise<T[]> {
    return CsvParser.parseFile<T>(filePath);
  }

  /**
   * Filter rows by UID if configured
   */
  protected filterByUid<T extends { UID: string }>(rows: T[]): T[] {
    return CsvFilters.filterByUid(rows, this.config.uid);
  }

  /**
   * Validate CSV headers and determine file type
   */
  private async validateCSVHeaders(filePath: string): Promise<string> {
    const expectedHeaders = this.getExpectedHeaders();
    const fileType = await CsvParser.validateHeaders(filePath, expectedHeaders);

    if (fileType === 'unknown') {
      const headers = await CsvParser.getHeaders(filePath);
      this.logger.warn(`Unrecognized CSV headers in ${filePath} - Headers: ${headers}`);
    }

    return fileType;
  }

  /**
   * Test if the CSV directories contain expected files
   */
  async testConnection(): Promise<boolean> {
    try {
      for (const csvDirectory of this.config.csvDirectories) {
        try {
          const stats = await fs.stat(csvDirectory);
          if (!stats.isDirectory()) {
            continue;
          }

          const files = await fs.readdir(csvDirectory);
          const csvFiles = files.filter(f => f.endsWith('.csv'));

          if (csvFiles.length > 0) {
            return true;
          }
        } catch (dirError) {
          this.logger.warn(`CSV directory test failed for directory - Error: ${dirError}, Directory: ${csvDirectory}`);
          continue;
        }
      }

      return false;
    } catch (error) {
      this.logger.error(`CSV directories test failed - Error: ${error}, Directories: ${this.config.csvDirectories}`);
      return false;
    }
  }

  /**
   * Load all transactions from CSV directories
   */
  protected async loadAllTransactions(): Promise<CryptoTransaction[]> {
    if (this.cachedTransactions) {
      this.logger.debug('Returning cached transactions');
      return this.cachedTransactions;
    }

    this.logger.info(`Starting to load CSV transactions - CsvDirectories: ${this.config.csvDirectories}`);

    const transactions: CryptoTransaction[] = [];
    const fileTypeHandlers = this.getFileTypeHandlers();

    try {
      // Process each directory in order
      for (const csvDirectory of this.config.csvDirectories) {
        this.logger.info(`Processing CSV directory - CsvDirectory: ${csvDirectory}`);

        try {
          const files = await fs.readdir(csvDirectory);
          this.logger.debug(`Found CSV files in directory - CsvDirectory: ${csvDirectory}, Files: ${files}`);

          // Process all CSV files with proper header validation
          const csvFiles = files.filter(f => f.endsWith('.csv'));

          for (const file of csvFiles) {
            const filePath = path.join(csvDirectory, file);
            const fileType = await this.validateCSVHeaders(filePath);

            const handler = fileTypeHandlers[fileType];
            if (handler) {
              this.logger.info(`Processing ${fileType} CSV file - File: ${file}, Directory: ${csvDirectory}`);
              const fileTransactions = await handler(filePath);
              this.logger.info(`Parsed ${fileType} transactions - File: ${file}, Directory: ${csvDirectory}, Count: ${fileTransactions.length}`);
              transactions.push(...fileTransactions);
            } else if (fileType === 'unknown') {
              this.logger.warn(`Skipping unrecognized CSV file - File: ${file}, Directory: ${csvDirectory}`);
            } else {
              this.logger.warn(`No handler for file type: ${fileType} - File: ${file}, Directory: ${csvDirectory}`);
            }
          }
        } catch (dirError) {
          this.logger.error(`Failed to process CSV directory - Error: ${dirError}, Directory: ${csvDirectory}`);
          // Continue processing other directories
          continue;
        }
      }

      // Sort by timestamp
      transactions.sort((a, b) => a.timestamp - b.timestamp);

      this.cachedTransactions = transactions;
      this.logger.info(`Loaded ${transactions.length} transactions from ${this.config.csvDirectories.length} CSV directories`);

      return transactions;
    } catch (error) {
      this.logger.error(`Failed to load CSV transactions - Error: ${error}`);
      throw error;
    }
  }

  /**
   * Generic method to fetch transactions by type with optional time filtering
   */
  private async fetchTransactionsByType(type?: TransactionType, since?: number): Promise<CryptoTransaction[]> {
    const transactions = await this.loadAllTransactions();

    let filtered = type ? transactions.filter(tx => tx.type === type) : transactions;

    if (since) {
      filtered = filtered.filter(tx => tx.timestamp >= since);
    }

    return filtered;
  }

  // Standard IExchangeAdapter implementations
  async fetchAllTransactions(since?: number): Promise<CryptoTransaction[]> {
    return this.fetchTransactionsByType(undefined, since);
  }

  async fetchTrades(since?: number): Promise<CryptoTransaction[]> {
    return this.fetchTransactionsByType('trade', since);
  }

  async fetchDeposits(since?: number): Promise<CryptoTransaction[]> {
    return this.fetchTransactionsByType('deposit', since);
  }

  async fetchWithdrawals(since?: number): Promise<CryptoTransaction[]> {
    return this.fetchTransactionsByType('withdrawal', since);
  }

  async fetchClosedOrders(since?: number): Promise<CryptoTransaction[]> {
    // For CSV, closed orders are essentially the same as trades
    return this.fetchTrades(since);
  }

  async fetchLedger(_since?: number): Promise<CryptoTransaction[]> {
    // Most CSV adapters don't support ledger to prevent double-counting
    return [];
  }

  async fetchBalance(): Promise<never> {
    // CSV files don't contain current balance information
    throw new Error('Balance fetching not supported for CSV adapter - CSV files do not contain current balance data');
  }

  async close(): Promise<void> {
    // Clear cached data
    this.cachedTransactions = null;
  }
}===== ./src/exchanges/csv-filters.ts =====
/**
 * Generic filtering utilities for CSV data
 */
export class CsvFilters {
  /**
   * Filter rows by a single field value
   * @param rows Array of objects to filter
   * @param field Field name to filter by
   * @param value Value to match (if undefined, no filtering is applied)
   * @returns Filtered array
   */
  static filterByField<T, K extends keyof T>(
    rows: T[],
    field: K,
    value?: T[K]
  ): T[] {
    if (value === undefined || value === null) {
      return rows;
    }
    return rows.filter(row => row[field] === value);
  }

  /**
   * Filter rows by multiple field values
   * @param rows Array of objects to filter
   * @param filters Object with field names as keys and values to match
   * @returns Filtered array
   */
  static filterByFields<T>(
    rows: T[],
    filters: Partial<Record<keyof T, any>>
  ): T[] {
    return rows.filter(row => {
      return Object.entries(filters).every(([field, value]) => {
        if (value === undefined || value === null) {
          return true;
        }
        return row[field as keyof T] === value;
      });
    });
  }

  /**
   * Filter rows by UID (common pattern for exchange CSVs)
   * @param rows Array of objects with UID field
   * @param uid UID to filter by (if undefined, no filtering is applied)
   * @returns Filtered array
   */
  static filterByUid<T extends { UID: string }>(
    rows: T[],
    uid?: string
  ): T[] {
    return this.filterByField(rows, 'UID', uid);
  }

  /**
   * Filter rows by timestamp range
   * @param rows Array of objects with timestamp field
   * @param since Minimum timestamp (if undefined, no lower bound)
   * @param until Maximum timestamp (if undefined, no upper bound)
   * @returns Filtered array
   */
  static filterByTimestamp<T extends { timestamp: number }>(
    rows: T[],
    since?: number,
    until?: number
  ): T[] {
    return rows.filter(row => {
      if (since !== undefined && row.timestamp < since) {
        return false;
      }
      if (until !== undefined && row.timestamp > until) {
        return false;
      }
      return true;
    });
  }

  /**
   * Group rows by a field value
   * @param rows Array of objects to group
   * @param field Field name to group by
   * @returns Map with field values as keys and arrays of rows as values
   */
  static groupByField<T, K extends keyof T>(
    rows: T[],
    field: K
  ): Map<T[K], T[]> {
    const groups = new Map<T[K], T[]>();
    
    for (const row of rows) {
      const key = row[field];
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(row);
    }
    
    return groups;
  }
}===== ./src/exchanges/coinbase/ccxt-adapter.ts =====
import type { CryptoTransaction, Money, TransactionType } from '@crypto/core';
import ccxt from 'ccxt';
import { Decimal } from 'decimal.js';
import { BaseCCXTAdapter } from '../base-ccxt-adapter.ts';
/**
 * Specialized Coinbase adapter that uses fetchLedger for comprehensive transaction data
 * 
 * COINBASE LEDGER API QUIRKS AND WHY THIS IS COMPLICATED:
 * 
 * 1. DOUBLE-NESTED INFO STRUCTURE:
 *    - Coinbase ledger entries have info.info structure (double nested)
 *    - The inner info contains the actual Coinbase transaction data
 *    - This is because CCXT wraps the raw Coinbase response in its own structure
 * 
 * 2. TRADE GROUPING COMPLEXITY:
 *    - A single buy/sell order creates multiple ledger entries
 *    - Example: Buying BTC with CAD creates:
 *      * Entry 1: CAD going out (direction: "out", currency: "CAD")  
 *      * Entry 2: BTC coming in (direction: "in", currency: "BTC")
 *    - Both entries share the same order ID but represent different sides of the trade
 * 
 * 3. FEE DUPLICATION ISSUE:
 *    - Each ledger entry contains the SAME fee information for the same order
 *    - Must deduplicate fees by order ID to avoid double counting
 *    - Example: 10.98 CAD fee appears in both CAD-out and BTC-in entries
 * 
 * 4. DIRECTION-BASED TRANSACTION TYPES:
 *    - "send" transactions can be either deposits OR withdrawals
 *    - Must check direction field: "in" = deposit, "out" = withdrawal
 *    - This is counter-intuitive but reflects Coinbase's perspective
 * 
 * 5. BUY/SELL AMOUNT/PRICE INVERSION:
 *    - For BUY: inEntries = base currency, outEntries = quote currency
 *    - For SELL: outEntries = base currency, inEntries = quote currency
 *    - Direction field indicates money flow, not trade semantics
 * 
 * 6. PRICE CALCULATION:
 *    - Price should exclude fees (net cost of asset)
 *    - Total from Coinbase includes fees, must subtract them
 *    - Only subtract fees if fee currency matches quote currency
 * 
 * 7. DEPOSITS/WITHDRAWALS SHOULD NOT HAVE PRICE:
 *    - Only trade transactions should have price fields populated
 *    - Deposits and withdrawals represent transfers, not exchanges
 * 
 * DEBUGGING GUIDE:
 * To enable detailed debug logging, set environment variable:
 * export DEBUG_COINBASE=true
 * 
 * This will log:
 * - Raw entry structures for each trade group
 * - Fee calculation details and deduplication
 * - Final combined trade results
 * - Transaction type extraction decisions
 */
export class CoinbaseCCXTAdapter extends BaseCCXTAdapter {
  private accounts: any[] | null = null;

  constructor(
    configOrCredentials: { apiKey: string; secret: string; password: string; sandbox?: boolean },
    enableOnlineVerificationOrOptions?: boolean | { enableOnlineVerification?: boolean }
  ) {
    
    let enableOnlineVerification: boolean = false;

      const credentials = configOrCredentials;
      const options = enableOnlineVerificationOrOptions as { enableOnlineVerification?: boolean } || {};
      enableOnlineVerification = options.enableOnlineVerification || false;
      
      // Create config from credentials
      const config = {
        id: 'coinbase',
        enabled: true,
        adapterType: 'ccxt',
        credentials: {
          apiKey: credentials.apiKey,
          secret: credentials.secret,
          password: credentials.password,
          sandbox: credentials.sandbox
        },
        options: {
          enableRateLimit: true,
          rateLimit: 1000
        }
      };
    
    // Create Coinbase Advanced Trade exchange
    const exchange = new (ccxt as any).coinbaseadvanced({
      apiKey: config.credentials.apiKey,
      secret: config.credentials.secret,
      password: config.credentials.password, // Coinbase uses password for passphrase      
      sandbox: config.credentials.sandbox ?? false,
      ...config.options
    });

    super(exchange, config.id, enableOnlineVerification, 'CoinbaseCCXTAdapter');

    this.logger.info(`Initialized Coinbase Ledger adapter - RateLimit: ${this.exchange.rateLimit}, Sandbox: ${config.credentials.sandbox}`);
  }


  protected createExchange() {
    return this.exchange; // Already created in constructor
  }

  /**
   * Override to focus on ledger-based transaction fetching with post-processing
   */
  async fetchAllTransactions(since?: number): Promise<CryptoTransaction[]> {
    const startTime = Date.now();
    this.logger.info(`Starting ledger-based transaction fetch from Coinbase - Since: ${since}`);

    try {

      // Primary data source: fetchLedger for comprehensive transaction data
      const ledgerTransactions = await this.fetchLedger(since);

      // Process ledger entries and group orders with fills
      const transactions = await this.processLedgerEntries(ledgerTransactions);

      // Sort by timestamp
      transactions.sort((a, b) => a.timestamp - b.timestamp);

      const duration = Date.now() - startTime;
      this.logger.info(`Completed Coinbase ledger-based transaction fetch - TotalTransactions: ${transactions.length}, GroupedTrades: ${transactions.filter(t => t.type === 'trade').length}, Duration: ${duration}ms`);

      return transactions;
    } catch (error) {
      this.handleError(error, 'fetchAllTransactions');
      throw error;
    }
  }

  /**
   * Enhanced fetchLedger with pagination support for Coinbase
   */
  async fetchLedger(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchLedger']) {
        this.logger.warn('Coinbase does not support fetchLedger - falling back to standard methods');
        return [];
      }

      // Load accounts to get available currencies and account IDs
      await this.loadAccounts();

      const allEntries: any[] = [];

      if (!this.accounts || this.accounts.length === 0) {
        this.logger.warn('No accounts available for ledger fetching');
        return [];
      }

      // Use account IDs directly instead of currencies since Coinbase Advanced Trade prefers account_id
      this.logger.info(`Fetching ledger entries for ${this.accounts.length} accounts`);

      for (const account of this.accounts) {
        try {
          if (!account.id || !account.currency) {
            this.logger.warn(`Skipping account with missing id or currency - Account: ${JSON.stringify(account)}`);
            continue;
          }

          const entries = await this.fetchLedgerWithAccountId(account.id, account.currency, since);
          allEntries.push(...entries);
          this.logger.debug(`Fetched ${entries.length} ledger entries for account ${account.id} (${account.currency})`);
        } catch (accountError) {
          this.logger.warn(`Failed to fetch ledger for account ${account.id} - AccountId: ${account.id}, Currency: ${account.currency}, Error: ${accountError instanceof Error ? accountError.message : 'Unknown error'}`);
        }
      }

      this.logger.info(`Fetched ${allEntries.length} total ledger entries from Coinbase`);

      // Transform raw ledger entries before post-processing
      return this.transformTransactions(allEntries, 'ledger');
    } catch (error) {
      this.handleError(error, 'fetchLedger');
      throw error;
    }
  }

  /**
   * Fetch ledger entries with pagination for a specific account
   */
  private async fetchLedgerWithAccountId(accountId: string, currency: string, since?: number): Promise<any[]> {
    const allEntries: any[] = [];
    let hasMore = true;
    let startingAfter: string | undefined;
    const pageSize = 100; // CCXT default for Coinbase

    while (hasMore) {
      try {
        const params: any = {
          limit: pageSize,
          paginate: false, // We handle pagination manually for better control
          account_id: accountId // Pass account_id to satisfy Coinbase requirement
        };

        // Add pagination cursor if available
        if (startingAfter) {
          params.starting_after = startingAfter;
        }

        this.logger.debug(`Fetching ledger page for account: ${accountId} (${currency}) - AccountId: ${accountId}, Currency: ${currency}, StartingAfter: ${startingAfter}, PageSize: ${pageSize}`);

        // Pass currency as the first parameter since CCXT expects it
        const entries = await this.exchange.fetchLedger(undefined, since, pageSize, params);

        if (entries.length === 0) {
          hasMore = false;
          break;
        }

        allEntries.push(...entries);

        // Check if there are more pages
        if (entries.length < pageSize) {
          hasMore = false;
        } else {
          // Use the last entry's ID as the starting point for the next page
          const lastEntry = entries[entries.length - 1];
          if (lastEntry) {
            startingAfter = lastEntry.id || lastEntry.info?.id;

            if (!startingAfter) {
              // If we can't get pagination cursor, stop to avoid infinite loop
              this.logger.warn('No pagination cursor available, stopping pagination');
              hasMore = false;
            }
          } else {
            hasMore = false;
          }
        }

        // Prevent infinite loops
        if (allEntries.length > 50000) { // Reasonable safety limit
          this.logger.warn('Reached pagination safety limit, stopping fetch');
          break;
        }

      } catch (pageError) {
        this.logger.error(`Error fetching ledger page for account - AccountId: ${accountId}, Currency: ${currency}, StartingAfter: ${startingAfter}, Error: ${pageError instanceof Error ? pageError.message : 'Unknown error'}`);
        throw pageError;
      }
    }

    return allEntries;
  }

  /**
   * Process ledger entries to group orders and fills into complete trades
   */
  private async processLedgerEntries(ledgerTransactions: CryptoTransaction[]): Promise<CryptoTransaction[]> {
    this.logger.info(`Processing Coinbase ledger entries for grouping - TotalEntries: ${ledgerTransactions.length}`);

    this.logger.info(`Processing all ledger transactions - TotalCount: ${ledgerTransactions.length}`);

    // Restore the original grouping approach now that we understand the data structure
    const tradeGroups = new Map<string, CryptoTransaction[]>();
    const nonTradeTransactions: CryptoTransaction[] = [];

    // Group trade entries by their reference IDs
    for (const transaction of ledgerTransactions) {
      if (this.isTradeRelatedTransaction(transaction)) {
        const groupId = this.extractTradeGroupId(transaction);
        if (groupId) {
          if (!tradeGroups.has(groupId)) {
            tradeGroups.set(groupId, []);
          }
          tradeGroups.get(groupId)!.push(transaction);
        } else {
          // Trade entry without group ID, treat as individual transaction
          nonTradeTransactions.push(this.convertLedgerEntryToTrade(transaction));
        }
      } else {
        nonTradeTransactions.push(this.convertLedgerEntryToTrade(transaction));
      }
    }

    // Convert grouped trade entries into single trade transactions
    const groupedTrades = this.createTradeFromGroups(tradeGroups);

    const result = [...groupedTrades, ...nonTradeTransactions];

    this.logger.info(`Completed ledger entry processing - TotalTransactions: ${result.length}, TradeGroups: ${tradeGroups.size}, GroupedTrades: ${groupedTrades.length}, NonTradeTransactions: ${nonTradeTransactions.length}`);

    return result;
  }

  /**
   * Extract the trade group ID from a Coinbase ledger entry
   */
  private extractTradeGroupId(transaction: CryptoTransaction): string | null {
    const info = transaction.info?.info; // Double nested structure
    if (!info) return null;

    // Extract group IDs from different transaction types
    if (info.buy?.id) {
      return info.buy.id;
    }
    if (info.trade?.id) {
      return info.trade.id;
    }
    if (info.sell?.id) {
      return info.sell.id;
    }

    // For advanced trade fills, check the nested structure
    if (info.advanced_trade_fill?.order_id) {
      return info.advanced_trade_fill.order_id;
    }

    // For other possible locations
    if (info.order_id) {
      return info.order_id;
    }

    return null;
  }

  /**
   * Create single trade transactions from grouped ledger entries
   */
  private createTradeFromGroups(tradeGroups: Map<string, CryptoTransaction[]>): CryptoTransaction[] {
    const trades: CryptoTransaction[] = [];

    for (const [groupId, entries] of tradeGroups.entries()) {
      if (entries.length === 0) continue;

      try {
        // For single entry, convert directly
        if (entries.length === 1) {
          const entry = entries[0];
          if (entry) {
            trades.push(this.convertLedgerEntryToTrade(entry));
          }
          continue;
        }

        // For multiple entries, combine them into a single trade
        const combinedTrade = this.combineMultipleLedgerEntries(groupId, entries);
        if (combinedTrade) {
          trades.push(combinedTrade);
        }
      } catch (error) {
        this.logger.warn(`Failed to create trade from group ${groupId} - Error: ${error instanceof Error ? error.message : 'Unknown error'}, EntriesCount: ${entries.length}`);

        // Fallback: convert each entry individually
        for (const entry of entries) {
          trades.push(this.convertLedgerEntryToTrade(entry));
        }
      }
    }

    return trades;
  }

  /**
   * Combine multiple ledger entries into a single trade transaction
   */
  private combineMultipleLedgerEntries(groupId: string, entries: CryptoTransaction[]): CryptoTransaction | null {
    if (entries.length === 0) return null;


    // Use the first entry as the base
    const baseEntry = entries[0];
    const timestamp = Math.min(...entries.map(e => e.timestamp));

    // Determine the trade symbol and sides from the entries
    const inEntries = entries.filter(e => e.info?.direction === 'in');
    const outEntries = entries.filter(e => e.info?.direction === 'out');

    // If we have both in and out entries, this is a proper trade
    if (inEntries.length > 0 && outEntries.length > 0) {
      // Extract symbol from advanced_trade_fill data more comprehensively
      let symbol = this.extractSymbolFromInfo(baseEntry?.info);

      // If symbol is still unknown, try to construct it from currencies
      if (!symbol || symbol === 'unknown') {
        const baseCurrency = inEntries[0]?.info?.currency;
        const quoteCurrency = outEntries[0]?.info?.currency;
        if (baseCurrency && quoteCurrency) {
          symbol = `${baseCurrency}-${quoteCurrency}`;
        }
      }

      // Extract side from advanced_trade_fill data
      const advancedTradeInfo = baseEntry?.info?.info?.advanced_trade_fill;
      const side = advancedTradeInfo?.order_side || this.extractSideFromInfo(baseEntry?.info);

      // COINBASE DIRECTION SEMANTICS (this is the confusing part):
      // - direction: "in" = money coming INTO your account
      // - direction: "out" = money going OUT OF your account
      // 
      // For BUY trades: You spend quote currency (out) to receive base currency (in)
      // For SELL trades: You send base currency (out) to receive quote currency (in)
      // 
      // This is counter-intuitive because "direction" is about account flow, not trade semantics!
      let baseCurrency: string;
      let quoteCurrency: string;
      let totalBaseAmount: Decimal;
      let totalQuoteAmount: Decimal;

      if (side === 'buy') {
        // Buy: receiving base currency (in), spending quote currency (out)
        baseCurrency = inEntries[0]?.info?.currency || 'unknown';
        quoteCurrency = outEntries[0]?.info?.currency || 'unknown';

        totalBaseAmount = inEntries.reduce((sum, entry) => {
          const amount = entry.amount && typeof entry.amount === 'object' ? entry.amount.amount : new Decimal(0);
          return sum.plus(amount);
        }, new Decimal(0));

        totalQuoteAmount = outEntries.reduce((sum, entry) => {
          const amount = entry.amount && typeof entry.amount === 'object' ? entry.amount.amount : new Decimal(0);
          return sum.plus(amount);
        }, new Decimal(0));
      } else {
        // Sell: sending base currency (out), receiving quote currency (in)
        baseCurrency = outEntries[0]?.info?.currency || 'unknown';
        quoteCurrency = inEntries[0]?.info?.currency || 'unknown';

        totalBaseAmount = outEntries.reduce((sum, entry) => {
          const amount = entry.amount && typeof entry.amount === 'object' ? entry.amount.amount : new Decimal(0);
          return sum.plus(amount);
        }, new Decimal(0));

        totalQuoteAmount = inEntries.reduce((sum, entry) => {
          const amount = entry.amount && typeof entry.amount === 'object' ? entry.amount.amount : new Decimal(0);
          return sum.plus(amount);
        }, new Decimal(0));
      }

      // Sum all fees from all entries - deduplicate by order ID to avoid double counting
      // CRITICAL: Coinbase includes the SAME fee in multiple ledger entries for the same order.
      // Example: A buy order creates CAD-out and BTC-in entries, both containing identical fee data.
      // Without deduplication, we'd count fees twice (e.g., 10.98 + 10.98 = 21.96 instead of 10.98).
      const seenFees = new Set<string>(); // Track fee IDs to avoid duplicates
      const totalFee = entries.reduce((sum, entry) => {
        // Check direct fee first
        if (entry.fee && typeof entry.fee === 'object' && entry.fee.amount) {
          const feeKey = `direct_${entry.id}_${entry.fee.amount}_${entry.fee.currency}`;
          if (!seenFees.has(feeKey)) {
            seenFees.add(feeKey);
            return sum.plus(entry.fee.amount);
          }
        }

        // Check nested fee structures in buy/sell info
        const nestedInfo = entry.info?.info;
        if (nestedInfo?.buy?.fee?.amount) {
          const orderId = nestedInfo.buy?.id || 'unknown';
          const feeKey = `buy_${orderId}_${nestedInfo.buy.fee.amount}_${nestedInfo.buy.fee.currency}`;
          if (!seenFees.has(feeKey)) {
            seenFees.add(feeKey);
            return sum.plus(new Decimal(nestedInfo.buy.fee.amount));
          }
        }
        if (nestedInfo?.sell?.fee?.amount) {
          const orderId = nestedInfo.sell?.id || 'unknown';
          const feeKey = `sell_${orderId}_${nestedInfo.sell.fee.amount}_${nestedInfo.sell.fee.currency}`;
          if (!seenFees.has(feeKey)) {
            seenFees.add(feeKey);
            return sum.plus(new Decimal(nestedInfo.sell.fee.amount));
          }
        }

        return sum;
      }, new Decimal(0));


      // Get fee currency from the first entry that has a fee
      let feeCurrency = entries.find(e => e.fee && typeof e.fee === 'object' && e.fee.currency)?.fee?.currency;

      // If no direct fee currency, check nested structures
      if (!feeCurrency) {
        for (const entry of entries) {
          const nestedInfo = entry.info?.info;
          if (nestedInfo?.buy?.fee?.currency) {
            feeCurrency = nestedInfo.buy.fee.currency;
            break;
          }
          if (nestedInfo?.sell?.fee?.currency) {
            feeCurrency = nestedInfo.sell.fee.currency;
            break;
          }
        }
      }

      // Calculate price excluding fees if fee currency matches quote currency
      // COINBASE PRICE SEMANTICS:
      // - Coinbase's "total" includes fees (e.g., 747.94 CAD = 736.96 cost + 10.98 fee)
      // - We want "price" to be the net cost of the asset (736.96 CAD)
      // - Only subtract fees if they're in the same currency as the price
      let priceAmount = totalQuoteAmount;
      if (totalFee.greaterThan(0) && feeCurrency === quoteCurrency) {
        priceAmount = totalQuoteAmount.minus(totalFee);
      }

      const combinedTrade: CryptoTransaction = {
        id: `${groupId}-combined`,
        type: 'trade',
        timestamp,
        datetime: new Date(timestamp).toISOString(),
        symbol: symbol || 'unknown',
        amount: { amount: totalBaseAmount, currency: baseCurrency },
        side: side as 'buy' | 'sell',
        price: { amount: priceAmount, currency: quoteCurrency },
        fee: totalFee.greaterThan(0) && feeCurrency ? {
          amount: totalFee,
          currency: feeCurrency
        } : undefined,
        status: 'closed',
        info: {
          groupId,
          entries: entries.map(e => e.info),
          combinedBy: 'CoinbaseCCXTAdapter'
        }
      };


      return combinedTrade;
    }

    // Fallback: single entry trade
    return baseEntry ? this.convertLedgerEntryToTrade(baseEntry) : null;
  }

  /**
   * Convert a Coinbase ledger entry to a proper transaction with correct price, side, and type
   */
  private convertLedgerEntryToTrade(transaction: CryptoTransaction): CryptoTransaction {
    const info = transaction.info;
    if (!info) return transaction;

    // Extract the proper transaction type from Coinbase ledger entry
    const properType = this.extractTransactionType(info);

    // Extract symbol, side, and price information
    const symbol = this.extractSymbolFromInfo(info);
    const side = this.extractSideFromInfo(info);
    const price = this.extractPriceFromInfo(info, transaction.price, properType);

    // Create a proper transaction from the ledger entry
    const enhancedTransaction: CryptoTransaction = {
      ...transaction,
      type: properType,
      symbol,
      side: side as 'buy' | 'sell',
      price,
      info: {
        ...info,
        convertedBy: 'CoinbaseCCXTAdapter',
        originalType: info.type
      }
    };

    return enhancedTransaction;
  }

  /**
   * Determine if transaction is trade-related
   */
  private isTradeRelatedTransaction(transaction: CryptoTransaction): boolean {
    const info = transaction.info;
    if (!info) return false;

    const type = info.type?.toLowerCase() || '';

    // Coinbase ledger entries that represent trades
    return type === 'trade' ||
      type === 'advanced_trade_fill' ||
      type === 'match';
  }

  /**
   * Extract the proper transaction type from Coinbase ledger entry
   */
  private extractTransactionType(info: any): TransactionType {
    const type = info.type?.toLowerCase() || '';

    // First check the deeply nested info structure for more specific types
    const nestedInfo = info?.info;
    const deepNestedInfo = nestedInfo?.info;

    // Check the deepest nested type first (most specific)
    if (deepNestedInfo?.type) {
      const deepType = deepNestedInfo.type.toLowerCase();
      switch (deepType) {
        case 'buy':
        case 'sell':
          return 'trade';
        case 'send':
          // COINBASE "SEND" CONFUSION: 
          // A "send" transaction can be either a deposit OR withdrawal depending on direction.
          // - send + direction:"in" = Someone sent crypto TO you (deposit)
          // - send + direction:"out" = You sent crypto to someone else (withdrawal)
          // This reflects Coinbase's perspective: "send" is the transaction type, direction shows the flow.
          return info.direction === 'in' ? 'deposit' : 'withdrawal';
        case 'request':
          return 'deposit';
        case 'transfer':
          return 'transfer';
        case 'fiat_deposit':
          return 'deposit';
        case 'fiat_withdrawal':
          return 'withdrawal';
        case 'subscription':
        case 'subscription_fee':
        case 'subscription_payment':
          return 'fee';
        case 'retail_simple_dust':
          // Dust conversion - small amounts converted to base currency
          return 'trade';
      }
    }

    // Check the first nested level
    if (nestedInfo?.type) {
      const nestedType = nestedInfo.type.toLowerCase();
      switch (nestedType) {
        case 'buy':
        case 'sell':
          return 'trade';
        case 'send':
          // COINBASE "SEND" CONFUSION: 
          // A "send" transaction can be either a deposit OR withdrawal depending on direction.
          // - send + direction:"in" = Someone sent crypto TO you (deposit)
          // - send + direction:"out" = You sent crypto to someone else (withdrawal)
          // This reflects Coinbase's perspective: "send" is the transaction type, direction shows the flow.
          return info.direction === 'in' ? 'deposit' : 'withdrawal';
        case 'request':
          return 'deposit';
        case 'transfer':
          return 'transfer';
        case 'fiat_deposit':
          return 'deposit';
        case 'fiat_withdrawal':
          return 'withdrawal';
        case 'subscription':
        case 'subscription_fee':
        case 'subscription_payment':
          return 'fee';
        case 'retail_simple_dust':
          // Dust conversion - small amounts converted to base currency
          return 'trade';
      }
    }

    // Map Coinbase ledger types to our transaction types
    switch (type) {
      case 'trade':
      case 'advanced_trade_fill':
      case 'match':
        return 'trade';
      case 'deposit':
      case 'pro_deposit':
      case 'coinbase_deposit':
        return 'deposit';
      case 'withdrawal':
      case 'pro_withdrawal':
      case 'coinbase_withdrawal':
      case 'send':
        // Check direction: 'in' means receiving (deposit), 'out' means sending (withdrawal)
        return info.direction === 'in' ? 'deposit' : 'withdrawal';
      case 'transfer':
      case 'pro_transfer':
        return 'transfer';
      case 'fee':
      case 'advanced_trade_fee':
      case 'subscription':
      case 'subscription_fee':
      case 'subscription_payment':
        return 'fee';
      case 'retail_simple_dust':
        // Dust conversion - small amounts converted to base currency
        return 'trade';
      default:
        // Log error for unparseable transaction types - these should not exist
        this.logger.error(`Unable to determine transaction type from Coinbase ledger entry - Type: ${type}, NestedType: ${nestedInfo?.type}, DeepNestedType: ${deepNestedInfo?.type}, Direction: ${info.direction}, TransactionId: ${info.id}, RawInfo: ${JSON.stringify(info, null, 2)}`);

        // Throw error instead of falling back to 'ledger' type
        throw new Error(`Cannot determine transaction type for Coinbase entry: ${type} (ID: ${info.id || 'unknown'})`)
    }
  }

  /**
   * Extract symbol from transaction info
   * 
   * COINBASE SYMBOL EXTRACTION COMPLEXITY:
   * Symbols are buried deep in nested structures and can be in multiple locations:
   * 1. info.info.advanced_trade_fill.product_id (most reliable for trades)
   * 2. info.info.buy.product_id or info.info.sell.product_id  
   * 3. Fallback to top-level fields (often missing)
   * 
   * The double-nested structure (info.info) is due to CCXT wrapping Coinbase's response.
   */
  private extractSymbolFromInfo(info: any): string | undefined {
    // Check the deeply nested structure first for advanced_trade_fill (most reliable)
    const nestedInfo = info?.info;
    if (nestedInfo?.advanced_trade_fill?.product_id) {
      return nestedInfo.advanced_trade_fill.product_id;
    }

    // Check for buy/sell nested structures
    if (nestedInfo?.buy?.product_id) {
      return nestedInfo.buy.product_id;
    }

    if (nestedInfo?.sell?.product_id) {
      return nestedInfo.sell.product_id;
    }

    // Check for trade nested structure
    if (nestedInfo?.trade?.product_id) {
      return nestedInfo.trade.product_id;
    }

    return info?.symbol ||
      info?.product_id ||
      info?.currency_pair ||
      undefined;
  }


  /**
   * Extract trade side from transaction info
   */
  private extractSideFromInfo(info: any): string {
    // First check explicit side fields
    if (info?.order_side) return info.order_side;
    if (info?.side) return info.side;
    if (info?.trade_side) return info.trade_side;

    // For Coinbase Advanced Trade, infer from direction and nested info
    const nestedInfo = info?.info;
    if (nestedInfo) {
      if (nestedInfo.buy) return 'buy';
      if (nestedInfo.sell) return 'sell';
    }

    // Infer from direction for non-trade transactions
    if (info?.direction === 'in') return 'buy'; // Receiving currency
    if (info?.direction === 'out') return 'sell'; // Sending currency

    // Try to infer from amount sign (if available)
    if (info?.amount && typeof info.amount === 'number') {
      return info.amount > 0 ? 'buy' : 'sell';
    }

    return 'unknown';
  }

  /**
   * Extract price information from Coinbase ledger entry
   * 
   * COINBASE PRICE EXTRACTION RULES:
   * 1. Only trade transactions should have prices (deposits/withdrawals are transfers, not exchanges)
   * 2. Price represents the total cost/proceeds, not per-unit price
   * 3. For buy/sell transactions, extract from nested buy.total or sell.total
   * 4. These totals include fees, which we subtract later in combineMultipleLedgerEntries
   */
  private extractPriceFromInfo(info: any, fallbackPrice?: Money, transactionType?: string): Money | undefined {
    // CRITICAL: Don't extract price for deposits and withdrawals - they're transfers, not trades
    if (transactionType === 'deposit' || transactionType === 'withdrawal') {
      return undefined;
    }

    // For Coinbase buy/sell transactions, extract total cost from nested structure
    const nestedInfo = info?.info;
    if (nestedInfo?.buy) {
      const buyInfo = nestedInfo.buy;
      if (buyInfo.total?.amount && buyInfo.total?.currency) {
        // Return the total cost (what was spent)
        return {
          amount: new Decimal(Math.abs(parseFloat(buyInfo.total.amount))),
          currency: buyInfo.total.currency
        };
      }
    }

    if (nestedInfo?.sell) {
      const sellInfo = nestedInfo.sell;
      if (sellInfo.total?.amount && sellInfo.total?.currency) {
        // Return the total proceeds (what was received)
        return {
          amount: new Decimal(Math.abs(parseFloat(sellInfo.total.amount))),
          currency: sellInfo.total.currency
        };
      }
    }

    // For trade transaction types, check for total or amount fields
    if (transactionType === 'trade' || transactionType === 'limit' || transactionType === 'market') {
      if (info?.total && typeof info.total === 'number') {
        return {
          amount: new Decimal(Math.abs(info.total)),
          currency: info?.currency || 'USD'
        };
      }

      if (info?.amount && typeof info.amount === 'number') {
        return {
          amount: new Decimal(Math.abs(info.amount)),
          currency: info?.currency || 'USD'
        };
      }
    }

    // Use fallback price from CCXT if available for trade transactions only
    if ((transactionType === 'trade' || transactionType === 'limit' || transactionType === 'market') && fallbackPrice) {
      return fallbackPrice;
    }

    return undefined;
  }


  /**
   * Override deposits with account-specific logic (inherited from CoinbaseCCXTAdapter)
   */
  async fetchDeposits(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchDeposits']) {
        this.logger.debug('Coinbase does not support fetchDeposits');
        return [];
      }

      await this.loadAccounts();
      const allDeposits: any[] = [];

      if (!this.accounts || this.accounts.length === 0) {
        this.logger.warn('No accounts available for fetching deposits');
        return [];
      }

      for (const account of this.accounts) {
        try {
          const params = { account_id: account.id };
          const deposits = await this.exchange.fetchDeposits(undefined, since, undefined, params) as any[];
          allDeposits.push(...deposits);
        } catch (accountError) {
          this.logger.warn(`Failed to fetch deposits for account ${account.id} - Error: ${accountError instanceof Error ? accountError.message : 'Unknown error'}`);
        }
      }

      return this.transformTransactions(allDeposits, 'deposit');
    } catch (error) {
      this.handleError(error, 'fetchDeposits');
      throw error;
    }
  }

  /**
   * Override withdrawals with account-specific logic (inherited from CoinbaseCCXTAdapter)
   */
  async fetchWithdrawals(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchWithdrawals']) {
        this.logger.debug('Coinbase does not support fetchWithdrawals');
        return [];
      }

      await this.loadAccounts();
      const allWithdrawals: any[] = [];

      if (!this.accounts || this.accounts.length === 0) {
        this.logger.warn('No accounts available for fetching withdrawals');
        return [];
      }

      for (const account of this.accounts) {
        try {
          const params = { account_id: account.id };
          const withdrawals = await this.exchange.fetchWithdrawals(undefined, since, undefined, params) as any[];
          allWithdrawals.push(...withdrawals);
        } catch (accountError) {
          this.logger.warn(`Failed to fetch withdrawals for account ${account.id} - Error: ${accountError instanceof Error ? accountError.message : 'Unknown error'}`);
        }
      }

      return this.transformTransactions(allWithdrawals, 'withdrawal');
    } catch (error) {
      this.handleError(error, 'fetchWithdrawals');
      throw error;
    }
  }

  /**
   * Load Coinbase accounts (inherited from CoinbaseCCXTAdapter)
   */
  private async loadAccounts(): Promise<void> {
    if (this.accounts !== null) {
      return; // Already loaded
    }

    try {
      this.logger.info('Loading Coinbase accounts for ledger adapter...');

      // First try fetchAccounts
      if (this.exchange.has['fetchAccounts']) {
        try {
          const accounts = await this.exchange.fetchAccounts();


          this.accounts = accounts.filter((account: any) => {
            // Coinbase Advanced Trade account structure uses 'code' for currency
            const hasId = account.id;
            const hasCurrency = account.code; // Use 'code' field for currency


            return hasId && hasCurrency; // Include all account types, not just 'wallet'
          }).map((account: any) => ({
            id: account.id,
            currency: account.code, // Use 'code' field for currency
            balance: 0, // We don't need balance for ledger fetching
            type: account.type || 'wallet'
          }));

          if ((this.accounts ?? []).length > 0) {
            this.logger.info(`Loaded ${this.accounts!.length} Coinbase accounts for ledger processing`);
            return;
          } else {
            this.logger.warn('fetchAccounts returned accounts but none were valid, trying balance fallback');
          }
        } catch (fetchAccountsError) {
          this.logger.warn(`fetchAccounts failed, trying balance fallback - Error: ${fetchAccountsError instanceof Error ? fetchAccountsError.message : 'Unknown error'}`);
        }
      } else {
        this.logger.info('fetchAccounts not supported, using balance fallback');
      }

      // Fallback: create accounts from balance data
      this.logger.info('Using balance data to create accounts...');
      const balance = await this.exchange.fetchBalance();


      this.accounts = [];

      for (const [currency, balanceInfo] of Object.entries(balance)) {
        if (currency === 'info' || currency === 'free' || currency === 'used' || currency === 'total') {
          continue;
        }
        const info = balanceInfo as any;


        if (info && typeof info === 'object') { // Include zero-balance accounts for historical transactions
          this.accounts.push({
            id: `${currency.toLowerCase()}-account`,
            currency: currency,
            balance: info.total || 0,
            type: 'spot'
          });
        }
      }

      this.logger.info(`Created ${this.accounts.length} fallback accounts from balance data`);

      if (this.accounts.length === 0) {
        this.logger.error('No accounts could be loaded from either fetchAccounts or balance data');
      }

    } catch (error) {
      this.logger.error(`Failed to load Coinbase accounts - Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
      this.accounts = [];
      throw error;
    }
  }
}===== ./src/exchanges/csv-parser.ts =====
import { parse } from 'csv-parse/sync';
import fs from 'fs/promises';

/**
 * Generic CSV file parser with common preprocessing
 */
export class CsvParser {
  /**
   * Parse a CSV file into typed objects
   * @param filePath Path to the CSV file
   * @returns Array of parsed rows as objects
   */
  static async parseFile<T>(filePath: string): Promise<T[]> {
    const content = await fs.readFile(filePath, 'utf-8');
    const cleanContent = content.replace(/^\uFEFF/, ''); // Remove BOM

    return parse(cleanContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    }) as T[];
  }

  /**
   * Validate CSV headers against expected format
   * @param filePath Path to the CSV file
   * @param expectedHeaders Map of header strings to file types
   * @returns The file type or 'unknown'
   */
  static async validateHeaders(
    filePath: string,
    expectedHeaders: Record<string, string>
  ): Promise<string> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const cleanContent = content.replace(/^\uFEFF/, ''); // Remove BOM
      const lines = cleanContent.split('\n');

      if (lines.length === 0) return 'unknown';

      const headerLine = lines[0]?.trim() ?? '';
      
      // Find matching header
      for (const [expectedHeader, fileType] of Object.entries(expectedHeaders)) {
        if (headerLine === expectedHeader) {
          return fileType;
        }
      }

      return 'unknown';
    } catch (error) {
      return 'unknown';
    }
  }

  /**
   * Get the first line (header) of a CSV file for debugging
   * @param filePath Path to the CSV file
   * @returns The header line or empty string
   */
  static async getHeaders(filePath: string): Promise<string> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const cleanContent = content.replace(/^\uFEFF/, '');
      const lines = cleanContent.split('\n');
      return lines[0]?.trim() ?? '';
    } catch (error) {
      return '';
    }
  }
}===== ./src/exchanges/types.ts =====
import type { CryptoTransaction } from '@crypto/core';

// Exchange adapter types and interfaces
export interface ExchangeInfo {
  id: string;
  name: string;
  version?: string;
  capabilities: ExchangeCapabilities;
  rateLimit?: number;
}

export interface ExchangeCapabilities {
  fetchMyTrades: boolean;
  fetchDeposits: boolean;
  fetchWithdrawals: boolean;
  fetchLedger: boolean;
  fetchClosedOrders: boolean;
  fetchBalance: boolean;
  fetchOrderBook: boolean;
  fetchTicker: boolean;
}

// Abstract interface for exchange operations
export interface IExchangeAdapter {
  // Connection and info
  testConnection(): Promise<boolean>;
  getExchangeInfo(): Promise<ExchangeInfo>;

  // Transaction fetching
  fetchAllTransactions(since?: number): Promise<CryptoTransaction[]>;
  fetchTrades(since?: number): Promise<CryptoTransaction[]>;
  fetchDeposits(since?: number): Promise<CryptoTransaction[]>;
  fetchWithdrawals(since?: number): Promise<CryptoTransaction[]>;
  fetchClosedOrders(since?: number): Promise<CryptoTransaction[]>;
  fetchLedger(since?: number): Promise<CryptoTransaction[]>;

  // Balance operations
  fetchBalance(): Promise<ExchangeBalance[]>;

  // Cleanup
  close(): Promise<void>;
}

export interface ExchangeBalance {
  currency: string;
  balance: number; // Available/free amount
  used: number;
  total: number;
}===== ./src/exchanges/ccxt-adapter.ts =====
import type { Exchange } from 'ccxt';
import { BaseCCXTAdapter } from './base-ccxt-adapter.ts';

export class CCXTAdapter extends BaseCCXTAdapter {
  constructor(exchange: Exchange, exchangeId: string, enableOnlineVerification: boolean = false) {
    super(exchange, exchangeId, enableOnlineVerification, 'CCXTAdapter');
  }

  protected createExchange(): Exchange {
    // Exchange is already created and passed in constructor
    return this.exchange;
  }
}===== ./src/exchanges/kucoin/csv-adapter.ts =====
import type { CryptoTransaction, ExchangeInfo, TransactionStatus, TransactionType } from '@crypto/core';
import { createMoney, parseDecimal } from '@crypto/shared-utils';
import type { CSVConfig } from '../base-csv-adapter.ts';
import { BaseCSVAdapter } from '../base-csv-adapter.ts';
interface KuCoinCSVConfig extends CSVConfig { }

// Expected CSV headers for validation
const EXPECTED_HEADERS = {
  TRADING_CSV: 'UID,Account Type,Order ID,Order Time(UTC),Symbol,Side,Order Type,Order Price,Order Amount,Avg. Filled Price,Filled Amount,Filled Volume,Filled Volume (USDT),Filled Time(UTC),Fee,Fee Currency,Tax,Status',
  DEPOSIT_CSV: 'UID,Account Type,Time(UTC),Coin,Amount,Fee,Hash,Deposit Address,Transfer Network,Status,Remarks',
  WITHDRAWAL_CSV: 'UID,Account Type,Time(UTC),Coin,Amount,Fee,Hash,Withdrawal Address/Account,Transfer Network,Status,Remarks',
  CONVERT_CSV: 'UID,Account Type,Payment Account,Sell,Buy,Price,Tax,Time of Update(UTC),Status', // Legacy - not used, we get converts from account history
  ACCOUNT_HISTORY_CSV: 'UID,Account Type,Currency,Side,Amount,Fee,Time(UTC),Remark,Type'
};

interface SpotOrderRow {
  UID: string;
  'Account Type': string;
  'Order ID': string;
  'Order Time(UTC)': string;
  Symbol: string;
  Side: string;
  'Order Type': string;
  'Order Price': string;
  'Order Amount': string;
  'Avg. Filled Price': string;
  'Filled Amount': string;
  'Filled Volume': string;
  'Filled Volume (USDT)': string;
  'Filled Time(UTC)': string;
  Fee: string;
  'Fee Currency': string;
  Tax?: string;
  Status: string;
}

interface DepositWithdrawalRow {
  UID: string;
  'Account Type': string;
  'Time(UTC)': string;
  Coin: string;
  Amount: string;
  Fee: string;
  Hash: string;
  'Deposit Address'?: string;
  'Transfer Network': string;
  Status: string;
  Remarks: string;
}

interface AccountHistoryRow {
  UID: string;
  'Account Type': string;
  Currency: string;
  Side: string;
  Amount: string;
  Fee: string;
  'Time(UTC)': string;
  Remark: string;
  Type: string;
}

export class KuCoinCSVAdapter extends BaseCSVAdapter {
  constructor(config: KuCoinCSVConfig) {
    super(config, 'KuCoinCSVAdapter');
  }

  protected getExpectedHeaders(): Record<string, string> {
    return {
      [EXPECTED_HEADERS.TRADING_CSV]: 'trading',
      [EXPECTED_HEADERS.DEPOSIT_CSV]: 'deposit',
      [EXPECTED_HEADERS.WITHDRAWAL_CSV]: 'withdrawal',
      [EXPECTED_HEADERS.CONVERT_CSV]: 'convert',
      [EXPECTED_HEADERS.ACCOUNT_HISTORY_CSV]: 'account_history'
    };
  }

  protected getFileTypeHandlers(): Record<string, (filePath: string) => Promise<CryptoTransaction[]>> {
    return {
      'trading': (filePath) => this.parseSpotOrders(filePath),
      'deposit': (filePath) => this.parseDepositHistory(filePath),
      'withdrawal': (filePath) => this.parseWithdrawalHistory(filePath),
      'convert': (filePath) => {
        this.logger.warn(`Skipping convert orders CSV file - using account history instead - File: ${filePath}`);
        return Promise.resolve([]);
      },
      'account_history': (filePath) => this.parseAccountHistory(filePath)
    };
  }

  private mapStatus(status: string, type: 'spot' | 'deposit_withdrawal'): TransactionStatus {
    if (!status) return 'pending';

    const statusLower = status.toLowerCase();

    if (type === 'spot') {
      switch (statusLower) {
        case 'deal': return 'closed';
        case 'part_deal': return 'open';
        case 'cancel': return 'canceled';
        default: return 'pending';
      }
    } else { // deposit_withdrawal
      switch (statusLower) {
        case 'success': return 'ok';
        case 'pending': return 'pending';
        case 'failed': return 'failed';
        case 'canceled': return 'canceled';
        default: return 'pending';
      }
    }
  }

  async getExchangeInfo(): Promise<ExchangeInfo> {
    return {
      id: 'kucoin',
      name: 'KuCoin CSV',
      version: '1.0.0',
      capabilities: {
        fetchMyTrades: true,
        fetchDeposits: true,
        fetchWithdrawals: true,
        fetchLedger: false, // Ledger entries removed to prevent double-counting
        fetchClosedOrders: true,
        fetchBalance: false, // CSV doesn't provide current balances
        fetchOrderBook: false,
        fetchTicker: false
      }
    };
  }


  private async parseSpotOrders(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<SpotOrderRow>(filePath);
    return this.filterByUid(rows).map(row => this.convertSpotOrderToTransaction(row));
  }

  private async parseDepositHistory(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<DepositWithdrawalRow>(filePath);
    return this.filterByUid(rows).map(row => this.convertDepositToTransaction(row));
  }

  private async parseWithdrawalHistory(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<DepositWithdrawalRow>(filePath);
    return this.filterByUid(rows).map(row => this.convertWithdrawalToTransaction(row));
  }

  private async parseAccountHistory(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<AccountHistoryRow>(filePath);
    const filteredRows = this.filterByUid(rows);

    // Find Convert Market transactions and pair them
    const convertTransactions: CryptoTransaction[] = [];
    const convertMarketRows = filteredRows.filter(row => row.Type === 'Convert Market');

    // Group convert market entries by timestamp
    const convertGroups = new Map<string, AccountHistoryRow[]>();

    for (const row of convertMarketRows) {
      const timestamp = row['Time(UTC)'];
      if (!convertGroups.has(timestamp)) {
        convertGroups.set(timestamp, []);
      }
      convertGroups.get(timestamp)!.push(row);
    }

    // Process each group of convert transactions
    for (const [timestamp, group] of convertGroups) {
      if (group.length === 2) {
        // Should be one deposit and one withdrawal
        const deposit = group.find(row => row.Side === 'Deposit');
        const withdrawal = group.find(row => row.Side === 'Withdrawal');

        if (deposit && withdrawal) {
          const convertTx = this.convertAccountHistoryConvertToTransaction(deposit, withdrawal, timestamp);
          convertTransactions.push(convertTx);
        } else {
          this.logger.warn(`Convert Market group missing deposit/withdrawal pair - Timestamp: ${timestamp}, Group: ${JSON.stringify(group)}`);
        }
      } else {
        this.logger.warn(`Convert Market group has unexpected number of entries - Timestamp: ${timestamp}, Count: ${group.length}, Group: ${JSON.stringify(group)}`);
      }
    }

    return convertTransactions;
  }

  private convertSpotOrderToTransaction(row: SpotOrderRow): CryptoTransaction {
    const timestamp = new Date(row['Filled Time(UTC)']).getTime();
    const [baseCurrency, quoteCurrency] = row.Symbol.split('-');

    return {
      id: row['Order ID'],
      type: 'trade' as TransactionType,
      timestamp,
      datetime: row['Filled Time(UTC)'],
      symbol: `${baseCurrency}/${quoteCurrency}`,
      amount: createMoney(row['Filled Amount'], baseCurrency || 'unknown'),
      side: row.Side.toLowerCase() as 'buy' | 'sell',
      price: createMoney(row['Filled Volume'], quoteCurrency || 'unknown'),
      fee: createMoney(row.Fee, row['Fee Currency']),
      status: this.mapStatus(row.Status, 'spot'),
      info: {
        originalRow: row,
        orderType: row['Order Type'],
        filledVolume: parseDecimal(row['Filled Volume']).toNumber(),
        filledVolumeUSDT: parseDecimal(row['Filled Volume (USDT)']).toNumber(),
        orderTime: row['Order Time(UTC)'],
        orderPrice: parseDecimal(row['Order Price']).toNumber(),
        orderAmount: parseDecimal(row['Order Amount']).toNumber()
      }
    };
  }

  private convertDepositToTransaction(row: DepositWithdrawalRow): CryptoTransaction {
    const timestamp = new Date(row['Time(UTC)']).getTime();

    return {
      id: row.Hash || `${row.UID}-${timestamp}-${row.Coin}-deposit-${row.Amount}`,
      type: 'deposit' as TransactionType,
      timestamp,
      datetime: row['Time(UTC)'],
      symbol: undefined,
      amount: createMoney(row.Amount, row.Coin),
      side: undefined,
      price: undefined,
      fee: row.Fee ? createMoney(row.Fee, row.Coin) : undefined,
      status: this.mapStatus(row.Status, 'deposit_withdrawal'),
      info: {
        originalRow: row,
        hash: row.Hash,
        network: row['Transfer Network'],
        address: row['Deposit Address'],
        remarks: row.Remarks
      }
    };
  }

  private convertWithdrawalToTransaction(row: DepositWithdrawalRow): CryptoTransaction {
    const timestamp = new Date(row['Time(UTC)']).getTime();

    return {
      id: row.Hash || `${row.UID}-${timestamp}-${row.Coin}-withdrawal-${row.Amount}`,
      type: 'withdrawal' as TransactionType,
      timestamp,
      datetime: row['Time(UTC)'],
      symbol: undefined,
      amount: createMoney(row.Amount, row.Coin),
      side: undefined,
      price: undefined,
      fee: row.Fee ? createMoney(row.Fee, row.Coin) : undefined,
      status: this.mapStatus(row.Status, 'deposit_withdrawal'),
      info: {
        originalRow: row,
        hash: row.Hash,
        network: row['Transfer Network'],
        remarks: row.Remarks
      }
    };
  }


  private convertAccountHistoryConvertToTransaction(deposit: AccountHistoryRow, withdrawal: AccountHistoryRow, timestamp: string): CryptoTransaction {
    const timestampMs = new Date(timestamp).getTime();

    const sellCurrency = withdrawal.Currency;
    const sellAmount = withdrawal.Amount;
    const buyCurrency = deposit.Currency;
    const buyAmount = deposit.Amount;

    // Create a synthetic symbol for the conversion
    const symbol = `${sellCurrency}/${buyCurrency}`;

    // Calculate total fees (both deposit and withdrawal fees)
    const withdrawalFee = withdrawal.Fee ? parseDecimal(withdrawal.Fee).toNumber() : 0;
    const depositFee = deposit.Fee ? parseDecimal(deposit.Fee).toNumber() : 0;

    return {
      id: `${withdrawal.UID}-${timestampMs}-convert-market-${sellCurrency}-${buyCurrency}`,
      type: 'trade' as TransactionType,
      timestamp: timestampMs,
      datetime: timestamp,
      symbol,
      amount: createMoney(sellAmount, sellCurrency),
      side: 'sell' as 'sell',
      price: createMoney(buyAmount, buyCurrency),
      fee: withdrawalFee + depositFee > 0 ? createMoney((withdrawalFee + depositFee).toString(), sellCurrency) : undefined,
      status: 'closed' as TransactionStatus, // Account history entries are completed transactions
      info: {
        type: 'convert_market',
        sellAmount: parseDecimal(sellAmount).toNumber(),
        sellCurrency,
        buyAmount: parseDecimal(buyAmount).toNumber(),
        buyCurrency,
        withdrawalRow: withdrawal,
        depositRow: deposit,
        withdrawalFee,
        depositFee
      }
    };
  }
}===== ./src/exchanges/base-ccxt-adapter.ts =====
// @ts-ignore - CCXT types compatibility
import { CryptoTransaction, ExchangeBalance, ExchangeCapabilities, ExchangeInfo, IExchangeAdapter, ServiceError, TransactionType } from '@crypto/core';
import type { Logger } from '@crypto/shared-logger';
import { getLogger } from '@crypto/shared-logger';

import type { Exchange } from 'ccxt';
import { TransactionTransformer } from '../utils/transaction-transformer.ts';
import { ServiceErrorHandler } from './exchange-error-handler.ts';

/**
 * Base class for all CCXT-based exchange adapters
 * Provides common functionality and eliminates code duplication
 */
export abstract class BaseCCXTAdapter implements IExchangeAdapter {
  protected exchange: Exchange;
  protected logger: Logger;
  protected exchangeId: string;
  protected enableOnlineVerification: boolean;

  constructor(exchange: Exchange, exchangeId: string, enableOnlineVerification: boolean = false, loggerSuffix?: string) {
    this.exchange = exchange;
    this.exchangeId = exchangeId;
    this.enableOnlineVerification = enableOnlineVerification;
    this.logger = getLogger(`${loggerSuffix || 'CCXTAdapter'}:${exchangeId}`);

    // Enable rate limiting and other common settings
    this.exchange.enableRateLimit = true;
    this.exchange.rateLimit = 1000;
  }

  async testConnection(): Promise<boolean> {
    try {
      await this.exchange.loadMarkets();
      await this.exchange.fetchBalance();
      this.logger.info(`Connection test successful for ${this.exchangeId}`);
      return true;
    } catch (error) {
      this.logger.error(`Connection test failed for ${this.exchangeId} - Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return false;
    }
  }

  async getExchangeInfo(): Promise<ExchangeInfo> {
    const capabilities: ExchangeCapabilities = {
      fetchMyTrades: Boolean(this.exchange.has['fetchMyTrades']),
      fetchDeposits: Boolean(this.exchange.has['fetchDeposits']),
      fetchWithdrawals: Boolean(this.exchange.has['fetchWithdrawals']),
      fetchLedger: Boolean(this.exchange.has['fetchLedger']),
      fetchClosedOrders: Boolean(this.exchange.has['fetchClosedOrders']),
      fetchBalance: this.enableOnlineVerification && Boolean(this.exchange.has['fetchBalance']),
      fetchOrderBook: Boolean(this.exchange.has['fetchOrderBook']),
      fetchTicker: Boolean(this.exchange.has['fetchTicker']),
    };

    return {
      id: this.exchangeId,
      name: this.exchange.name || this.exchangeId,
      version: this.exchange.version,
      capabilities,
      rateLimit: this.exchange.rateLimit,
    };
  }

  async fetchAllTransactions(since?: number): Promise<CryptoTransaction[]> {
    const startTime = Date.now();
    this.logger.info(`Starting fetchAllTransactions for ${this.exchangeId}`);

    try {
      const allTransactions: CryptoTransaction[] = [];

      // Fetch different transaction types
      const fetchPromises = [
        this.fetchTrades(since),
        this.fetchDeposits(since),
        this.fetchWithdrawals(since),
        this.fetchClosedOrders(since),
        this.fetchLedger(since)
      ];

      const results = await Promise.allSettled(fetchPromises);
      const labels = ['trades', 'deposits', 'withdrawals', 'closed_orders', 'ledger'];

      // Process all results
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          allTransactions.push(...result.value);
          this.logger.info(`Fetched ${result.value.length} ${labels[index]} from ${this.exchangeId}`);
        } else {
          this.logger.warn(`Failed to fetch ${labels[index]} from ${this.exchangeId} - Error: ${result.reason}`);
        }
      });

      const duration = Date.now() - startTime;
      this.logger.info(`Completed fetchAllTransactions for ${this.exchangeId} - Count: ${allTransactions.length}, Duration: ${duration}ms`);

      return allTransactions;
    } catch (error) {
      throw new ServiceError(
        `Failed to fetch transactions from ${this.exchangeId}`,
        this.exchangeId,
        'fetchAllTransactions',
        error as Error
      );
    }
  }

  async fetchTrades(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchMyTrades']) {
        this.logger.debug(`Exchange ${this.exchangeId} does not support fetchMyTrades`);
        return [];
      }

      const trades = await this.exchange.fetchMyTrades(undefined, since);
      return this.transformTransactions(trades, 'trade');
    } catch (error) {
      this.handleError(error, 'fetchTrades');
      throw error;
    }
  }

  async fetchDeposits(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchDeposits']) {
        this.logger.debug(`Exchange ${this.exchangeId} does not support fetchDeposits`);
        return [];
      }

      const deposits = await this.exchange.fetchDeposits(undefined, since);
      return this.transformTransactions(deposits, 'deposit');
    } catch (error) {
      this.handleError(error, 'fetchDeposits');
      throw error;
    }
  }

  async fetchWithdrawals(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchWithdrawals']) {
        this.logger.debug(`Exchange ${this.exchangeId} does not support fetchWithdrawals`);
        return [];
      }

      const withdrawals = await this.exchange.fetchWithdrawals(undefined, since);
      return this.transformTransactions(withdrawals, 'withdrawal');
    } catch (error) {
      this.handleError(error, 'fetchWithdrawals');
      throw error;
    }
  }

  async fetchClosedOrders(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchClosedOrders']) {
        this.logger.debug(`Exchange ${this.exchangeId} does not support fetchClosedOrders`);
        return [];
      }

      const orders = await this.exchange.fetchClosedOrders(undefined, since);
      return this.transformTransactions(orders, 'order');
    } catch (error) {
      this.handleError(error, 'fetchClosedOrders');
      throw error;
    }
  }

  async fetchLedger(since?: number): Promise<CryptoTransaction[]> {
    try {
      if (!this.exchange.has['fetchLedger']) {
        this.logger.debug(`Exchange ${this.exchangeId} does not support fetchLedger`);
        return [];
      }

      const ledgerEntries = await this.exchange.fetchLedger(undefined, since);
      return this.transformTransactions(ledgerEntries, 'ledger');
    } catch (error) {
      this.handleError(error, 'fetchLedger');
      throw error;
    }
  }

  async fetchBalance(): Promise<ExchangeBalance[]> {
    if (!this.enableOnlineVerification) {
      throw new Error(`Balance fetching not supported for ${this.exchangeId} CCXT adapter - enable online verification to fetch live balances`);
    }

    try {
      const balance = await this.exchange.fetchBalance();

      // Transform CCXT balance format to our standard format
      const balances: ExchangeBalance[] = [];

      for (const [currency, balanceInfo] of Object.entries(balance)) {
        if (currency === 'info' || currency === 'free' || currency === 'used' || currency === 'total') {
          continue; // Skip CCXT metadata fields
        }

        const info = balanceInfo as any;
        if (info && typeof info === 'object' && info.total !== undefined) {
          balances.push({
            currency,
            balance: info.free || 0,
            used: info.used || 0,
            total: info.total || 0,
          });
        }
      }

      return balances;
    } catch (error) {
      this.handleError(error, 'fetchBalance');
      throw error;
    }
  }

  async close(): Promise<void> {
    if (this.exchange && this.exchange.close) {
      await this.exchange.close();
    }
    this.logger.info(`Closed connection to ${this.exchangeId}`);
  }

  /**
   * Transform array of CCXT transactions to our standard format
   * Can be overridden by subclasses for exchange-specific transformation
   */
  protected transformTransactions(transactions: any[], type: TransactionType): CryptoTransaction[] {
    return transactions
      .filter(tx => !TransactionTransformer.shouldFilterOut(tx))
      .map(tx => this.transformTransaction(tx, type));
  }

  /**
   * Transform a single CCXT transaction to our standard format
   * Can be overridden by subclasses for exchange-specific transformation
   */
  protected transformTransaction(transaction: any, type: TransactionType): CryptoTransaction {
    return TransactionTransformer.fromCCXT(transaction, type, this.exchangeId);
  }

  /**
   * Handle errors using centralized error handler
   * Can be overridden by subclasses for exchange-specific error handling
   */
  protected handleError(error: any, operation: string): void {
    ServiceErrorHandler.handle(error, operation, this.exchangeId, this.logger);
  }

  /**
   * Create exchange instance - to be implemented by subclasses
   * This allows each subclass to configure their specific exchange instance
   */
  protected abstract createExchange(): Exchange;

  /**
   * Get exchange-specific capabilities - can be overridden
   * Allows subclasses to modify capabilities based on exchange limitations
   */
  protected getExchangeCapabilities(): Partial<ExchangeCapabilities> {
    return {};
  }
}===== ./src/exchanges/index.ts =====
// Exchange adapters and factory
export { ExchangeAdapterFactory } from './adapter-factory.ts';
===== ./src/exchanges/kraken/csv-adapter.ts =====
import type { CryptoTransaction, ExchangeInfo, TransactionStatus } from '@crypto/core';
import { createMoney, parseDecimal } from '@crypto/shared-utils';
import type { CSVConfig } from '../base-csv-adapter.ts';
import { BaseCSVAdapter } from '../base-csv-adapter.ts';
import { CsvFilters } from '../csv-filters.ts';
interface KrakenCSVConfig extends CSVConfig { }

// Expected CSV headers for validation
const EXPECTED_HEADERS = {
  LEDGERS_CSV: '"txid","refid","time","type","subtype","aclass","asset","wallet","amount","fee","balance"'
};

interface KrakenLedgerRow {
  txid: string;
  refid: string;
  time: string;
  type: string;
  subtype: string;
  aclass: string;
  asset: string;
  wallet: string;
  amount: string;
  fee: string;
  balance: string;
}

export class KrakenCSVAdapter extends BaseCSVAdapter {
  constructor(config: KrakenCSVConfig) {
    super(config, 'KrakenCSVAdapter');
  }

  protected getExpectedHeaders(): Record<string, string> {
    return {
      [EXPECTED_HEADERS.LEDGERS_CSV]: 'ledgers'
    };
  }

  protected getFileTypeHandlers(): Record<string, (filePath: string) => Promise<CryptoTransaction[]>> {
    return {
      'ledgers': (filePath) => this.parseLedgers(filePath)
    };
  }

  private mapStatus(): TransactionStatus {
    // Kraken ledger entries don't have explicit status, assume completed
    return 'closed';
  }

  public async getExchangeInfo(): Promise<ExchangeInfo> {
    return {
      id: 'kraken',
      name: 'Kraken CSV',
      version: '1.0.0',
      capabilities: {
        fetchMyTrades: true,
        fetchDeposits: true,
        fetchWithdrawals: true,
        fetchLedger: true,
        fetchClosedOrders: false,
        fetchBalance: false, // CSV doesn't provide current balances
        fetchOrderBook: false,
        fetchTicker: false
      }
    };
  }

  /**
   * Detects and filters out failed transaction pairs from Kraken withdrawal data.
   * 
   * KRAKEN FAILED TRANSACTION PATTERN:
   * When a transaction fails on Kraken, it creates two ledger entries with the same refid:
   * 1. Negative amount (the attempted transaction) 
   * 2. Positive amount (the credit/refund)
   * 
   * Example failed withdrawal:
   * FTCzTjm-tQU7uzZARTQpgD2APjuRQs  2024-12-27 15:35  withdrawal  -385.1555371   0.5  0
   * FTCzTjm-tQU7uzZARTQpgD2APjuRQs  2024-12-27 15:36  withdrawal   385.1555371  -0.5  385.6555371
   * 
   * The net effect should be zero - these transactions cancel each other out.
   * We filter these out to avoid double-counting and incorrect balance calculations.
   * 
   * @param withdrawalRows All withdrawal rows from the CSV
   * @returns Object containing valid withdrawals and failed transaction refids
   */
  private filterFailedTransactions(withdrawalRows: KrakenLedgerRow[]): {
    validWithdrawals: KrakenLedgerRow[];
    failedTransactionRefIds: Set<string>;
  } {
    const failedTransactionRefIds = new Set<string>();
    const validWithdrawals: KrakenLedgerRow[] = [];

    // Group withdrawals by refid to detect failed transaction pairs
    const withdrawalsByRefId = CsvFilters.groupByField(withdrawalRows, 'refid');

    for (const [refId, group] of withdrawalsByRefId) {
      if (group.length === 2) {
        // Check if this looks like a failed transaction pair
        const negative = group.find(w => parseDecimal(w.amount).lt(0));
        const positive = group.find(w => parseDecimal(w.amount).gt(0));

        if (negative && positive && this.isFailedTransactionPair(negative, positive)) {
          // This is a failed transaction - mark refid as failed and skip both entries
          failedTransactionRefIds.add(refId);
          this.logger.info(`Failed transaction detected and filtered: refid=${refId}, ` +
            `attempted=${negative.amount} ${negative.asset}, ` +
            `credited=${positive.amount} ${positive.asset}`);
          continue;
        }
      }

      // Not a failed transaction pair - add all entries to valid withdrawals
      validWithdrawals.push(...group);
    }

    this.logger.info(`Withdrawal filtering: ${withdrawalRows.length} total, ` +
      `${validWithdrawals.length} valid, ` +
      `${failedTransactionRefIds.size} failed transaction pairs filtered`);

    return { validWithdrawals, failedTransactionRefIds };
  }

  /**
   * Determines if two withdrawal entries represent a failed transaction pair.
   * 
   * Criteria for failed transaction detection:
   * 1. Same asset
   * 2. Amounts are approximately equal but opposite signs
   * 3. Fees are also opposite (negative fee indicates fee refund)
   * 4. Time difference is small (within 24 hours)
   * 5. Net balance change should be approximately zero
   * 
   * @param negative The negative (attempted) transaction
   * @param positive The positive (credit) transaction
   * @returns true if this appears to be a failed transaction pair
   */
  private isFailedTransactionPair(negative: KrakenLedgerRow, positive: KrakenLedgerRow): boolean {
    // Must be same asset
    if (negative.asset !== positive.asset) {
      return false;
    }

    // Amounts should be approximately equal but opposite
    const negativeAmount = parseDecimal(negative.amount).abs();
    const positiveAmount = parseDecimal(positive.amount);
    const amountDiff = negativeAmount.minus(positiveAmount).abs();
    const relativeDiff = amountDiff.div(negativeAmount);

    if (relativeDiff.gt(0.001)) { // More than 0.1% difference
      return false;
    }

    // Check fees - they should be opposite (negative fee = refund)
    const negativeFee = parseDecimal(negative.fee || '0');
    const positiveFee = parseDecimal(positive.fee || '0');

    // For failed transactions, the fee pattern should be: positive fee, then negative fee (refund)
    const feesAreOpposite = negativeFee.gt(0) && positiveFee.lt(0) &&
      negativeFee.plus(positiveFee).abs().lt(0.001);

    if (!feesAreOpposite) {
      return false;
    }

    // Check time difference (should be within 24 hours for failed transactions)
    const negativeTime = new Date(negative.time).getTime();
    const positiveTime = new Date(positive.time).getTime();
    const timeDiff = Math.abs(positiveTime - negativeTime);
    const maxTimeDiff = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

    if (timeDiff > maxTimeDiff) {
      return false;
    }

    return true;
  }

  private async parseLedgers(filePath: string): Promise<CryptoTransaction[]> {
    const rows = await this.parseCsvFile<KrakenLedgerRow>(filePath);
    const transactions: CryptoTransaction[] = [];

    // Separate transactions by type
    const tradeRows = rows.filter(row => row.type === 'trade');
    const depositRows = rows.filter(row => row.type === 'deposit');
    const transferRows = rows.filter(row => row.type === 'transfer');
    const spendRows = rows.filter(row => row.type === 'spend');
    const receiveRows = rows.filter(row => row.type === 'receive');

    // Filter out failed transactions and get valid withdrawals
    const { validWithdrawals, failedTransactionRefIds } = this.filterFailedTransactions(
      rows.filter(row => row.type === 'withdrawal')
    );

    // Process existing single trade records
    for (const trade of tradeRows) {
      const transaction = this.convertSingleTradeToTransaction(trade);
      transactions.push(transaction);
    }

    // Process spend/receive pairs by grouping by refid
    const spendReceiveRows = [...spendRows, ...receiveRows];
    const tradeGroups = CsvFilters.groupByField(spendReceiveRows, 'refid');
    const processedRefIds = new Set<string>();

    for (const [refId, group] of tradeGroups) {
      if (group.length === 2) {
        const spend = group.find(row => parseDecimal(row.amount).lt(0) || row.type === 'spend');
        const receive = group.find(row => parseDecimal(row.amount).gt(0) || row.type === 'receive');

        if (spend && receive) {
          const transaction = this.convertTradeToTransaction(spend, receive);
          transactions.push(transaction);
          processedRefIds.add(refId);
        }
      } else if (group.length > 2) {
        // Handle dustsweeping - multiple spends for one receive (small amounts)
        const receive = group.find(row => parseDecimal(row.amount).gt(0) && (row.type === 'receive' || row.type === 'trade'));
        const spends = group.filter(row => parseDecimal(row.amount).lt(0) && (row.type === 'spend' || row.type === 'trade'));

        if (receive && spends.length > 0) {
          const receiveAmount = parseDecimal(receive.amount).abs().toNumber();

          // Kraken dustsweeping: small amounts (< 1) get converted, creating multiple spends for one receive
          if (receiveAmount < 1) {
            this.logger.warn(`Dustsweeping detected for refid ${refId}: ${receiveAmount} ${receive.asset} with ${spends.length} spend transactions`);

            // Create deposit transaction for the received amount
            const depositTransaction = this.convertDepositToTransaction(receive);
            depositTransaction.info = {
              ...depositTransaction.info,
              dustsweeping: true,
              relatedRefId: refId
            };
            transactions.push(depositTransaction);

            // Create withdrawal transactions for each spend
            for (const spend of spends) {
              const withdrawalTransaction = this.convertWithdrawalToTransaction(spend);
              withdrawalTransaction.info = {
                ...withdrawalTransaction.info,
                dustsweeping: true,
                relatedRefId: refId
              };
              transactions.push(withdrawalTransaction);
            }

            processedRefIds.add(refId);
          } else {
            this.logger.error(`Trade with more than 2 currencies detected for refid ${refId}. This is not supported.`);
          }
        }
      }
    }

    // Process deposits
    for (const deposit of depositRows) {
      const transaction = this.convertDepositToTransaction(deposit);
      transactions.push(transaction);
    }

    // Process valid withdrawals (failed transactions already filtered out)
    for (const withdrawal of validWithdrawals) {
      const transaction = this.convertWithdrawalToTransaction(withdrawal);
      transactions.push(transaction);
    }

    // Process token migrations (transfer transactions)
    const migrationTransactions = this.processTokenMigrations(transferRows);
    transactions.push(...migrationTransactions.transactions);

    // Add processed transfer refids to avoid double processing
    for (const refId of migrationTransactions.processedRefIds) {
      processedRefIds.add(refId);
    }

    // Validate that all CSV records were processed
    this.validateAllRecordsProcessed(rows, {
      tradeRows,
      depositRows,
      validWithdrawals,
      transferRows,
      spendRows,
      receiveRows,
      processedRefIds,
      failedTransactionRefIds
    });

    return transactions;
  }

  private processTokenMigrations(transferRows: KrakenLedgerRow[]): {
    transactions: CryptoTransaction[];
    processedRefIds: string[];
  } {
    const transactions: CryptoTransaction[] = [];
    const processedRefIds: string[] = [];

    // Group transfers by date and amount to detect token migrations
    const transfersByDate = this.groupTransfersByDateAndAmount(transferRows);

    for (const group of transfersByDate) {
      if (group.length === 2) {
        const negative = group.find(t => parseDecimal(t.amount).lt(0));
        const positive = group.find(t => parseDecimal(t.amount).gt(0));

        if (negative && positive && negative.asset !== positive.asset) {
          // This looks like a token migration (RNDR -> RENDER)
          const negativeAmount = parseDecimal(negative.amount).abs().toNumber();
          const positiveAmount = parseDecimal(positive.amount).toNumber();

          // Amounts should be approximately equal (allowing for small precision differences)
          const amountDiff = Math.abs(negativeAmount - positiveAmount);
          const relativeDiff = amountDiff / Math.max(negativeAmount, positiveAmount);

          if (relativeDiff < 0.001) { // Less than 0.1% difference
            this.logger.info(`Token migration detected: ${negativeAmount} ${negative.asset} -> ${positiveAmount} ${positive.asset}`);

            const migrationTransaction = this.convertTokenMigrationToTransaction(negative, positive);
            transactions.push(migrationTransaction);

            processedRefIds.push(negative.refid, positive.refid);
            continue;
          }
        }
      }

      // Process remaining transfers as individual transactions
      for (const transfer of group) {
        if (!processedRefIds.includes(transfer.refid)) {
          const transaction = this.convertTransferToTransaction(transfer);
          transactions.push(transaction);
          processedRefIds.push(transfer.refid);
        }
      }
    }

    return { transactions, processedRefIds };
  }

  private groupTransfersByDateAndAmount(transferRows: KrakenLedgerRow[]): KrakenLedgerRow[][] {
    const groups: KrakenLedgerRow[][] = [];
    const processed = new Set<string>();

    for (const transfer of transferRows) {
      if (processed.has(transfer.txid)) continue;

      const amount = parseDecimal(transfer.amount).abs().toNumber();
      const transferDate = new Date(transfer.time).toDateString();

      // Find potential matching transfer (opposite sign, same amount, same date)
      const match = transferRows.find(t =>
        !processed.has(t.txid) &&
        t.txid !== transfer.txid &&
        parseDecimal(t.amount).abs().minus(amount).abs().lt(0.001) &&
        parseDecimal(t.amount).isPositive() !== parseDecimal(transfer.amount).isPositive() &&
        new Date(t.time).toDateString() === transferDate
      );

      if (match) {
        groups.push([transfer, match]);
        processed.add(transfer.txid);
        processed.add(match.txid);
      } else {
        groups.push([transfer]);
        processed.add(transfer.txid);
      }
    }

    return groups;
  }

  private convertTokenMigrationToTransaction(negative: KrakenLedgerRow, positive: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(negative.time).getTime();
    const sentAmount = parseDecimal(negative.amount).abs().toNumber();
    const receivedAmount = parseDecimal(positive.amount).toNumber();

    return {
      id: `${negative.txid}_${positive.txid}`,
      type: 'trade',
      timestamp,
      datetime: negative.time,
      symbol: `${positive.asset}/${negative.asset}`,
      side: 'buy',
      amount: createMoney(receivedAmount, positive.asset),
      price: createMoney(sentAmount, negative.asset),
      fee: createMoney(0, positive.asset), // Token migrations typically have no fees
      status: this.mapStatus(),
      info: {
        tokenMigration: true,
        fromAsset: negative.asset,
        toAsset: positive.asset,
        fromTransaction: negative,
        toTransaction: positive,
        originalRows: { negative, positive }
      }
    };
  }

  private convertTransferToTransaction(transfer: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(transfer.time).getTime();
    const isIncoming = parseDecimal(transfer.amount).isPositive();

    return {
      id: transfer.txid,
      type: isIncoming ? 'deposit' : 'withdrawal',
      timestamp,
      datetime: transfer.time,
      symbol: undefined,
      side: undefined,
      amount: createMoney(parseDecimal(transfer.amount).abs().toNumber(), transfer.asset),
      price: undefined,
      fee: createMoney(parseDecimal(transfer.fee || '0').toNumber(), transfer.asset),
      status: this.mapStatus(),
      info: {
        originalRow: transfer,
        transferType: transfer.subtype,
        wallet: transfer.wallet,
        isTransfer: true
      }
    };
  }

  private validateAllRecordsProcessed(
    allRows: KrakenLedgerRow[],
    processed: {
      tradeRows: KrakenLedgerRow[];
      depositRows: KrakenLedgerRow[];
      validWithdrawals: KrakenLedgerRow[];
      transferRows: KrakenLedgerRow[];
      spendRows: KrakenLedgerRow[];
      receiveRows: KrakenLedgerRow[];
      processedRefIds: Set<string>;
      failedTransactionRefIds: Set<string>;
    }
  ): void {
    const { tradeRows, depositRows, validWithdrawals, transferRows, spendRows, receiveRows, processedRefIds, failedTransactionRefIds } = processed;

    // Count expected processed records
    let expectedProcessed = 0;

    // All single trades should be processed
    expectedProcessed += tradeRows.length;

    // All deposits should be processed
    expectedProcessed += depositRows.length;

    // All valid withdrawals should be processed (failed transactions are filtered out)
    expectedProcessed += validWithdrawals.length;

    // Failed transactions are intentionally skipped (each pair = 2 rows filtered)
    const failedTransactionRows = failedTransactionRefIds.size * 2;
    expectedProcessed += failedTransactionRows; // Count as "processed" since they were handled

    // All transfers should be processed (either as migrations or individual transfers)
    expectedProcessed += transferRows.length;

    // Spend/receive pairs that form trades or dustsweeping (all records with processed refids)
    const processedTradeRecords = spendRows.filter(row => processedRefIds.has(row.refid)).length +
      receiveRows.filter(row => processedRefIds.has(row.refid)).length;
    expectedProcessed += processedTradeRecords;

    // Unprocessed spend records (treated as withdrawals)
    const unprocessedSpendRecords = spendRows.filter(row => !processedRefIds.has(row.refid)).length;
    expectedProcessed += unprocessedSpendRecords;

    // Check for any unprocessed records
    const unprocessedRows = allRows.filter(row => {
      // Check if this row type is known
      const knownTypes = ['trade', 'deposit', 'withdrawal', 'transfer', 'spend', 'receive'];
      if (!knownTypes.includes(row.type)) {
        return true; // Unknown type = unprocessed
      }

      // Check if spend/receive rows that aren't part of processed trades
      if ((row.type === 'spend' || row.type === 'receive') && !processedRefIds.has(row.refid)) {
        // Unprocessed spend rows are handled as withdrawals, but unprocessed receive rows are problematic
        return row.type === 'receive';
      }

      return false; // This row should be processed
    });

    if (unprocessedRows.length > 0) {
      const unprocessedTypes = [...new Set(unprocessedRows.map(r => r.type))];
      this.logger.warn(`Found ${unprocessedRows.length} unprocessed CSV records with types: ${unprocessedTypes.join(', ')}`);

      // Log details of unprocessed records for debugging
      for (const row of unprocessedRows.slice(0, 5)) { // Show first 5
        this.logger.warn(`Unprocessed record: txid=${row.txid}, type=${row.type}, refid=${row.refid}, asset=${row.asset}, amount=${row.amount}`);
      }

      if (unprocessedRows.length > 5) {
        this.logger.warn(`... and ${unprocessedRows.length - 5} more unprocessed records`);
      }
    }

    this.logger.info(`CSV processing summary: ${allRows.length} total records, ${expectedProcessed} processed, ${unprocessedRows.length} unprocessed, ${failedTransactionRefIds.size} failed transaction pairs filtered`);
  }

  private convertSingleTradeToTransaction(trade: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(trade.time).getTime();
    const amount = parseDecimal(trade.amount).abs().toNumber();
    const fee = parseDecimal(trade.fee || '0').toNumber();

    return {
      id: trade.txid,
      type: 'trade',
      timestamp,
      datetime: trade.time,
      symbol: trade.asset, // Single trade records may not have clear symbol
      side: parseDecimal(trade.amount).isPositive() ? 'buy' : 'sell',
      amount: createMoney(amount, trade.asset),
      price: undefined, // Single trade records may not have clear price
      fee: createMoney(fee, trade.asset),
      status: this.mapStatus(),
      info: {
        originalRow: trade
      }
    };
  }

  private convertTradeToTransaction(spend: KrakenLedgerRow, receive: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(spend.time).getTime();
    const spendAmount = parseDecimal(spend.amount).abs().toNumber();
    let receiveAmount = parseDecimal(receive.amount).toNumber();

    // Check fees from both spend and receive transactions
    const spendFee = parseDecimal(spend.fee || '0').toNumber();
    const receiveFee = parseDecimal(receive.fee || '0').toNumber();

    // Determine which transaction has the fee and adjust accordingly
    let totalFee = 0;
    let feeAsset = spend.asset; // Default fee asset

    if (spendFee > 0) {
      totalFee = spendFee;
      feeAsset = spend.asset;
    } else if (receiveFee > 0) {
      // Fee is applied to received amount - subtract it (like C# code logic)
      totalFee = receiveFee;
      feeAsset = receive.asset;
      //receiveAmount -= receiveFee; // Adjust received amount for fee
    }

    return {
      id: spend.txid,
      type: 'trade',
      timestamp,
      datetime: spend.time,
      symbol: `${receive.asset}/${spend.asset}`,
      side: 'buy',
      amount: createMoney(receiveAmount, receive.asset),
      price: createMoney(spendAmount, spend.asset),
      fee: createMoney(totalFee, feeAsset),
      status: this.mapStatus(),
      info: {
        spend,
        receive,
        originalRows: { spend, receive },
        feeAdjustment: receiveFee > 0 ? 'receive_adjusted' : 'spend_fee'
      }
    };
  }

  private convertDepositToTransaction(row: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(row.time).getTime();
    const amount = parseDecimal(row.amount).toNumber();
    const fee = parseDecimal(row.fee || '0').toNumber();

    return {
      id: row.txid,
      type: 'deposit',
      timestamp,
      datetime: row.time,
      symbol: undefined,
      side: undefined,
      amount: createMoney(amount, row.asset), // Net amount after fee
      price: undefined,
      fee: createMoney(fee, row.asset),
      status: this.mapStatus(),
      info: {
        originalRow: row,
        txHash: undefined, // Kraken ledgers don't include tx hash
        wallet: row.wallet
      }
    };
  }

  private convertWithdrawalToTransaction(row: KrakenLedgerRow): CryptoTransaction {
    const timestamp = new Date(row.time).getTime();
    const amount = parseDecimal(row.amount).abs().toNumber();
    const fee = parseDecimal(row.fee || '0').toNumber();

    return {
      id: row.txid,
      type: 'withdrawal',
      timestamp,
      datetime: row.time,
      symbol: undefined,
      side: undefined,
      amount: createMoney(amount, row.asset), // Net amount after fee
      price: undefined,
      fee: createMoney(fee, row.asset),
      status: this.mapStatus(),
      info: {
        originalRow: row,
        txHash: undefined, // Kraken ledgers don't include tx hash
        wallet: row.wallet
      }
    };
  }
}===== ./src/exchanges/exchange-error-handler.ts =====
import { AuthenticationError, RateLimitError, ServiceError } from '@crypto/core';
import type { Logger } from '@crypto/shared-logger';
import ccxt from 'ccxt';

/**
 * Centralized error handling for exchange operations
 * Eliminates duplicate error handling code across adapters
 */
export class ServiceErrorHandler {
  /**
   * Handle errors and convert to appropriate exception types
   */
  static handle(error: any, operation: string, exchangeId: string, logger?: Logger): never {
    if (logger) {
      logger.error(`Exchange operation failed: ${operation} - Exchange: ${exchangeId}, Error: ${error instanceof Error ? error.message : 'Unknown error'}, Type: ${error instanceof Error ? error.constructor.name : 'Unknown'}`);
    }

    // Handle CCXT-specific errors
    if (this.isRateLimit(error)) {
      const retryAfter = this.extractRetryAfter(error);
      if (logger) {
        logger.warn(`Rate limit exceeded for ${exchangeId}, should retry after ${retryAfter}ms`);
      }

      throw new RateLimitError(
        `Rate limit exceeded: ${error.message}`,
        exchangeId,
        operation,
        retryAfter
      );
    }

    if (this.isAuthError(error)) {
      throw new AuthenticationError(
        `Authentication failed: ${error.message}`,
        exchangeId,
        operation
      );
    }

    if (this.isNetworkError(error)) {
      throw new ServiceError(
        `Network error: ${error.message}`,
        exchangeId,
        operation,
        error
      );
    }

    if (this.isNotSupported(error)) {
      // For unsupported operations, we'll log it but create a specific error
      if (logger) {
        logger.warn(`Operation not supported: ${operation} - Exchange: ${exchangeId}, Error: ${error.message}`);
      }
      throw new ServiceError(
        `Operation not supported: ${error.message}`,
        exchangeId,
        operation,
        error
      );
    }

    // Re-throw if it's already one of our custom errors
    if (error instanceof ServiceError ||
      error instanceof RateLimitError ||
      error instanceof AuthenticationError) {
      throw error;
    }

    // Generic exchange error fallback
    throw new ServiceError(
      `Operation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      exchangeId,
      operation,
      error instanceof Error ? error : undefined
    );
  }

  /**
   * Check if error is a rate limit error
   */
  static isRateLimit(error: any): boolean {
    return error instanceof ccxt.RateLimitExceeded ||
      error.name === 'RateLimitExceeded' ||
      (error.message && error.message.toLowerCase().includes('rate limit'));
  }

  /**
   * Check if error is an authentication error
   */
  static isAuthError(error: any): boolean {
    return error instanceof ccxt.AuthenticationError ||
      error.name === 'AuthenticationError' ||
      (error.message && (
        error.message.toLowerCase().includes('authentication') ||
        error.message.toLowerCase().includes('unauthorized') ||
        error.message.toLowerCase().includes('invalid api') ||
        error.message.toLowerCase().includes('api key')
      ));
  }

  /**
   * Check if error is a network error
   */
  static isNetworkError(error: any): boolean {
    return error instanceof ccxt.NetworkError ||
      error.name === 'NetworkError' ||
      (error.message && (
        error.message.toLowerCase().includes('network') ||
        error.message.toLowerCase().includes('timeout') ||
        error.message.toLowerCase().includes('connection')
      ));
  }

  /**
   * Check if error indicates operation is not supported
   */
  static isNotSupported(error: any): boolean {
    return error instanceof ccxt.NotSupported ||
      error.name === 'NotSupported' ||
      (error.message && (
        error.message.toLowerCase().includes('not supported') ||
        error.message.toLowerCase().includes('not implemented')
      ));
  }

  /**
   * Extract retry after value from rate limit error
   */
  static extractRetryAfter(error: any): number {
    // Try to get retry after from CCXT error
    if (error.retryAfter && typeof error.retryAfter === 'number') {
      return error.retryAfter;
    }

    // Try to extract from error message
    const retryMatch = error.message?.match(/retry.{0,10}(\d+)/i);
    if (retryMatch) {
      return parseInt(retryMatch[1]) * 1000; // Convert to milliseconds
    }

    // Default fallback
    return 2000; // 2 seconds
  }

  /**
   * Create a standardized error message
   */
  static formatErrorMessage(operation: string, exchangeId: string, originalMessage: string): string {
    return `Failed to ${operation} from ${exchangeId}: ${originalMessage}`;
  }

  /**
   * Log error details for debugging
   */
  static logErrorDetails(error: any, operation: string, exchangeId: string, logger: Logger): void {
    const details = {
      operation,
      exchange: exchangeId,
      errorType: error.constructor.name,
      message: error.message,
      stack: error.stack,
      // Include CCXT-specific details if available
      ...(error.code && { code: error.code }),
      ...(error.status && { status: error.status }),
      ...(error.retryAfter && { retryAfter: error.retryAfter })
    };

    logger.error('Detailed error information', details);
  }

  /**
   * Check if error is recoverable (should retry)
   */
  static isRecoverable(error: any): boolean {
    return this.isRateLimit(error) ||
      this.isNetworkError(error) ||
      (error.message && (
        error.message.toLowerCase().includes('temporary') ||
        error.message.toLowerCase().includes('try again')
      ));
  }
}===== ./src/exchanges/adapter-factory.ts =====
import type { IExchangeAdapter } from '@crypto/core';
import { ServiceError } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import ccxt from 'ccxt';
import { CCXTAdapter } from './ccxt-adapter.ts';
import { CoinbaseCCXTAdapter } from './coinbase/ccxt-adapter.ts';
import { KrakenCSVAdapter } from './kraken/csv-adapter.ts';
import { KuCoinCSVAdapter } from './kucoin/csv-adapter.ts';
import { LedgerLiveCSVAdapter } from './ledgerlive/csv-adapter.ts';

export class ExchangeAdapterFactory {
  private logger = getLogger('ExchangeAdapterFactory');

  /**
   * Create adapter with direct credentials (new simplified approach)
   */
  async createAdapterWithCredentials(
    exchangeId: string,
    adapterType: 'ccxt' | 'csv',
    options: {
      credentials?: {
        apiKey: string;
        secret: string;
        password?: string;
        sandbox?: boolean;
      };
      csvDirectories?: string[];
      enableOnlineVerification?: boolean;
    }
  ): Promise<IExchangeAdapter> {
    this.logger.info(`Creating adapter for ${exchangeId} with type: ${adapterType}`);

    if (adapterType === 'csv') {
      if (!options.csvDirectories || options.csvDirectories.length === 0) {
        throw new ServiceError('CSV directories required for CSV adapter', exchangeId, 'createAdapterWithCredentials');
      }

      switch (exchangeId.toLowerCase()) {
        case 'kraken':
          return new KrakenCSVAdapter({ csvDirectories: options.csvDirectories });
        case 'kucoin':
          return new KuCoinCSVAdapter({ csvDirectories: options.csvDirectories });
        case 'ledgerlive':
          return new LedgerLiveCSVAdapter({ csvDirectories: options.csvDirectories });
        default:
          throw new ServiceError(`Unsupported CSV exchange: ${exchangeId}`, exchangeId, 'createAdapterWithCredentials');
      }
    } else if (adapterType === 'ccxt') {
      if (!options.credentials) {
        throw new ServiceError('Credentials required for CCXT adapter', exchangeId, 'createAdapterWithCredentials');
      }

      switch (exchangeId.toLowerCase()) {
        case 'coinbase':
          if (!options.credentials.password) {
            throw new ServiceError('Password is required for Coinbase', exchangeId, 'createAdapterWithCredentials');
          }
          return new CoinbaseCCXTAdapter(options.credentials as { apiKey: string; secret: string; password: string; sandbox?: boolean }, { enableOnlineVerification: options.enableOnlineVerification });
        default:
          return this.createGenericCCXTAdapter(exchangeId, options.credentials, options.enableOnlineVerification);
      }
    }

    throw new ServiceError(`Unsupported adapter type: ${adapterType}`, exchangeId, 'createAdapterWithCredentials');
  }

  private createGenericCCXTAdapter(
    exchangeId: string,
    credentials: { apiKey: string; secret: string; password?: string; sandbox?: boolean },
    enableOnlineVerification?: boolean
  ): IExchangeAdapter {
    this.logger.info(`Creating generic CCXT adapter for ${exchangeId}`);

    if (!ccxt[exchangeId as keyof typeof ccxt]) {
      throw new ServiceError(`CCXT exchange ${exchangeId} not found`, exchangeId, 'createGenericCCXTAdapter');
    }

    // Create CCXT exchange instance
    const ExchangeClass = ccxt[exchangeId as keyof typeof ccxt] as any;
    const ccxtOptions: any = {
      apiKey: credentials.apiKey,
      secret: credentials.secret,
      enableRateLimit: true,
      rateLimit: 1000,
      sandbox: credentials.sandbox || false,
    };

    // Handle passphrase/password mapping for different exchanges
    if (exchangeId === 'kucoin') {
      // KuCoin uses 'password' field for passphrase in CCXT
      if (credentials.password) {
        ccxtOptions.password = credentials.password;
      }
    } else {
      // Most other exchanges use 'passphrase'
      if (credentials.password) {
        ccxtOptions.passphrase = credentials.password;
      }
    }

    const exchange = new ExchangeClass(ccxtOptions);
    
    return new CCXTAdapter(exchange, exchangeId, enableOnlineVerification);
  }
} ===== ./src/utils/circuit-breaker.ts =====
// Circuit breaker implementation for provider resilience
// Prevents hammering failed providers and enables automatic recovery

import type { Logger } from '@crypto/shared-logger';
import { getLogger } from '@crypto/shared-logger';

export class CircuitBreaker {
  private failureCount = 0;
  private lastFailureTimestamp = 0;
  private lastSuccessTimestamp = 0;
  private readonly maxFailures: number;
  private readonly recoveryTimeoutMs: number;
  private readonly providerName: string;
  private readonly logger: Logger;
  private previousState: 'closed' | 'open' | 'half-open' = 'closed';

  constructor(
    providerName: string,
    maxFailures: number = 3,
    recoveryTimeoutMs: number = 5 * 60 * 1000 // Default 5 minutes
  ) {
    this.providerName = providerName;
    this.maxFailures = maxFailures;
    this.recoveryTimeoutMs = recoveryTimeoutMs;
    this.logger = getLogger(`CircuitBreaker:${providerName}`);

    this.logger.debug(`Circuit breaker initialized for ${providerName}`);
  }

  /**
   * Determines if circuit breaker is open (blocking all requests)
   */
  isOpen(): boolean {
    if (this.failureCount >= this.maxFailures) {
      const timeSinceLastFailure = Date.now() - this.lastFailureTimestamp;
      return timeSinceLastFailure < this.recoveryTimeoutMs;
    }
    return false;
  }

  /**
   * Determines if circuit breaker is half-open (allowing test requests)
   */
  isHalfOpen(): boolean {
    if (this.failureCount >= this.maxFailures) {
      const timeSinceLastFailure = Date.now() - this.lastFailureTimestamp;
      return timeSinceLastFailure >= this.recoveryTimeoutMs;
    }
    return false;
  }

  /**
   * Determines if circuit breaker is closed (normal operation)
   */
  isClosed(): boolean {
    return this.failureCount < this.maxFailures;
  }

  /**
   * Records successful operation and resets failure state
   */
  recordSuccess(): void {
    const wasOpen = this.isOpen();
    this.failureCount = 0;
    this.lastFailureTimestamp = 0;
    this.lastSuccessTimestamp = Date.now();

    const currentState = this.getCurrentState();
    if (this.previousState !== currentState) {
      this.logger.info(`Circuit breaker state changed: ${this.previousState} → ${currentState} - Reason: success_recorded, Stats: ${JSON.stringify(this.getStatistics())}`);
      this.previousState = currentState;
    } else if (wasOpen) {
      this.logger.info(`Circuit breaker recovered after success - Stats: ${JSON.stringify(this.getStatistics())}`);
    }
  }

  /**
   * Records failed operation and updates failure state
   */
  recordFailure(): void {
    this.failureCount++;
    this.lastFailureTimestamp = Date.now();

    const currentState = this.getCurrentState();
    if (this.previousState !== currentState) {
      this.logger.warn(`Circuit breaker state changed: ${this.previousState} → ${currentState} - Reason: failure_recorded, FailureCount: ${this.failureCount}, MaxFailures: ${this.maxFailures}, Stats: ${JSON.stringify(this.getStatistics())}`);
      this.previousState = currentState;
    } else if (currentState === 'open') {
      this.logger.debug(`Circuit breaker failure recorded while open - FailureCount: ${this.failureCount}, MaxFailures: ${this.maxFailures}`);
    }
  }

  /**
   * Returns current circuit breaker state
   */
  getCurrentState(): 'closed' | 'open' | 'half-open' {
    if (this.failureCount < this.maxFailures) return 'closed';

    const timeSinceLastFailure = Date.now() - this.lastFailureTimestamp;
    if (timeSinceLastFailure >= this.recoveryTimeoutMs) return 'half-open';

    return 'open';
  }

  /**
   * Returns comprehensive circuit breaker statistics
   */
  getStatistics() {
    return {
      providerName: this.providerName,
      state: this.getCurrentState(),
      failureCount: this.failureCount,
      maxFailures: this.maxFailures,
      lastFailureTimestamp: this.lastFailureTimestamp,
      lastSuccessTimestamp: this.lastSuccessTimestamp,
      timeSinceLastFailureMs: this.lastFailureTimestamp ? Date.now() - this.lastFailureTimestamp : 0,
      timeUntilRecoveryMs: this.isOpen() ? this.recoveryTimeoutMs - (Date.now() - this.lastFailureTimestamp) : 0
    };
  }

  /**
   * Resets circuit breaker to closed state (clears all failure history)
   */
  reset(): void {
    this.failureCount = 0;
    this.lastFailureTimestamp = 0;
    this.lastSuccessTimestamp = 0;
    this.previousState = 'closed';
    this.logger.info(`Circuit breaker manually reset for ${this.providerName}`);
  }
}===== ./src/utils/scam-detection.ts =====
import type { TransactionNote } from '@crypto/core';
import { TransactionNoteType } from '../types.ts';


/**
 * Token metadata from DAS API for scam detection
 */
interface TokenMetadata {
  symbol: string;
  name: string;
  description?: string;
  image?: string;
  external_url?: string;
  attributes?: Array<{ trait_type: string; value: string }>;
}

/**
 * Analyzes token metadata to identify potential scam tokens
 * Returns a transaction note if suspicious patterns are detected
 */
export function detectScamToken(
  mintAddress: string,
  tokenMetadata: TokenMetadata,
  transactionContext?: {
    amount: number;
    isAirdrop: boolean;
  }
): TransactionNote | null {
  const suspiciousIndicators: string[] = [];
  let riskLevel: 'warning' | 'error' = 'warning';

  // Analyze token name for gift/reward emojis
  if (tokenMetadata.name && containsGiftEmojis(tokenMetadata.name)) {
    suspiciousIndicators.push('Gift/drop emojis in token name');
    riskLevel = 'error';
  }

  // Check for project impersonation attempts
  const impersonationResult = detectProjectImpersonation(tokenMetadata.symbol, tokenMetadata.name);
  if (impersonationResult.isImpersonation) {
    suspiciousIndicators.push(`Impersonating ${impersonationResult.targetProject}`);
    riskLevel = 'error';
  }

  // Validate external URLs for suspicious patterns
  if (tokenMetadata.external_url && isSuspiciousUrl(tokenMetadata.external_url)) {
    suspiciousIndicators.push('Suspicious external URL');
    riskLevel = 'error';
  }

  // Check for time-sensitive drop language
  if (tokenMetadata.name && hasTimeBasedDropPattern(tokenMetadata.name)) {
    suspiciousIndicators.push('Suspicious year/drop pattern in name');
    riskLevel = 'warning';
  }

  // Detect embedded URLs in token names
  if (tokenMetadata.name && containsUrlPattern(tokenMetadata.name)) {
    suspiciousIndicators.push('Contains suspicious URL/website pattern');
    riskLevel = 'error';
  }

  // Evaluate airdrop context
  if (transactionContext?.isAirdrop && transactionContext.amount > 0) {
    suspiciousIndicators.push('Unsolicited airdrop');
    riskLevel = 'warning';
  }

  // Generate warning note if suspicious patterns found
  if (suspiciousIndicators.length > 0) {
    const noteType = riskLevel === 'error' ? TransactionNoteType.SCAM_TOKEN : TransactionNoteType.SUSPICIOUS_AIRDROP;

    return {
      type: noteType,
      message: `⚠️ ${riskLevel === 'error' ? 'Scam token detected' : 'Suspicious token'}: ${suspiciousIndicators.join(', ')}`,
      severity: riskLevel,
      metadata: {
        mintAddress,
        tokenSymbol: tokenMetadata.symbol,
        tokenName: tokenMetadata.name,
        indicators: suspiciousIndicators,
        externalUrl: tokenMetadata.external_url
      }
    };
  }

  return null;
}

/**
 * Checks if token name contains gift/reward emojis commonly used in scam tokens
 */
function containsGiftEmojis(name: string): boolean {
  const giftEmojis = /[🎁🎉🎊💰💎⭐✨🔥🚀]/;
  return giftEmojis.test(name);
}

/**
 * Identifies potential impersonation of legitimate projects
 */
function detectProjectImpersonation(symbol: string, name: string): { isImpersonation: boolean; targetProject?: string } {
  const knownProjects = [
    { symbols: ['jup'], names: ['jupiter'], project: 'Jupiter Exchange' },
    { symbols: ['sol'], names: ['solana'], project: 'Solana' },
    { symbols: ['ray'], names: ['raydium'], project: 'Raydium' },
    { symbols: ['srm'], names: ['serum'], project: 'Serum' },
    { symbols: ['orca'], names: ['orca'], project: 'Orca' },
    { symbols: ['mngo'], names: ['mango'], project: 'Mango Markets' },
  ];

  const lowerSymbol = symbol.toLowerCase();
  const lowerName = name.toLowerCase();

  for (const project of knownProjects) {
    // Check if symbol matches but name suggests it's fake
    if (project.symbols.includes(lowerSymbol)) {
      // If name contains suspicious patterns, it's likely impersonation
      if (hasTimeBasedDropPattern(name) || containsGiftEmojis(name)) {
        return { isImpersonation: true, targetProject: project.project };
      }
    }

    // Check if name contains project name but has suspicious additions
    const hasProjectName = project.names.some(projName => lowerName.includes(projName));
    if (hasProjectName && (hasTimeBasedDropPattern(name) || containsGiftEmojis(name))) {
      return { isImpersonation: true, targetProject: project.project };
    }
  }

  return { isImpersonation: false };
}

/**
 * Detects time-sensitive language commonly used in scam tokens
 */
function hasTimeBasedDropPattern(name: string): boolean {
  const yearDropPatterns = /\b(202[3-9]|drop|airdrop|claim|bonus|reward|visit|free|prize|win)\b/i;
  return yearDropPatterns.test(name);
}

/**
 * Identifies URL or website patterns embedded in token names
 */
function containsUrlPattern(name: string): boolean {
  const urlPatterns = /\b(www\.|\.com|\.net|\.org|\.io|\.app|\.xyz|token-|claim-|visit |go to )/i;
  return urlPatterns.test(name);
}

/**
 * Detects explicit scam language patterns (conservative approach)
 */
function containsExplicitScamPhrases(name: string): boolean {
  const obviousScamPatterns = /\b(visit.*to.*claim|go.*to.*claim|click.*to.*claim|free.*airdrop.*claim|claim.*your.*reward)\b/i;
  return obviousScamPatterns.test(name);
}

/**
 * Check if external URL looks suspicious
 */
function isSuspiciousUrl(url: string): boolean {
  try {
    const parsedUrl = new URL(url);
    const hostname = parsedUrl.hostname.toLowerCase();

    // Check for suspicious domain patterns
    const suspiciousPatterns = [
      /jupiter.*claim/i,
      /solana.*drop/i,
      /crypto.*bonus/i,
      /.*-airdrop.*\.com/i,
      /.*claim.*\.site/i,
      /.*bonus.*\.xyz/i,
    ];

    return suspiciousPatterns.some(pattern => pattern.test(hostname));
  } catch {
    // Invalid URL is suspicious
    return true;
  }
}

/**
 * Check if a transaction appears to be an unsolicited airdrop
 */
export function isUnsolicitedAirdrop(
  transactionType: string,
  amount: number,
  tokenSymbol: string,
  userInitiated: boolean = false
): boolean {
  // If user didn't initiate the transaction and received tokens, it's likely an airdrop
  return (
    !userInitiated &&
    transactionType === 'deposit' &&
    amount > 0 &&
    !isKnownLegitimateToken(tokenSymbol)
  );
}

/**
 * Detect scam patterns directly from token symbol (for cases where we don't have full metadata)
 * CONSERVATIVE approach - only flag extremely obvious scams
 */
export function detectScamFromSymbol(tokenSymbol: string): { isScam: boolean; reason: string } {
  // Check for URL patterns in token symbol (very obvious scam pattern)
  if (containsUrlPattern(tokenSymbol)) {
    return { isScam: true, reason: 'Contains suspicious URL/website pattern' };
  }

  // Check for very obvious scam phrases (not individual words like "claim" but full suspicious phrases)
  if (containsExplicitScamPhrases(tokenSymbol)) {
    return { isScam: true, reason: 'Contains obvious scam phrases' };
  }

  // Check for gift emojis (legitimate tokens don't typically have these)
  if (containsGiftEmojis(tokenSymbol)) {
    return { isScam: true, reason: 'Contains gift/reward emojis' };
  }

  // Check known specific scam tokens
  const knownScamTokens = ['jup']; // Fake Jupiter from Solana - specific known scam
  if (knownScamTokens.includes(tokenSymbol.toLowerCase())) {
    return { isScam: true, reason: 'Known scam token' };
  }

  return { isScam: false, reason: '' };
}

/**
 * Check if a token symbol is from a known legitimate project
 */
function isKnownLegitimateToken(symbol: string): boolean {
  const legitimateTokens = [
    'SOL', 'USDC', 'USDT', 'BTC', 'ETH',
    'RAY', 'SRM', 'ORCA', 'MNGO', 'STEP',
    'RENDER', 'HNT', 'BONK', 'JTO', 'PYTH'
  ];

  return legitimateTokens.includes(symbol.toUpperCase());
}===== ./src/utils/transaction-transformer.ts =====
import type {
  CryptoTransaction,
  Money,
  TransactionStatus,
  TransactionType
} from '@crypto/core';
import { createMoney } from '@crypto/shared-utils';
import crypto from 'crypto';


/**
 * Transforms CCXT transactions to our standard CryptoTransaction format
 * Provides consistent data normalization across all exchange adapters
 */
export class TransactionTransformer {
  /**
   * Converts CCXT transaction data to standardized CryptoTransaction format
   */
  static fromCCXT(ccxtTransaction: any, type: TransactionType, exchangeId: string): CryptoTransaction {
    const { baseCurrency, quoteCurrency } = this.extractCurrencies(ccxtTransaction);
    const transactionId = this.extractTransactionId(ccxtTransaction, exchangeId);
    const timestamp = ccxtTransaction.timestamp || Date.now();
    const amount = Math.abs(ccxtTransaction.amount || 0);

    const amountMoney = createMoney(amount, baseCurrency);
    const priceMoney = this.extractPrice(ccxtTransaction, type, quoteCurrency);
    const fee = this.extractFee(ccxtTransaction);

    return {
      id: transactionId,
      type,
      timestamp,
      datetime: ccxtTransaction.datetime,
      symbol: ccxtTransaction.symbol,
      amount: amountMoney,
      side: ccxtTransaction.side,
      price: priceMoney,
      fee,
      status: this.normalizeStatus(ccxtTransaction.status),
      info: ccxtTransaction,
    };
  }

  /**
   * Extracts base and quote currencies from transaction data
   */
  static extractCurrencies(transaction: any): { baseCurrency: string; quoteCurrency: string } {
    let baseCurrency = 'unknown';
    let quoteCurrency = 'unknown';

    if (transaction.symbol && transaction.symbol.includes('/')) {
      [baseCurrency, quoteCurrency] = transaction.symbol.split('/');
    } else if (transaction.currency) {
      baseCurrency = transaction.currency;
      quoteCurrency = transaction.currency;
    } else if (transaction.info?.currency) {
      baseCurrency = transaction.info.currency;
      quoteCurrency = transaction.info.currency;
    }

    return { baseCurrency, quoteCurrency };
  }

  /**
   * Extracts transaction ID with fallback to generated hash
   */
  private static extractTransactionId(transaction: any, exchangeId: string): string {
    return transaction.id || transaction.txid || this.createTransactionHash(transaction, exchangeId);
  }

  /**
   * Extracts and normalizes price information
   */
  private static extractPrice(transaction: any, type: TransactionType, quoteCurrency: string): Money | undefined {
    if (transaction.price) {
      return createMoney(transaction.price, quoteCurrency);
    }
    
    if (type === 'trade' && transaction.cost && transaction.amount && transaction.amount !== 0) {
      const calculatedPrice = Math.abs(transaction.cost) / Math.abs(transaction.amount);
      return createMoney(calculatedPrice, quoteCurrency);
    }
    
    return undefined;
  }

  /**
   * Extracts fee information from transaction
   */
  private static extractFee(transaction: any): Money | undefined {
    if (transaction.fee?.cost) {
      return createMoney(transaction.fee.cost, transaction.fee.currency || 'unknown');
    }
    return undefined;
  }

  /**
   * Normalizes various exchange status formats to standard TransactionStatus
   */
  static normalizeStatus(status: any): TransactionStatus {
    if (!status) return 'pending';

    const statusMap: Record<string, TransactionStatus> = {
      'open': 'open',
      'closed': 'closed',
      'filled': 'closed',
      'completed': 'closed',
      'complete': 'closed',
      'canceled': 'canceled',
      'cancelled': 'canceled',
      'pending': 'pending',
      'rejected': 'failed',
      'expired': 'failed',
      'failed': 'failed',
      'ok': 'ok',
    };

    const normalizedStatus = statusMap[status.toLowerCase()];
    return normalizedStatus || 'pending';
  }

  /**
   * Generates unique transaction identifier from transaction data
   */
  static createTransactionHash(transaction: any, exchangeId: string): string {
    const hashData = JSON.stringify({
      id: transaction.id,
      timestamp: transaction.timestamp,
      symbol: transaction.symbol,
      amount: transaction.amount,
      side: transaction.side,
      type: transaction.type,
      exchange: exchangeId
    });

    return crypto.createHash('sha256').update(hashData).digest('hex').slice(0, 16);
  }

  /**
   * Determines if transaction should be excluded from import
   */
  static shouldFilterOut(transaction: any): boolean {
    // Check CCXT status
    if (transaction.status === 'canceled' || transaction.status === 'cancelled') {
      return true;
    }

    // Check exchange-specific status indicators
    const exchangeStatus = transaction.info?.status?.toLowerCase();
    if (exchangeStatus === 'canceled' || exchangeStatus === 'cancelled') {
      return true;
    }

    // Check for cancel_reason in exchange data
    if (transaction.info?.cancel_reason &&
      (transaction.info?.cancel_reason?.id || transaction.info?.cancel_reason?.message)) {
      return true;
    }

    return false;
  }
}===== ./src/types.ts =====
// Import results types - shared by exchange and blockchain adapters
export interface ImportResult {
  source: string; // Exchange or blockchain identifier
  transactions: number;
  newTransactions: number;
  duplicatesSkipped: number;
  errors: string[];
  duration: number;
}

export interface ImportSummary {
  totalTransactions: number;
  newTransactions: number;
  duplicatesSkipped: number;
  sourceResults: ImportResult[]; // Results from all sources (exchanges + blockchains)
  errors: string[];
  duration: number;
}

// Transaction Note Types - Enum for standardized transaction annotations
export enum TransactionNoteType {
  // Security & Scam Detection
  SCAM_TOKEN = 'SCAM_TOKEN',
  SUSPICIOUS_AIRDROP = 'SUSPICIOUS_AIRDROP',

  // Transaction Quality
  DUST_TRANSACTION = 'DUST_TRANSACTION',
  FAILED_TRANSACTION = 'FAILED_TRANSACTION',
  HIGH_FEE = 'HIGH_FEE',

  // Transfer Types
  INTERNAL_TRANSFER = 'INTERNAL_TRANSFER',
  STAKING_REWARD = 'STAKING_REWARD',
  UNSTAKING = 'UNSTAKING',

  // Exchange Operations
  PARTIAL_FILL = 'PARTIAL_FILL',
  MARGIN_LIQUIDATION = 'MARGIN_LIQUIDATION',

  // Airdrops & Rewards
  LEGITIMATE_AIRDROP = 'LEGITIMATE_AIRDROP',
  MINING_REWARD = 'MINING_REWARD',
  VALIDATOR_REWARD = 'VALIDATOR_REWARD',

  // Special Cases
  DUST_SWEEP = 'DUST_SWEEP',
  NETWORK_FEE_ONLY = 'NETWORK_FEE_ONLY',
  TEST_TRANSACTION = 'TEST_TRANSACTION'
}===== ./src/adapters/universal/base-adapter.ts =====
import type { Logger } from '@crypto/shared-logger';
import { getLogger } from '@crypto/shared-logger';
import type { IUniversalAdapter, AdapterInfo, FetchParams, Transaction, Balance } from './types.js';
import type { AdapterConfig } from './config.js';

export abstract class BaseAdapter implements IUniversalAdapter {
  protected logger: Logger;
  
  constructor(protected readonly config: AdapterConfig) {
    this.logger = getLogger(this.constructor.name);
  }
  
  abstract getInfo(): Promise<AdapterInfo>;
  abstract testConnection(): Promise<boolean>;
  
  // Template method pattern
  async fetchTransactions(params: FetchParams): Promise<Transaction[]> {
    await this.validateParams(params);
    const rawData = await this.fetchRawTransactions(params);
    const transactions = await this.transformTransactions(rawData, params);
    const filtered = this.applyFilters(transactions, params);
    return this.sortTransactions(filtered);
  }
  
  async fetchBalances(params: FetchParams): Promise<Balance[]> {
    await this.validateParams(params);
    const rawBalances = await this.fetchRawBalances(params);
    return this.transformBalances(rawBalances, params);
  }
  
  // Abstract hooks for subclasses
  protected abstract fetchRawTransactions(params: FetchParams): Promise<any>;
  protected abstract fetchRawBalances(params: FetchParams): Promise<any>;
  protected abstract transformTransactions(raw: any, params: FetchParams): Promise<Transaction[]>;
  protected abstract transformBalances(raw: any, params: FetchParams): Promise<Balance[]>;
  
  // Common utilities
  protected async validateParams(params: FetchParams): Promise<void> {
    // Common validation logic
    if (params.since && params.until && params.since > params.until) {
      throw new Error('since cannot be greater than until');
    }
    
    // Validate operation support
    const info = await this.getInfo();
    if (params.addresses && !info.capabilities.supportedOperations.includes('getAddressTransactions')) {
      throw new Error(`${info.name} does not support address-based transaction fetching`);
    }
  }
  
  protected applyFilters(transactions: Transaction[], params: FetchParams): Transaction[] {
    let filtered = transactions;
    
    if (params.symbols?.length) {
      filtered = filtered.filter(tx => 
        params.symbols!.includes(tx.amount.currency) ||
        (tx.symbol && params.symbols!.includes(tx.symbol))
      );
    }
    
    if (params.transactionTypes?.length) {
      filtered = filtered.filter(tx => 
        params.transactionTypes!.includes(tx.type)
      );
    }
    
    return filtered;
  }
  
  protected sortTransactions(transactions: Transaction[]): Transaction[] {
    return transactions.sort((a, b) => b.timestamp - a.timestamp);
  }
  
  async close(): Promise<void> {
    // Default cleanup
  }
}===== ./src/adapters/universal/exchange-bridge-adapter.ts =====
import type { IExchangeAdapter, CryptoTransaction, ExchangeBalance } from '@crypto/core';
import { BaseAdapter } from './base-adapter.js';
import type { AdapterInfo, FetchParams, Transaction, Balance } from './types.js';
import type { ExchangeAdapterConfig } from './config.js';

/**
 * Bridge adapter that wraps existing IExchangeAdapter implementations 
 * to provide the new IUniversalAdapter interface.
 * 
 * This enables a gradual migration by allowing the new unified interface
 * to work with existing exchange adapter implementations without modification.
 */
export class ExchangeBridgeAdapter extends BaseAdapter {
  constructor(
    private readonly oldAdapter: IExchangeAdapter,
    config: ExchangeAdapterConfig
  ) {
    super(config);
  }

  async getInfo(): Promise<AdapterInfo> {
    const exchangeInfo = await this.oldAdapter.getExchangeInfo();
    
    return {
      id: exchangeInfo.id,
      name: exchangeInfo.name,
      type: 'exchange',
      subType: this.config.subType,
      capabilities: {
        supportedOperations: [
          'fetchTransactions',
          'fetchBalances'
        ],
        maxBatchSize: 100,
        supportsHistoricalData: true,
        supportsPagination: true,
        requiresApiKey: this.config.subType === 'ccxt',
        rateLimit: exchangeInfo.rateLimit ? {
          requestsPerSecond: Math.floor(1000 / exchangeInfo.rateLimit),
          burstLimit: 50
        } : undefined
      }
    };
  }

  async testConnection(): Promise<boolean> {
    return this.oldAdapter.testConnection();
  }

  protected async fetchRawTransactions(params: FetchParams): Promise<CryptoTransaction[]> {
    // Use the old adapter's fetchAllTransactions method
    return this.oldAdapter.fetchAllTransactions(params.since);
  }
  
  protected async transformTransactions(rawTxs: CryptoTransaction[], params: FetchParams): Promise<Transaction[]> {
    // Transform CryptoTransaction to universal Transaction format
    return rawTxs.map(tx => ({
      id: tx.id,
      timestamp: tx.timestamp,
      datetime: tx.datetime || new Date(tx.timestamp).toISOString(),
      type: tx.type,
      status: this.mapTransactionStatus(tx.status),
      amount: tx.amount,
      fee: tx.fee,
      price: tx.price,
      from: tx.info?.from,
      to: tx.info?.to,
      symbol: tx.symbol,
      source: this.config.id,
      network: 'exchange',
      metadata: {
        side: tx.side,
        originalInfo: tx.info || {},
        exchangeSpecific: {
          status: tx.status,
          type: tx.type
        }
      }
    }));
  }

  protected async fetchRawBalances(params: FetchParams): Promise<ExchangeBalance[]> {
    return this.oldAdapter.fetchBalance();
  }

  protected async transformBalances(rawBalances: ExchangeBalance[], params: FetchParams): Promise<Balance[]> {
    return rawBalances.map(balance => ({
      currency: balance.currency,
      total: balance.total,
      free: balance.balance,
      used: balance.used,
      // No contract address for exchange balances
    }));
  }

  private mapTransactionStatus(status?: string): 'pending' | 'open' | 'closed' | 'canceled' | 'failed' | 'ok' {
    switch (status) {
      case 'pending':
        return 'pending';
      case 'open':
        return 'open';
      case 'closed':
        return 'closed';
      case 'ok':
        return 'ok';
      case 'failed':
        return 'failed';
      case 'canceled':
        return 'canceled';
      default:
        return 'ok'; // Default to ok for unknown statuses
    }
  }

  async close(): Promise<void> {
    return this.oldAdapter.close();
  }
}===== ./src/adapters/universal/blockchain-bridge-adapter.ts =====
import type { IBlockchainAdapter, BlockchainTransaction, BlockchainBalance } from '@crypto/core';
import { BaseAdapter } from './base-adapter.js';
import type { AdapterInfo, FetchParams, Transaction, Balance } from './types.js';
import type { BlockchainAdapterConfig } from './config.js';

/**
 * Bridge adapter that wraps existing IBlockchainAdapter implementations 
 * to provide the new IUniversalAdapter interface.
 * 
 * This enables a gradual migration by allowing the new unified interface
 * to work with existing blockchain adapter implementations without modification.
 */
export class BlockchainBridgeAdapter extends BaseAdapter {
  constructor(
    private readonly oldAdapter: IBlockchainAdapter,
    config: BlockchainAdapterConfig
  ) {
    super(config);
  }

  async getInfo(): Promise<AdapterInfo> {
    const blockchainInfo = await this.oldAdapter.getBlockchainInfo();
    
    return {
      id: blockchainInfo.id,
      name: blockchainInfo.name,
      type: 'blockchain',
      subType: this.config.subType,
      capabilities: {
        supportedOperations: [
          'fetchTransactions',
          'fetchBalances',
          'getAddressTransactions',
          'getAddressBalance',
          ...(blockchainInfo.capabilities.supportsTokenTransactions ? ['getTokenTransactions'] as const : []),
        ],
        maxBatchSize: 1,
        supportsHistoricalData: blockchainInfo.capabilities.supportsHistoricalData,
        supportsPagination: blockchainInfo.capabilities.supportsPagination,
        requiresApiKey: false,
        rateLimit: {
          requestsPerSecond: 5, // Conservative default for blockchain APIs
          burstLimit: 10
        }
      }
    };
  }

  async testConnection(): Promise<boolean> {
    return this.oldAdapter.testConnection();
  }

  protected async fetchRawTransactions(params: FetchParams): Promise<BlockchainTransaction[]> {
    if (!params.addresses?.length) {
      throw new Error('Addresses required for blockchain adapter');
    }
    
    const allTxs: BlockchainTransaction[] = [];
    
    // Fetch transactions for each address
    for (const address of params.addresses) {
      try {
        const txs = await this.oldAdapter.getAddressTransactions(address, params.since);
        allTxs.push(...txs);
      } catch (error) {
        this.logger.warn(`Failed to fetch transactions for address ${address}: ${error}`);
        // Continue with other addresses rather than failing completely
      }
    }
    
    // Fetch token transactions if supported and requested
    if (params.includeTokens && this.oldAdapter.getTokenTransactions) {
      for (const address of params.addresses) {
        try {
          const tokenTxs = await this.oldAdapter.getTokenTransactions(address);
          allTxs.push(...tokenTxs);
        } catch (error) {
          this.logger.warn(`Failed to fetch token transactions for address ${address}: ${error}`);
        }
      }
    }
    
    return allTxs;
  }
  
  protected async transformTransactions(rawTxs: BlockchainTransaction[], params: FetchParams): Promise<Transaction[]> {
    if (!params.addresses?.length) {
      throw new Error('Addresses required for blockchain transaction transformation');
    }
    
    const userAddresses = new Set(params.addresses.map(addr => addr.toLowerCase()));
    
    return rawTxs.map(tx => {
      // Convert blockchain transaction to universal format
      const cryptoTx = this.oldAdapter.convertToCryptoTransaction(tx, params.addresses![0]);
      
      return {
        id: tx.hash,
        timestamp: tx.timestamp * 1000, // Convert to milliseconds if needed
        datetime: new Date(tx.timestamp * 1000).toISOString(),
        type: cryptoTx.type,
        status: this.mapBlockchainStatus(tx.status),
        amount: tx.value,
        fee: tx.fee,
        price: cryptoTx.price,
        from: tx.from,
        to: tx.to,
        symbol: tx.tokenSymbol || cryptoTx.symbol,
        source: this.config.id,
        network: (this.config as BlockchainAdapterConfig).network || 'mainnet',
        metadata: {
          blockNumber: tx.blockNumber,
          blockHash: tx.blockHash,
          confirmations: tx.confirmations,
          gasUsed: tx.gasUsed,
          gasPrice: tx.gasPrice,
          nonce: tx.nonce,
          tokenContract: tx.tokenContract,
          blockchainType: tx.type,
          direction: this.determineDirection(tx, userAddresses),
          originalTransaction: tx
        }
      };
    });
  }

  protected async fetchRawBalances(params: FetchParams): Promise<BlockchainBalance[]> {
    if (!params.addresses?.length) {
      throw new Error('Addresses required for blockchain balance fetching');
    }
    
    const allBalances: BlockchainBalance[] = [];
    
    for (const address of params.addresses) {
      try {
        const balances = await this.oldAdapter.getAddressBalance(address);
        
        // Add address metadata to each balance
        const enrichedBalances = balances.map(balance => ({
          ...balance,
          address
        }));
        
        allBalances.push(...enrichedBalances);
        
        // Fetch token balances if supported and requested
        if (params.includeTokens && this.oldAdapter.getTokenBalances) {
          try {
            const tokenBalances = await this.oldAdapter.getTokenBalances(address);
            const enrichedTokenBalances = tokenBalances.map(balance => ({
              ...balance,
              address
            }));
            allBalances.push(...enrichedTokenBalances);
          } catch (error) {
            this.logger.warn(`Failed to fetch token balances for address ${address}: ${error}`);
          }
        }
      } catch (error) {
        this.logger.warn(`Failed to fetch balances for address ${address}: ${error}`);
      }
    }
    
    return allBalances;
  }

  protected async transformBalances(rawBalances: (BlockchainBalance & { address?: string })[], params: FetchParams): Promise<Balance[]> {
    return rawBalances.map(balance => ({
      currency: balance.currency,
      total: balance.total,
      free: balance.balance,
      used: balance.used,
      contractAddress: balance.contractAddress
    }));
  }

  private mapBlockchainStatus(status: 'success' | 'failed' | 'pending'): 'pending' | 'open' | 'closed' | 'canceled' | 'failed' | 'ok' {
    switch (status) {
      case 'success':
        return 'ok';
      case 'failed':
        return 'failed';
      case 'pending':
        return 'pending';
      default:
        return 'ok';
    }
  }

  private determineDirection(tx: BlockchainTransaction, userAddresses: Set<string>): 'in' | 'out' | 'self' {
    const fromLower = tx.from.toLowerCase();
    const toLower = tx.to.toLowerCase();
    
    const isFromUser = userAddresses.has(fromLower);
    const isToUser = userAddresses.has(toLower);
    
    if (isFromUser && isToUser) {
      return 'self';
    } else if (isFromUser) {
      return 'out';
    } else if (isToUser) {
      return 'in';
    } else {
      // This shouldn't happen for transactions fetched by address
      return 'out';
    }
  }

  async close(): Promise<void> {
    return this.oldAdapter.close();
  }
}===== ./src/adapters/universal/types.ts =====
import type { Money, TransactionStatus, TransactionType } from '@crypto/core';

export interface IUniversalAdapter {
  getInfo(): Promise<AdapterInfo>;
  testConnection(): Promise<boolean>;
  close(): Promise<void>;
  fetchTransactions(params: FetchParams): Promise<Transaction[]>;
  fetchBalances(params: FetchParams): Promise<Balance[]>;
}

export interface AdapterInfo {
  id: string;
  name: string;
  type: 'exchange' | 'blockchain';
  subType?: 'ccxt' | 'csv' | 'rpc' | 'rest';
  capabilities: AdapterCapabilities;
}

export interface AdapterCapabilities {
  supportedOperations: Array<
    | 'fetchTransactions' 
    | 'fetchBalances' 
    | 'getAddressTransactions'
    | 'getAddressBalance'
    | 'getTokenTransactions'
  >;
  maxBatchSize: number;
  supportsHistoricalData: boolean;
  supportsPagination: boolean;
  requiresApiKey: boolean;
  rateLimit?: {
    requestsPerSecond: number;
    burstLimit: number;
  };
}

export interface FetchParams {
  // Universal params
  addresses?: string[];        // For blockchains OR exchange accounts
  symbols?: string[];          // Filter by asset symbols
  since?: number;              // Time filter
  until?: number;              // Time filter
  
  // Optional type-specific params
  includeTokens?: boolean;     // For blockchains
  transactionTypes?: TransactionType[];
  
  // Pagination
  limit?: number;
  offset?: number;
}

export interface Transaction {
  // Universal fields
  id: string;
  timestamp: number;
  datetime: string;
  type: TransactionType;
  status: TransactionStatus;
  
  // Amounts
  amount: Money;
  fee?: Money;
  price?: Money;
  
  // Parties (works for both)
  from?: string;  // Sender address OR exchange account
  to?: string;    // Receiver address OR exchange account
  symbol?: string; // Add symbol for trades
  
  // Metadata
  source: string; // e.g., 'coinbase', 'bitcoin'
  network?: string; // e.g., 'mainnet'
  metadata: Record<string, any>;
}

export interface Balance {
  currency: string;
  total: number;
  free: number;
  used: number;
  contractAddress?: string;
}===== ./src/adapters/universal/index.ts =====
// Core interfaces and types
export type { 
  IUniversalAdapter,
  AdapterInfo,
  AdapterCapabilities,
  FetchParams,
  Transaction,
  Balance
} from './types.js';

// Configuration types
export type { 
  AdapterConfig,
  ExchangeAdapterConfig,
  BlockchainAdapterConfig
} from './config.js';

// Base adapter class
export { BaseAdapter } from './base-adapter.js';

// Bridge adapters for migration
export { ExchangeBridgeAdapter } from './exchange-bridge-adapter.js';
export { BlockchainBridgeAdapter } from './blockchain-bridge-adapter.js';

// Universal adapter factory
export { UniversalAdapterFactory } from './adapter-factory.js';===== ./src/adapters/universal/test-bridge-adapters.ts =====
import { Decimal } from 'decimal.js';
import type { IExchangeAdapter, IBlockchainAdapter, CryptoTransaction, BlockchainTransaction, ExchangeBalance, BlockchainBalance } from '@crypto/core';
import { ExchangeBridgeAdapter } from './exchange-bridge-adapter.js';
import { BlockchainBridgeAdapter } from './blockchain-bridge-adapter.js';
import type { ExchangeAdapterConfig, BlockchainAdapterConfig } from './config.js';

/**
 * Simple verification test for bridge adapters
 * This tests that the bridge adapters can wrap mock adapters and provide the universal interface
 */
async function testBridgeAdapters() {
  console.log('Testing Bridge Adapters...\n');

  // Test ExchangeBridgeAdapter
  console.log('1. Testing ExchangeBridgeAdapter');
  
  // Create a mock exchange adapter
  const mockExchangeAdapter: IExchangeAdapter = {
    testConnection: async () => true,
    getExchangeInfo: async () => ({
      id: 'test-exchange',
      name: 'Test Exchange',
      capabilities: {
        fetchMyTrades: true,
        fetchDeposits: true,
        fetchWithdrawals: true,
        fetchLedger: false,
        fetchClosedOrders: false,
        fetchBalance: true,
        fetchOrderBook: false,
        fetchTicker: false
      },
      rateLimit: 1000
    }),
    fetchAllTransactions: async () => [{
      id: 'test-tx-1',
      type: 'trade',
      timestamp: 1640995200000,
      amount: { amount: new Decimal('1.5'), currency: 'BTC' },
      symbol: 'BTC/USD',
      side: 'buy',
      price: { amount: new Decimal('50000'), currency: 'USD' },
      fee: { amount: new Decimal('75'), currency: 'USD' },
      status: 'ok'
    } as CryptoTransaction],
    fetchTrades: async () => [],
    fetchDeposits: async () => [],
    fetchWithdrawals: async () => [],
    fetchClosedOrders: async () => [],
    fetchLedger: async () => [],
    fetchBalance: async () => [{
      currency: 'BTC',
      balance: 1.5,
      used: 0,
      total: 1.5
    } as ExchangeBalance],
    close: async () => undefined
  };

  const exchangeConfig: ExchangeAdapterConfig = {
    type: 'exchange',
    id: 'test-exchange',
    subType: 'ccxt'
  };

  const exchangeBridge = new ExchangeBridgeAdapter(mockExchangeAdapter, exchangeConfig);

  // Test adapter info
  const exchangeInfo = await exchangeBridge.getInfo();
  console.log('   ✓ Exchange adapter info:', {
    type: exchangeInfo.type,
    id: exchangeInfo.id,
    subType: exchangeInfo.subType,
    operationsCount: exchangeInfo.capabilities.supportedOperations.length
  });

  // Test connection
  const exchangeConnected = await exchangeBridge.testConnection();
  console.log('   ✓ Exchange connection test:', exchangeConnected);

  // Test transaction fetching
  const exchangeTransactions = await exchangeBridge.fetchTransactions({
    since: 1640995200000
  });
  console.log('   ✓ Exchange transactions fetched:', {
    count: exchangeTransactions.length,
    firstTx: exchangeTransactions[0] ? {
      id: exchangeTransactions[0].id,
      type: exchangeTransactions[0].type,
      source: exchangeTransactions[0].source,
      network: exchangeTransactions[0].network
    } : null
  });

  // Test balance fetching
  const exchangeBalances = await exchangeBridge.fetchBalances({});
  console.log('   ✓ Exchange balances fetched:', {
    count: exchangeBalances.length,
    firstBalance: exchangeBalances[0] ? {
      currency: exchangeBalances[0].currency,
      total: exchangeBalances[0].total
    } : null
  });

  // Test cleanup
  await exchangeBridge.close();
  console.log('   ✓ Exchange adapter closed successfully\n');

  // Test BlockchainBridgeAdapter
  console.log('2. Testing BlockchainBridgeAdapter');

  // Create a mock blockchain adapter
  const mockBlockchainAdapter: IBlockchainAdapter = {
    testConnection: async () => true,
    getBlockchainInfo: async () => ({
      id: 'bitcoin',
      name: 'Bitcoin',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: false,
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: false
      }
    }),
    getAddressTransactions: async () => [{
      hash: '0x123456789abcdef',
      blockNumber: 12345,
      blockHash: '0xblock123',
      timestamp: 1640995200,
      from: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
      to: '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2',
      value: { amount: new Decimal('0.5'), currency: 'BTC' },
      fee: { amount: new Decimal('0.001'), currency: 'BTC' },
      gasUsed: 21000,
      gasPrice: 20,
      status: 'success',
      type: 'transfer',
      nonce: 1,
      confirmations: 6
    } as BlockchainTransaction],
    getAddressBalance: async () => [{
      currency: 'BTC',
      balance: 0.5,
      used: 0,
      total: 0.5
    } as BlockchainBalance],
    validateAddress: () => true,
    convertToCryptoTransaction: (tx, userAddress) => ({
      id: tx.hash,
      type: 'withdrawal',
      timestamp: tx.timestamp * 1000,
      amount: tx.value,
      fee: tx.fee,
      info: tx
    } as CryptoTransaction),
    close: async () => undefined
  };

  const blockchainConfig: BlockchainAdapterConfig = {
    type: 'blockchain',
    id: 'bitcoin',
    subType: 'rest',
    network: 'mainnet'
  };

  const blockchainBridge = new BlockchainBridgeAdapter(mockBlockchainAdapter, blockchainConfig);

  // Test adapter info
  const blockchainInfo = await blockchainBridge.getInfo();
  console.log('   ✓ Blockchain adapter info:', {
    type: blockchainInfo.type,
    id: blockchainInfo.id,
    subType: blockchainInfo.subType,
    operationsCount: blockchainInfo.capabilities.supportedOperations.length
  });

  // Test connection
  const blockchainConnected = await blockchainBridge.testConnection();
  console.log('   ✓ Blockchain connection test:', blockchainConnected);

  // Test transaction fetching
  const blockchainTransactions = await blockchainBridge.fetchTransactions({
    addresses: ['1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'],
    since: 1640995200000
  });
  console.log('   ✓ Blockchain transactions fetched:', {
    count: blockchainTransactions.length,
    firstTx: blockchainTransactions[0] ? {
      id: blockchainTransactions[0].id,
      source: blockchainTransactions[0].source,
      network: blockchainTransactions[0].network,
      blockNumber: blockchainTransactions[0].metadata.blockNumber
    } : null
  });

  // Test balance fetching
  const blockchainBalances = await blockchainBridge.fetchBalances({
    addresses: ['1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa']
  });
  console.log('   ✓ Blockchain balances fetched:', {
    count: blockchainBalances.length,
    firstBalance: blockchainBalances[0] ? {
      currency: blockchainBalances[0].currency,
      total: blockchainBalances[0].total
    } : null
  });

  // Test error handling for missing addresses
  try {
    await blockchainBridge.fetchTransactions({});
    console.log('   ✗ Should have thrown error for missing addresses');
  } catch (error) {
    console.log('   ✓ Correctly throws error for missing addresses:', (error as Error).message);
  }

  // Test cleanup
  await blockchainBridge.close();
  console.log('   ✓ Blockchain adapter closed successfully\n');

  console.log('All bridge adapter tests passed! ✅');
}

// Run the test if this file is executed directly
if (import.meta.url.endsWith(process.argv[1])) {
  testBridgeAdapters().catch(console.error);
}

export { testBridgeAdapters };===== ./src/adapters/universal/config.ts =====
interface BaseAdapterConfig {
  type: 'exchange' | 'blockchain';
  id: string;
}

export interface ExchangeAdapterConfig extends BaseAdapterConfig {
  type: 'exchange';
  subType: 'ccxt' | 'csv';
  credentials?: { 
    apiKey: string; 
    secret: string; 
    password?: string; 
  };
  csvDirectories?: string[];
}

export interface BlockchainAdapterConfig extends BaseAdapterConfig {
  type: 'blockchain';
  subType: 'rest' | 'rpc';
  network: string;
}

export type AdapterConfig = ExchangeAdapterConfig | BlockchainAdapterConfig;===== ./src/adapters/universal/adapter-factory.ts =====
import { ExchangeAdapterFactory } from '../../exchanges/adapter-factory.js';
import { BlockchainAdapterFactory } from '../../blockchains/shared/blockchain-adapter-factory.js';
import { ExchangeBridgeAdapter } from './exchange-bridge-adapter.js';
import { BlockchainBridgeAdapter } from './blockchain-bridge-adapter.js';
import type { IUniversalAdapter } from './types.js';
import type { AdapterConfig, ExchangeAdapterConfig, BlockchainAdapterConfig } from './config.js';
import type { BlockchainExplorersConfig } from '../../blockchains/shared/explorer-config.js';
import { getLogger } from '@crypto/shared-logger';

/**
 * Universal adapter factory that creates adapters implementing the IUniversalAdapter interface.
 * 
 * During the migration phase, this factory uses bridge adapters to wrap existing 
 * IExchangeAdapter and IBlockchainAdapter implementations. This allows the new
 * unified interface to work with existing adapter implementations without modification.
 */
export class UniversalAdapterFactory {
  private static readonly logger = getLogger('UniversalAdapterFactory');

  /**
   * Create a single universal adapter based on configuration
   */
  static async create(config: AdapterConfig, explorerConfig?: BlockchainExplorersConfig): Promise<IUniversalAdapter> {
    this.logger.info(`Creating universal adapter for ${config.id} (type: ${config.type})`);

    if (config.type === 'exchange') {
      return this.createExchangeAdapter(config as ExchangeAdapterConfig);
    }
    
    if (config.type === 'blockchain') {
      return this.createBlockchainAdapter(config as BlockchainAdapterConfig, explorerConfig);
    }
    
    throw new Error(`Unsupported adapter type: ${(config as any).type}`);
  }

  /**
   * Create multiple universal adapters from an array of configurations
   */
  static async createMany(
    configs: AdapterConfig[], 
    explorerConfig?: BlockchainExplorersConfig
  ): Promise<IUniversalAdapter[]> {
    this.logger.info(`Creating ${configs.length} universal adapters`);
    
    return Promise.all(
      configs.map(config => this.create(config, explorerConfig))
    );
  }

  /**
   * Create an exchange adapter wrapped in a bridge adapter
   */
  private static async createExchangeAdapter(config: ExchangeAdapterConfig): Promise<IUniversalAdapter> {
    this.logger.debug(`Creating exchange adapter for ${config.id} with subType: ${config.subType}`);
    
    // Create the old exchange adapter using the existing factory
    const oldFactory = new ExchangeAdapterFactory();
    const oldAdapter = await oldFactory.createAdapterWithCredentials(
      config.id,
      config.subType,
      {
        credentials: config.credentials,
        csvDirectories: config.csvDirectories,
        enableOnlineVerification: false // Default to false for now
      }
    );
    
    // Wrap it in a bridge adapter to provide the universal interface
    return new ExchangeBridgeAdapter(oldAdapter, config);
  }

  /**
   * Create a blockchain adapter wrapped in a bridge adapter
   */
  private static async createBlockchainAdapter(
    config: BlockchainAdapterConfig, 
    explorerConfig?: BlockchainExplorersConfig
  ): Promise<IUniversalAdapter> {
    if (!explorerConfig) {
      throw new Error('Explorer configuration required for blockchain adapters');
    }

    this.logger.debug(`Creating blockchain adapter for ${config.id} with network: ${config.network}`);
    
    // Create the old blockchain adapter using the existing factory
    const oldFactory = new BlockchainAdapterFactory();
    const oldAdapter = await oldFactory.createBlockchainAdapter(config.id, explorerConfig);
    
    // Wrap it in a bridge adapter to provide the universal interface
    return new BlockchainBridgeAdapter(oldAdapter, config);
  }

  /**
   * Helper method to create exchange adapter configuration
   */
  static createExchangeConfig(
    exchangeId: string,
    subType: 'ccxt' | 'csv',
    options: {
      credentials?: {
        apiKey: string;
        secret: string;
        password?: string;
      };
      csvDirectories?: string[];
    }
  ): ExchangeAdapterConfig {
    return {
      type: 'exchange',
      id: exchangeId,
      subType,
      credentials: options.credentials,
      csvDirectories: options.csvDirectories
    };
  }

  /**
   * Helper method to create blockchain adapter configuration
   */
  static createBlockchainConfig(
    blockchain: string,
    network: string = 'mainnet',
    subType: 'rest' | 'rpc' = 'rest'
  ): BlockchainAdapterConfig {
    return {
      type: 'blockchain',
      id: blockchain,
      subType,
      network
    };
  }
}===== ./src/adapters/universal/verify-transformations.ts =====
import { Decimal } from 'decimal.js';
import type { CryptoTransaction, BlockchainTransaction } from '@crypto/core';
import type { Transaction } from './types.js';

/**
 * Verification utility to check that data transformations are working correctly
 * This compares the input data format with the output universal format
 */

export function verifyExchangeTransformation() {
  console.log('=== Exchange Transaction Transformation Verification ===\n');

  // Sample input data (CryptoTransaction from old exchange adapter)
  const inputTransaction: CryptoTransaction = {
    id: 'exchange-tx-123',
    type: 'trade',
    timestamp: 1640995200000,
    datetime: '2022-01-01T00:00:00.000Z',
    symbol: 'BTC/USD',
    amount: { amount: new Decimal('1.5'), currency: 'BTC' },
    side: 'buy',
    price: { amount: new Decimal('50000'), currency: 'USD' },
    fee: { amount: new Decimal('75'), currency: 'USD' },
    status: 'ok',
    info: {
      orderId: '12345',
      from: 'user-account',
      to: 'exchange-pool'
    }
  };

  // Expected output format (universal Transaction)
  const expectedOutput: Transaction = {
    id: 'exchange-tx-123',
    timestamp: 1640995200000,
    datetime: '2022-01-01T00:00:00.000Z',
    type: 'trade',
    status: 'ok',
    amount: { amount: new Decimal('1.5'), currency: 'BTC' },
    fee: { amount: new Decimal('75'), currency: 'USD' },
    price: { amount: new Decimal('50000'), currency: 'USD' },
    from: 'user-account',
    to: 'exchange-pool',
    symbol: 'BTC/USD',
    source: 'test-exchange',
    network: 'exchange',
    metadata: {
      side: 'buy',
      originalInfo: {
        orderId: '12345',
        from: 'user-account',
        to: 'exchange-pool'
      },
      exchangeSpecific: {
        status: 'ok',
        type: 'trade'
      }
    }
  };

  console.log('Input (CryptoTransaction):');
  console.log(JSON.stringify(inputTransaction, null, 2));
  console.log('\nExpected Output (Universal Transaction):');
  console.log(JSON.stringify(expectedOutput, null, 2));

  // Verify key transformations
  const transformations = [
    { field: 'id', inputValue: inputTransaction.id, expectedValue: expectedOutput.id },
    { field: 'type', inputValue: inputTransaction.type, expectedValue: expectedOutput.type },
    { field: 'timestamp', inputValue: inputTransaction.timestamp, expectedValue: expectedOutput.timestamp },
    { field: 'amount', inputValue: inputTransaction.amount, expectedValue: expectedOutput.amount },
    { field: 'status mapping', inputValue: inputTransaction.status, expectedValue: expectedOutput.status },
    { field: 'source addition', inputValue: '(none)', expectedValue: expectedOutput.source },
    { field: 'network addition', inputValue: '(none)', expectedValue: expectedOutput.network },
    { field: 'metadata enrichment', inputValue: '(basic info)', expectedValue: '(enriched with side, originalInfo, etc.)' }
  ];

  console.log('\n✓ Key Data Transformations:');
  transformations.forEach(({ field, inputValue, expectedValue }) => {
    console.log(`  ${field}: ${JSON.stringify(inputValue)} → ${JSON.stringify(expectedValue)}`);
  });

  console.log('\n✅ Exchange transformation preserves all critical data while adding universal fields\n');
}

export function verifyBlockchainTransformation() {
  console.log('=== Blockchain Transaction Transformation Verification ===\n');

  // Sample input data (BlockchainTransaction from old blockchain adapter)
  const inputTransaction: BlockchainTransaction = {
    hash: '0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01',
    blockNumber: 12345678,
    blockHash: '0xblock123456789abcdef0123456789abcdef0123456789abcdef0123456789abc',
    timestamp: 1640995200,
    from: '0xfrom123456789abcdef0123456789abcdef01234567',
    to: '0xto123456789abcdef0123456789abcdef01234567',
    value: { amount: new Decimal('1.5'), currency: 'ETH' },
    fee: { amount: new Decimal('0.001'), currency: 'ETH' },
    gasUsed: 21000,
    gasPrice: 20,
    status: 'success',
    type: 'transfer',
    nonce: 42,
    confirmations: 6
  };

  // Expected output format (universal Transaction)
  const expectedOutput: Transaction = {
    id: '0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01',
    timestamp: 1640995200000, // Converted to milliseconds
    datetime: '2022-01-01T00:00:00.000Z',
    type: 'withdrawal', // Determined by convertToCryptoTransaction
    status: 'ok', // Mapped from 'success'
    amount: { amount: new Decimal('1.5'), currency: 'ETH' },
    fee: { amount: new Decimal('0.001'), currency: 'ETH' },
    from: '0xfrom123456789abcdef0123456789abcdef01234567',
    to: '0xto123456789abcdef0123456789abcdef01234567',
    source: 'ethereum',
    network: 'mainnet',
    metadata: {
      blockNumber: 12345678,
      blockHash: '0xblock123456789abcdef0123456789abcdef0123456789abcdef0123456789abc',
      confirmations: 6,
      gasUsed: 21000,
      gasPrice: 20,
      nonce: 42,
      blockchainType: 'transfer',
      direction: 'out', // Determined based on user address
      originalTransaction: inputTransaction
    }
  };

  console.log('Input (BlockchainTransaction):');
  console.log(JSON.stringify(inputTransaction, null, 2));
  console.log('\nExpected Output (Universal Transaction):');
  console.log(JSON.stringify(expectedOutput, null, 2));

  // Verify key transformations
  const transformations = [
    { field: 'id (hash)', inputValue: inputTransaction.hash, expectedValue: expectedOutput.id },
    { field: 'timestamp conversion', inputValue: `${inputTransaction.timestamp} (seconds)`, expectedValue: `${expectedOutput.timestamp} (milliseconds)` },
    { field: 'status mapping', inputValue: inputTransaction.status, expectedValue: expectedOutput.status },
    { field: 'blockchain type preservation', inputValue: inputTransaction.type, expectedValue: expectedOutput.metadata.blockchainType },
    { field: 'source addition', inputValue: '(none)', expectedValue: expectedOutput.source },
    { field: 'network addition', inputValue: '(none)', expectedValue: expectedOutput.network },
    { field: 'metadata enrichment', inputValue: '(gas details)', expectedValue: '(block info, gas, direction, etc.)' }
  ];

  console.log('\n✓ Key Data Transformations:');
  transformations.forEach(({ field, inputValue, expectedValue }) => {
    console.log(`  ${field}: ${JSON.stringify(inputValue)} → ${JSON.stringify(expectedValue)}`);
  });

  console.log('\n✅ Blockchain transformation preserves all blockchain data while adding universal fields\n');
}

export function verifyBalanceTransformation() {
  console.log('=== Balance Transformation Verification ===\n');

  // Exchange balance transformation
  const exchangeBalanceInput = {
    currency: 'BTC',
    balance: 1.5,    // Available/free amount
    used: 0.1,       // Used/frozen amount  
    total: 1.6       // Total balance
  };

  const exchangeBalanceOutput = {
    currency: 'BTC',
    total: 1.6,
    free: 1.5,       // Mapped from balance
    used: 0.1,
    // No contractAddress for exchange balances
  };

  console.log('Exchange Balance Transformation:');
  console.log('Input:', JSON.stringify(exchangeBalanceInput, null, 2));
  console.log('Output:', JSON.stringify(exchangeBalanceOutput, null, 2));

  // Blockchain balance transformation
  const blockchainBalanceInput = {
    currency: 'ETH',
    balance: 2.5,
    used: 0,
    total: 2.5,
    contractAddress: '0x1234567890abcdef1234567890abcdef12345678'
  };

  const blockchainBalanceOutput = {
    currency: 'ETH',
    total: 2.5,
    free: 2.5,       // Mapped from balance
    used: 0,
    contractAddress: '0x1234567890abcdef1234567890abcdef12345678'
  };

  console.log('\nBlockchain Balance Transformation:');
  console.log('Input:', JSON.stringify(blockchainBalanceInput, null, 2));
  console.log('Output:', JSON.stringify(blockchainBalanceOutput, null, 2));

  console.log('\n✅ Balance transformations maintain data consistency across both adapter types\n');
}

// Run all verifications if this file is executed directly
if (import.meta.url.endsWith(process.argv[1])) {
  console.log('🔍 Verifying Bridge Adapter Data Transformations\n');
  verifyExchangeTransformation();
  verifyBlockchainTransformation();
  verifyBalanceTransformation();
  console.log('🎉 All data transformation verifications completed successfully!');
}===== ./src/scripts/validate-config.ts =====
#!/usr/bin/env tsx

/**
 * Validate blockchain explorer configuration against registered providers
 */

import { loadExplorerConfig } from '../blockchains/shared/explorer-config.ts';
import { ProviderRegistry } from '../blockchains/shared/registry/index.ts';

// Import all providers to trigger registration
import '../blockchains/registry/register-providers.ts';

function validateConfiguration(): void {
  console.log('🔍 Validating Blockchain Configuration\n');

  try {
    // Load the configuration
    const config = loadExplorerConfig();

    // Validate against registry
    const validation = ProviderRegistry.validateConfig(config);

    if (validation.valid) {
      console.log('✅ Configuration is valid!\n');

      // Show configuration summary
      console.log('📋 Configuration Summary');
      console.log('─'.repeat(40));

      for (const [blockchain, blockchainConfig] of Object.entries(config)) {
        if (!blockchainConfig || typeof blockchainConfig !== 'object') continue;

        const { explorers = [] } = blockchainConfig as any;
        const enabled = explorers.filter((e: any) => e.enabled);

        console.log(`${blockchain.toUpperCase()}:`);
        console.log(`  Total providers: ${explorers.length}`);
        console.log(`  Enabled: ${enabled.length}`);
        console.log(`  Disabled: ${explorers.length - enabled.length}`);

        if (enabled.length > 0) {
          console.log('  Enabled providers:');
          enabled
            .sort((a: any, b: any) => a.priority - b.priority)
            .forEach((provider: any) => {
              const metadata = ProviderRegistry.getMetadata(blockchain, provider.name);
              const apiKeyInfo = metadata?.requiresApiKey ?
                (metadata.apiKeyEnvVar ? ` (${metadata.apiKeyEnvVar})` : ' (API key required)') : '';
              console.log(`    ${provider.priority}. ${provider.name}${apiKeyInfo}`);
            });
        }

        console.log('');
      }

    } else {
      console.log('❌ Configuration validation failed!\n');

      console.log('🚨 Errors found:');
      validation.errors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error}`);
      });

      console.log('\n💡 Suggestions:');
      console.log('  • Run `pnpm run providers:list` to see available providers');
      console.log('  • Check for typos in provider names');
      console.log('  • Ensure all referenced providers are registered');
      console.log('  • Verify required API keys are properly configured');

      process.exit(1);
    }

  } catch (error) {
    console.error('❌ Failed to load or validate configuration:');
    console.error(error instanceof Error ? error.message : error);
    console.log('\n💡 Suggestions:');
    console.log('  • Ensure config/blockchain-explorers.json exists');
    console.log('  • Check JSON syntax is valid');
    console.log('  • Run `pnpm run config:generate` to create a template');
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  validateConfiguration();
}

export { validateConfiguration };
===== ./src/scripts/generate-config.ts =====
#!/usr/bin/env tsx

/**
 * Generate blockchain explorer configuration template from registered providers
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { ProviderRegistry } from '../blockchains/shared/registry/index.ts';

// Import all providers to trigger registration
import '../blockchains/registry/register-providers.ts';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

function generateConfiguration(): void {
  console.log('🔧 Generating Blockchain Configuration Template\n');

  const allProviders = ProviderRegistry.getAllProviders();

  if (allProviders.length === 0) {
    console.log('❌ No providers found. Ensure provider files are imported.');
    process.exit(1);
  }

  // Group providers by blockchain
  const providersByBlockchain = new Map<string, typeof allProviders>();

  for (const provider of allProviders) {
    if (!providersByBlockchain.has(provider.blockchain)) {
      providersByBlockchain.set(provider.blockchain, []);
    }
    providersByBlockchain.get(provider.blockchain)!.push(provider);
  }

  // Generate configuration object
  const config: any = {};

  for (const [blockchain, providers] of providersByBlockchain.entries()) {
    config[blockchain] = {
      explorers: providers.map((provider, index) => {
        const metadata = ProviderRegistry.getMetadata(blockchain, provider.name);

        const explorerConfig: any = {
          name: provider.name,
          displayName: provider.displayName,
          enabled: index === 0, // Enable first provider by default
          priority: index + 1,
          type: provider.type,
          ...(metadata?.requiresApiKey && {
            requiresApiKey: true,
            ...(metadata.apiKeyEnvVar && {
              apiKeyEnvVar: metadata.apiKeyEnvVar
            })
          }),
          ...(metadata?.description && {
            description: metadata.description
          }),
          capabilities: {
            supportedOperations: provider.capabilities.supportedOperations,
            maxBatchSize: provider.capabilities.maxBatchSize,
            supportsHistoricalData: provider.capabilities.supportsHistoricalData,
            supportsRealTimeData: provider.capabilities.supportsRealTimeData,
            supportsTokenData: provider.capabilities.supportsTokenData,
            supportsPagination: provider.capabilities.supportsPagination,
            ...(provider.capabilities.maxLookbackDays && {
              maxLookbackDays: provider.capabilities.maxLookbackDays
            })
          },
          networks: {
            ...metadata?.networks.mainnet && {
              mainnet: {
                baseUrl: metadata.networks.mainnet.baseUrl
              }
            },
            ...metadata?.networks.testnet && {
              testnet: {
                baseUrl: metadata.networks.testnet.baseUrl
              }
            },
            ...metadata?.networks.devnet && {
              devnet: {
                baseUrl: metadata.networks.devnet.baseUrl
              }
            }
          },
          defaultConfig: {
            timeout: metadata?.defaultConfig.timeout,
            retries: metadata?.defaultConfig.retries,
            rateLimit: {
              requestsPerSecond: metadata?.defaultConfig.rateLimit.requestsPerSecond,
              ...(metadata?.defaultConfig.rateLimit.requestsPerMinute && {
                requestsPerMinute: metadata.defaultConfig.rateLimit.requestsPerMinute
              }),
              ...(metadata?.defaultConfig.rateLimit.requestsPerHour && {
                requestsPerHour: metadata.defaultConfig.rateLimit.requestsPerHour
              }),
              ...(metadata?.defaultConfig.rateLimit.burstLimit && {
                burstLimit: metadata.defaultConfig.rateLimit.burstLimit
              })
            }
          }
        };

        return explorerConfig;
      })
    };
  }

  // Write configuration file
  const configPath = path.join(__dirname, '../../config/blockchain-explorers-template.json');
  const configJson = JSON.stringify(config, null, 2);

  try {
    // Ensure config directory exists
    const configDir = path.dirname(configPath);
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    fs.writeFileSync(configPath, configJson);

    console.log('✅ Configuration template generated successfully!');
    console.log(`📄 File: ${configPath}`);
    console.log(`📊 Generated ${Object.keys(config).length} blockchains with ${allProviders.length} total providers\n`);

    // Show summary
    console.log('📋 Generated Configuration:');
    console.log('─'.repeat(50));

    for (const [blockchain, blockchainConfig] of Object.entries(config)) {
      const { explorers } = blockchainConfig as any;
      const enabled = explorers.filter((e: any) => e.enabled);

      console.log(`${blockchain.toUpperCase()}:`);
      console.log(`  Providers: ${explorers.length} (${enabled.length} enabled)`);
      console.log(`  Default: ${enabled.length > 0 ? enabled[0].name : 'none'}`);
      console.log('');
    }

    console.log('💡 Next steps:');
    console.log('  1. Review the generated template');
    console.log('  2. Copy to blockchain-explorers.json if needed');
    console.log('  3. Customize enabled providers and priorities');
    console.log('  4. Set up required API keys in environment variables:');

    // Show required environment variables
    const apiKeyProviders = allProviders.filter(p => p.requiresApiKey);
    if (apiKeyProviders.length > 0) {
      apiKeyProviders.forEach(provider => {
        const metadata = ProviderRegistry.getMetadata(provider.blockchain, provider.name);
        if (metadata?.apiKeyEnvVar) {
          console.log(`     export ${metadata.apiKeyEnvVar}="your_${provider.name}_api_key"`);
        }
      });
    }

    console.log('  5. Run `pnpm run config:validate` to verify');

  } catch (error) {
    console.error('❌ Failed to write configuration file:');
    console.error(error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    generateConfiguration();
  } catch (error) {
    console.error('❌ Failed to generate configuration:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

export { generateConfiguration };
===== ./src/scripts/list-providers.ts =====
#!/usr/bin/env tsx

/**
 * List all registered providers across all blockchains
 */

import { ProviderRegistry } from '../blockchains/shared/registry/index.ts';

// Import all providers to trigger registration
import '../blockchains/registry/register-providers.ts';

function formatRateLimit(rateLimit: any): string {
  const parts: string[] = [];
  if (rateLimit.requestsPerSecond) {
    parts.push(`${rateLimit.requestsPerSecond}/sec`);
  }
  if (rateLimit.requestsPerMinute) {
    parts.push(`${rateLimit.requestsPerMinute}/min`);
  }
  if (rateLimit.requestsPerHour) {
    parts.push(`${rateLimit.requestsPerHour}/hour`);
  }
  if (rateLimit.burstLimit) {
    parts.push(`burst:${rateLimit.burstLimit}`);
  }
  return parts.join(', ');
}

function formatCapabilities(capabilities: any): string {
  const features: string[] = [];
  if (capabilities.supportsHistoricalData) features.push('Historical');
  if (capabilities.supportsRealTimeData) features.push('Real-time');
  if (capabilities.supportsTokenData) features.push('Tokens');
  if (capabilities.supportsPagination) features.push('Pagination');
  if (capabilities.maxBatchSize > 1) features.push(`Batch:${capabilities.maxBatchSize}`);
  return features.join(', ') || 'Basic';
}

function listProviders(): void {
  console.log('🔍 Registered Blockchain Providers\n');

  const allProviders = ProviderRegistry.getAllProviders();

  if (allProviders.length === 0) {
    console.log('❌ No providers found. Ensure provider files are imported.');
    process.exit(1);
  }

  // Group providers by blockchain
  const providersByBlockchain = new Map<string, typeof allProviders>();

  for (const provider of allProviders) {
    if (!providersByBlockchain.has(provider.blockchain)) {
      providersByBlockchain.set(provider.blockchain, []);
    }
    providersByBlockchain.get(provider.blockchain)!.push(provider);
  }

  // Display providers by blockchain
  for (const [blockchain, providers] of providersByBlockchain.entries()) {
    console.log(`📋 ${blockchain.toUpperCase()}`);
    console.log('─'.repeat(50));

    for (const provider of providers) {
      console.log(`  ✓ ${provider.name}`);
      console.log(`    Name: ${provider.displayName}`);
      console.log(`    Type: ${provider.type}`);
      console.log(`    API Key Required: ${provider.requiresApiKey ? 'Yes' : 'No'}`);

      // Show API key environment variable if available
      const metadata = ProviderRegistry.getMetadata(blockchain, provider.name);
      if (metadata?.apiKeyEnvVar && provider.requiresApiKey) {
        console.log(`    Environment Variable: ${metadata.apiKeyEnvVar}`);
      }

      console.log(`    Rate Limits: ${formatRateLimit(provider.defaultConfig.rateLimit)}`);
      console.log(`    Networks: ${provider.supportedNetworks.join(', ')}`);
      console.log(`    Operations: ${provider.capabilities.supportedOperations.join(', ')}`);
      console.log(`    Features: ${formatCapabilities(provider.capabilities)}`);
      console.log(`    Timeout: ${provider.defaultConfig.timeout}ms, Retries: ${provider.defaultConfig.retries}`);

      if (provider.description) {
        console.log(`    Description: ${provider.description}`);
      }

      console.log('');
    }
  }

  // Summary
  console.log('📊 Summary');
  console.log('─'.repeat(20));
  console.log(`Total Blockchains: ${providersByBlockchain.size}`);
  console.log(`Total Providers: ${allProviders.length}`);

  const apiKeyRequired = allProviders.filter(p => p.requiresApiKey).length;
  console.log(`Require API Key: ${apiKeyRequired}`);
  console.log(`No API Key: ${allProviders.length - apiKeyRequired}`);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    listProviders();
  } catch (error) {
    console.error('❌ Failed to list providers:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

export { listProviders };
===== ./src/scripts/validate-providers.ts =====
#!/usr/bin/env tsx

/**
 * Validate that all providers are properly registered and functional
 */

import { ProviderRegistry } from '../blockchains/shared/registry/index.ts';

// Import all providers to trigger registration
import '../blockchains/registry/register-providers.ts';

interface ValidationResult {
  provider: string;
  blockchain: string;
  valid: boolean;
  errors: string[];
  warnings: string[];
}

function validateProvider(blockchain: string, providerName: string): ValidationResult {
  const result: ValidationResult = {
    provider: providerName,
    blockchain,
    valid: true,
    errors: [],
    warnings: []
  };

  try {
    // Check if provider is registered
    if (!ProviderRegistry.isRegistered(blockchain, providerName)) {
      result.valid = false;
      result.errors.push('Provider not found in registry');
      return result;
    }

    // Get metadata
    const metadata = ProviderRegistry.getMetadata(blockchain, providerName);
    if (!metadata) {
      result.valid = false;
      result.errors.push('No metadata found');
      return result;
    }

    // Validate metadata fields
    if (!metadata.name) {
      result.valid = false;
      result.errors.push('Missing name in metadata');
    }

    if (!metadata.displayName) {
      result.valid = false;
      result.errors.push('Missing displayName in metadata');
    }

    if (!metadata.networks?.mainnet?.baseUrl) {
      result.valid = false;
      result.errors.push('Missing mainnet baseUrl in metadata');
    }

    if (!metadata.defaultConfig?.rateLimit?.requestsPerSecond) {
      result.valid = false;
      result.errors.push('Missing rateLimit configuration');
    }

    if (!metadata.defaultConfig?.timeout) {
      result.valid = false;
      result.errors.push('Missing timeout configuration');
    }

    if (!metadata.capabilities) {
      result.valid = false;
      result.errors.push('Missing capabilities in metadata');
    } else {
      if (!metadata.capabilities.supportedOperations?.length) {
        result.warnings.push('No supported operations defined in capabilities');
      }
    }

    // Test provider instantiation
    try {
      const provider = ProviderRegistry.createProvider(blockchain, providerName, {});

      // Check provider properties
      if (provider.name !== providerName) {
        result.valid = false;
        result.errors.push(`Provider name mismatch: expected '${providerName}', got '${provider.name}'`);
      }

      if (provider.blockchain !== blockchain) {
        result.valid = false;
        result.errors.push(`Blockchain mismatch: expected '${blockchain}', got '${provider.blockchain}'`);
      }

      if (!provider.capabilities) {
        result.valid = false;
        result.errors.push('Missing capabilities');
      } else {
        if (!provider.capabilities.supportedOperations?.length) {
          result.warnings.push('No supported operations defined');
        }
      }

    } catch (error) {
      result.valid = false;
      result.errors.push(`Provider instantiation failed: ${error instanceof Error ? error.message : error}`);
    }

    // Warnings for best practices
    if (!metadata.description) {
      result.warnings.push('Missing description - consider adding for better documentation');
    }

    if (metadata.requiresApiKey && !metadata.networks?.testnet) {
      result.warnings.push('API key required but no testnet configuration - consider adding for testing');
    }

  } catch (error) {
    result.valid = false;
    result.errors.push(`Validation error: ${error instanceof Error ? error.message : error}`);
  }

  return result;
}

function validateProviders(): void {
  console.log('🔍 Validating Provider Registrations\n');

  const allProviders = ProviderRegistry.getAllProviders();

  if (allProviders.length === 0) {
    console.log('❌ No providers found. Ensure provider files are imported.');
    process.exit(1);
  }

  const results: ValidationResult[] = [];
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validate each provider
  for (const provider of allProviders) {
    const result = validateProvider(provider.blockchain, provider.name);
    results.push(result);

    if (!result.valid) {
      errors.push(...result.errors.map(err => `${provider.blockchain}:${provider.name} - ${err}`));
    }

    warnings.push(...result.warnings.map(warn => `${provider.blockchain}:${provider.name} - ${warn}`));
  }

  // Show results
  console.log('📋 Validation Results');
  console.log('─'.repeat(50));

  // Group by blockchain
  const providersByBlockchain = new Map<string, ValidationResult[]>();
  for (const result of results) {
    if (!providersByBlockchain.has(result.blockchain)) {
      providersByBlockchain.set(result.blockchain, []);
    }
    providersByBlockchain.get(result.blockchain)!.push(result);
  }

  for (const [blockchain, providerResults] of providersByBlockchain.entries()) {
    console.log(`\n${blockchain.toUpperCase()}:`);

    for (const result of providerResults) {
      const status = result.valid ? '✅' : '❌';
      console.log(`  ${status} ${result.provider}`);

      if (result.errors.length > 0) {
        result.errors.forEach(error => {
          console.log(`      ❌ ${error}`);
        });
      }

      if (result.warnings.length > 0) {
        result.warnings.forEach(warning => {
          console.log(`      ⚠️  ${warning}`);
        });
      }
    }
  }

  // Summary
  const validProviders = results.filter(r => r.valid).length;
  const invalidProviders = results.filter(r => !r.valid).length;

  console.log('\n📊 Summary');
  console.log('─'.repeat(20));
  console.log(`Total Providers: ${results.length}`);
  console.log(`Valid: ${validProviders}`);
  console.log(`Invalid: ${invalidProviders}`);
  console.log(`Warnings: ${warnings.length}`);

  if (invalidProviders > 0) {
    console.log('\n🚨 Validation Failed!');
    console.log('Fix the errors above before proceeding.');
    process.exit(1);
  } else if (warnings.length > 0) {
    console.log('\n⚠️  Validation Passed with Warnings');
    console.log('Consider addressing the warnings above for better provider quality.');
  } else {
    console.log('\n✅ All providers are valid!');
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    validateProviders();
  } catch (error) {
    console.error('❌ Failed to validate providers:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

export { validateProviders };
===== ./src/index.ts =====
export { ExchangeAdapterFactory } from './exchanges/index.ts';

// Main public API - Transaction importer service
export { TransactionImporter } from './services/importer.ts';

// Import-related types
export { TransactionNoteType } from './types.ts';
export type { ImportResult, ImportSummary } from './types.ts';

===== ./src/blockchains/solana/providers/SolscanProvider.ts =====
import { Decimal } from 'decimal.js';

import type { Balance, BlockchainTransaction } from '@crypto/core';

import { createMoney, maskAddress } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { SolscanTransaction } from '../types.ts';
import { isValidSolanaAddress, lamportsToSol } from '../utils.ts';


@RegisterProvider({
  name: 'solscan',
  blockchain: 'solana',
  displayName: 'Solscan API',
  type: 'rest',
  requiresApiKey: false,
  apiKeyEnvVar: 'SOLSCAN_API_KEY',
  description: 'Solana blockchain explorer API with transaction and account data access',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://public-api.solscan.io'
    },
    testnet: {
      baseUrl: 'https://api.solscan.io'
    },
    devnet: {
      baseUrl: 'https://api.solscan.io'
    }
  },
  defaultConfig: {
    timeout: 15000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 0.2, // Conservative: 1 request per 5 seconds
      burstLimit: 1
    }
  }
})
export class SolscanProvider extends BaseRegistryProvider {

  constructor() {
    super('solana', 'solscan', 'mainnet');

    // Override HTTP client to add browser-like headers for Solscan
    this.reinitializeHttpClient({
      defaultHeaders: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        ...(this.apiKey && this.apiKey !== 'YourApiKeyToken' && { 'Authorization': `Bearer ${this.apiKey}` })
      }
    });
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.get('/account/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
      return response && response.success !== false;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.httpClient.get('/account/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
      this.logger.debug(`Connection test successful - HasResponse: ${!!response}`);
      return response && response.success !== false;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${JSON.stringify(operation.params)}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}, Since: ${since}, Network: ${this.network}`);

    try {
      const response = await this.httpClient.get(`/account/transaction?address=${address}&limit=100&offset=0`);

      this.logger.debug(`Solscan API response received - HasResponse: ${!!response}, Success: ${response?.success}, HasData: ${!!response?.data}, TransactionCount: ${response?.data?.length || 0}`);

      if (!response || !response.success || !response.data) {
        this.logger.debug(`No transactions found or API error - Address: ${maskAddress(address)}`);
        return [];
      }

      const transactions: BlockchainTransaction[] = [];

      for (const tx of response.data) {
        try {
          const blockchainTx = this.transformTransaction(tx, address);
          if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
            transactions.push(blockchainTx);
          }
        } catch (error) {
          this.logger.warn(`Failed to transform transaction - TxHash: ${tx.txHash}, Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      // Sort by timestamp (newest first)
      transactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${transactions.length}, Network: ${this.network}`);

      return transactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance> {
    const { address } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const response = await this.httpClient.get(`/account/${address}`);

      if (!response || !response.success || !response.data) {
        throw new Error('Failed to fetch balance from Solscan API');
      }

      const lamports = new Decimal(response.data.lamports || '0');
      const solBalance = lamportsToSol(lamports.toNumber());

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceSOL: ${solBalance.toNumber()}, Network: ${this.network}`);

      return {
        currency: 'SOL',
        balance: solBalance.toNumber(),
        used: 0,
        total: solBalance.toNumber()
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private transformTransaction(tx: SolscanTransaction, userAddress: string): BlockchainTransaction | null {
    try {
      // Check if user is involved in the transaction
      const isUserSigner = tx.signer.includes(userAddress);
      const userAccount = tx.inputAccount?.find(acc => acc.account === userAddress);

      if (!isUserSigner && !userAccount) {
        this.logger.debug(`Transaction not relevant to user address - TxHash: ${tx.txHash}`);
        return null;
      }

      // Calculate amount and determine direction
      let amount = new Decimal(0);
      let type: 'transfer_in' | 'transfer_out' = 'transfer_out';

      if (userAccount) {
        const balanceChange = userAccount.postBalance - userAccount.preBalance;
        amount = lamportsToSol(Math.abs(balanceChange));
        type = balanceChange > 0 ? 'transfer_in' : 'transfer_out';
      } else {
        // Fallback to lamport field if available
        amount = lamportsToSol(Math.abs(tx.lamport || 0));
        type = 'transfer_out';
      }

      // Calculate fee
      const fee = lamportsToSol(tx.fee);

      return {
        hash: tx.txHash,
        blockNumber: tx.slot,
        blockHash: '',
        timestamp: tx.blockTime * 1000,
        from: tx.signer?.[0] || '',
        to: '',
        value: createMoney(amount.toNumber(), 'SOL'),
        fee: createMoney(fee.toNumber(), 'SOL'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.status === 'Success' ? 'success' : 'failed',
        type,
        tokenContract: undefined,
        tokenSymbol: 'SOL',
        nonce: undefined,
        confirmations: 1
      };
    } catch (error) {
      this.logger.warn(`Failed to transform transaction - TxHash: ${tx.txHash}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

}===== ./src/blockchains/solana/providers/SolanaRPCProvider.ts =====
import { Decimal } from 'decimal.js';

import type { Balance, BlockchainTransaction } from '@crypto/core';

import { createMoney, maskAddress } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { SolanaRPCTransaction } from '../types.ts';
import { isValidSolanaAddress, lamportsToSol } from '../utils.ts';


@RegisterProvider({
  name: 'solana-rpc',
  blockchain: 'solana',
  displayName: 'Solana RPC',
  type: 'rpc',
  requiresApiKey: false,
  description: 'Direct connection to Solana mainnet RPC endpoints with basic transaction data',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://api.mainnet-beta.solana.com'
    },
    testnet: {
      baseUrl: 'https://api.testnet.solana.com'
    },
    devnet: {
      baseUrl: 'https://api.devnet.solana.com'
    }
  },
  defaultConfig: {
    timeout: 30000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 1, // Conservative for public RPC
      burstLimit: 2
    }
  }
})
export class SolanaRPCProvider extends BaseRegistryProvider {

  constructor() {
    super('solana', 'solana-rpc', 'mainnet');
  }


  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getHealth'
      });
      return response && response.result === 'ok';
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getHealth'
      });
      this.logger.debug(`Connection test successful - Health: ${response?.result}`);
      return response && response.result === 'ok';
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getTokenTransactions':
          return this.getTokenTransactions(operation.params as { address: string; contractAddress?: string; since?: number }) as T;
        case 'getTokenBalances':
          return this.getTokenBalances(operation.params as { address: string; contractAddresses?: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get signatures for address
      const signaturesResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getSignaturesForAddress',
        params: [
          address,
          {
            limit: 100
          }
        ]
      });

      if (!signaturesResponse?.result) {
        this.logger.debug(`No signatures found - Address: ${maskAddress(address)}`);
        return [];
      }

      const transactions: BlockchainTransaction[] = [];
      const signatures = signaturesResponse.result.slice(0, 50); // Limit for performance

      this.logger.debug(`Retrieved signatures - Address: ${maskAddress(address)}, Count: ${signatures.length}`);

      // Fetch transaction details
      for (const sig of signatures) {
        try {
          const txResponse = await this.httpClient.post('/', {
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [
              sig.signature,
              {
                encoding: 'json',
                maxSupportedTransactionVersion: 0
              }
            ]
          });

          if (txResponse?.result) {
            const blockchainTx = this.transformTransaction(txResponse.result, address);
            if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
              transactions.push(blockchainTx);
            }
          }
        } catch (error) {
          this.logger.debug(`Failed to fetch transaction details - Signature: ${sig.signature}, Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      // Sort by timestamp (newest first)
      transactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${transactions.length}, Network: ${this.network}`);

      return transactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance> {
    const { address } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getBalance',
        params: [address]
      });

      if (!response?.result || response.result.value === undefined) {
        throw new Error('Failed to fetch balance from Solana RPC');
      }

      const lamports = new Decimal(response.result.value);
      const solBalance = lamportsToSol(lamports.toNumber());

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceSOL: ${solBalance.toNumber()}, Network: ${this.network}`);

      return {
        currency: 'SOL',
        balance: solBalance.toNumber(),
        used: 0,
        total: solBalance.toNumber()
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private transformTransaction(tx: SolanaRPCTransaction, userAddress: string): BlockchainTransaction | null {
    try {
      const accountKeys = tx.transaction.message.accountKeys;
      const userIndex = accountKeys.findIndex(key => key === userAddress);

      if (userIndex === -1) {
        this.logger.debug(`Transaction not relevant to user - Signature: ${tx.transaction.signatures?.[0]}`);
        return null;
      }

      // Calculate balance change
      const preBalance = tx.meta.preBalances[userIndex] || 0;
      const postBalance = tx.meta.postBalances[userIndex] || 0;
      const rawBalanceChange = postBalance - preBalance;

      // For fee payer, add back the fee to get the actual transfer amount
      const isFeePayerIndex = userIndex === 0;
      const feeAdjustment = isFeePayerIndex ? tx.meta.fee : 0;
      const balanceChange = rawBalanceChange + feeAdjustment;

      const amount = lamportsToSol(Math.abs(balanceChange));
      const type: 'transfer_in' | 'transfer_out' = balanceChange > 0 ? 'transfer_in' : 'transfer_out';
      const fee = lamportsToSol(tx.meta.fee);

      // Skip transactions with no meaningful amount (pure fee transactions)
      if (amount.toNumber() <= fee.toNumber() && amount.toNumber() < 0.000001) {
        this.logger.debug(`Skipping fee-only transaction - Hash: ${tx.transaction.signatures?.[0]}, Amount: ${amount.toNumber()}, Fee: ${fee.toNumber()}`);
        return null;
      }

      return {
        hash: tx.transaction.signatures?.[0] || '',
        blockNumber: tx.slot,
        blockHash: '',
        timestamp: (tx.blockTime || 0) * 1000,
        from: accountKeys?.[0] || '',
        to: '',
        value: createMoney(amount.toNumber(), 'SOL'),
        fee: createMoney(fee.toNumber(), 'SOL'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.meta.err ? 'failed' : 'success',
        type,
        tokenContract: undefined,
        tokenSymbol: 'SOL',
        nonce: undefined,
        confirmations: 1
      };
    } catch (error) {
      this.logger.warn(`Failed to transform transaction - Signature: ${tx.transaction.signatures?.[0]}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  private async getTokenTransactions(params: { address: string; contractAddress?: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, contractAddress, since } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching token transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get all signatures for this address (same as regular transactions)
      const signaturesResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getSignaturesForAddress',
        params: [
          address,
          {
            limit: 1000  // Increase limit to find more historical token transactions
          }
        ]
      });

      if (!signaturesResponse?.result) {
        this.logger.debug(`No signatures found for token transactions - Address: ${maskAddress(address)}`);
        return [];
      }

      const signatures = signaturesResponse.result.slice(0, 100); // Process more signatures for token transactions
      const tokenTransactions: BlockchainTransaction[] = [];

      // Process signatures individually to find token transactions (avoid batch requests)
      for (const sig of signatures) {
        try {
          const txResponse = await this.httpClient.post('/', {
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [
              sig.signature,
              {
                encoding: 'json',
                maxSupportedTransactionVersion: 0
              }
            ]
          });

          if (txResponse?.result) {
            const tokenTx = this.extractTokenTransaction(txResponse.result, address, contractAddress);
            if (tokenTx && (!since || tokenTx.timestamp >= since)) {
              tokenTransactions.push(tokenTx);
            }
          }
        } catch (error) {
          this.logger.debug(`Failed to fetch token transaction details - Signature: ${sig.signature}, Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      tokenTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved token transactions - Address: ${maskAddress(address)}, TotalTransactions: ${tokenTransactions.length}, Network: ${this.network}`);

      return tokenTransactions;

    } catch (error) {
      this.logger.error(`Failed to get token transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenBalances(params: { address: string; contractAddresses?: string[] }): Promise<Balance[]> {
    const { address, contractAddresses } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching token balances - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get all token accounts owned by the address
      const tokenAccountsResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getTokenAccountsByOwner',
        params: [
          address,
          {
            programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' // SPL Token Program ID
          },
          {
            encoding: 'jsonParsed'
          }
        ]
      });

      if (!tokenAccountsResponse?.result?.value) {
        this.logger.debug(`No token accounts found - Address: ${maskAddress(address)}`);
        return [];
      }

      const tokenAccounts = tokenAccountsResponse.result.value;
      const balances: Balance[] = [];

      for (const account of tokenAccounts) {
        const accountData = account.account.data.parsed;
        if (!accountData || !accountData.info) continue;

        const tokenInfo = accountData.info;
        const mintAddress = tokenInfo.mint;
        const tokenAmount = tokenInfo.tokenAmount;

        // If specific contract addresses are provided, filter by them
        if (contractAddresses && contractAddresses.length > 0) {
          if (!contractAddresses.includes(mintAddress)) {
            continue;
          }
        }

        // Skip zero balances
        if (!tokenAmount.uiAmount || tokenAmount.uiAmount === 0) {
          continue;
        }

        balances.push({
          currency: mintAddress.slice(0, 8), // Use truncated mint address as symbol for now
          balance: tokenAmount.uiAmount,
          used: 0,
          total: tokenAmount.uiAmount,
          contractAddress: mintAddress
        });
      }

      this.logger.debug(`Successfully retrieved token balances - Address: ${maskAddress(address)}, TotalTokens: ${balances.length}, Network: ${this.network}`);

      return balances;

    } catch (error) {
      this.logger.error(`Failed to get token balances - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private extractTokenTransaction(tx: SolanaRPCTransaction, userAddress: string, targetContract?: string): BlockchainTransaction | null {
    try {
      // Look for token balance changes in preTokenBalances and postTokenBalances
      const preTokenBalances = tx.meta.preTokenBalances || [];
      const postTokenBalances = tx.meta.postTokenBalances || [];

      // Find changes for token accounts
      for (const postBalance of postTokenBalances) {
        const preBalance = preTokenBalances.find(pre =>
          pre.accountIndex === postBalance.accountIndex &&
          pre.mint === postBalance.mint
        );

        const preAmount = preBalance ? parseFloat(preBalance.uiTokenAmount.uiAmountString || '0') : 0;
        const postAmount = parseFloat(postBalance.uiTokenAmount.uiAmountString || '0');
        const change = postAmount - preAmount;

        // Skip if no meaningful change
        if (Math.abs(change) < 0.000001) {
          continue;
        }

        // If a specific contract is specified, filter by it
        if (targetContract && postBalance.mint !== targetContract) {
          continue;
        }

        // Log any significant token transaction
        this.logger.debug(`Found SPL token transaction - Signature: ${tx.transaction.signatures?.[0]}, Mint: ${postBalance.mint}, Change: ${Math.abs(change)}, Type: ${change > 0 ? 'transfer_in' : 'transfer_out'}`);

        // Determine transfer direction
        const type: 'transfer_in' | 'transfer_out' = change > 0 ? 'transfer_in' : 'transfer_out';

        return {
          hash: tx.transaction.signatures?.[0] || '',
          blockNumber: tx.slot,
          blockHash: '',
          timestamp: (tx.blockTime || 0) * 1000,
          from: type === 'transfer_out' ? userAddress : '',
          to: type === 'transfer_in' ? userAddress : '',
          value: createMoney(Math.abs(change), 'UNKNOWN'), // Will be updated with proper symbol later
          fee: createMoney(lamportsToSol(tx.meta.fee).toNumber(), 'SOL'),
          gasUsed: undefined,
          gasPrice: undefined,
          status: tx.meta.err ? 'failed' : 'success',
          type: 'token_transfer',
          tokenContract: postBalance.mint,
          tokenSymbol: postBalance.uiTokenAmount.uiAmountString?.includes('.') ? 'UNKNOWN' : 'UNKNOWN',
          nonce: undefined,
          confirmations: 1
        };
      }

      return null;
    } catch (error) {
      this.logger.debug(`Failed to extract token transaction - Signature: ${tx.transaction.signatures?.[0]}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

}===== ./src/blockchains/solana/providers/HeliusProvider.ts =====
import { Decimal } from 'decimal.js';

import type { Balance, BlockchainTransaction } from '@crypto/core';

import { createMoney, maskAddress } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import { isValidSolanaAddress, lamportsToSol } from '../utils.ts';


interface HeliusTransaction {
  signature: string;
  slot: number;
  blockTime?: number;
  err: any;
  meta: {
    fee: number;
    preBalances: number[];
    postBalances: number[];
    preTokenBalances?: any[];
    postTokenBalances?: any[];
    logMessages: string[];
    err: any;
  };
  transaction: {
    message: {
      accountKeys: string[];
      instructions: any[];
      recentBlockhash: string;
    };
    signatures: string[];
  };
}

@RegisterProvider({
  name: 'helius',
  blockchain: 'solana',
  displayName: 'Helius RPC API',
  type: 'rpc',
  requiresApiKey: true,
  apiKeyEnvVar: 'SOLANA_HELIUS_API_KEY',
  description: 'High-performance Solana RPC API with comprehensive transaction data and token support',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://mainnet.helius-rpc.com'
    },
    testnet: {
      baseUrl: 'https://rpc.helius.xyz'
    },
    devnet: {
      baseUrl: 'https://rpc.helius.xyz'
    }
  },
  defaultConfig: {
    timeout: 30000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 10, // Helius has generous rate limits
      requestsPerMinute: 500,
      requestsPerHour: 5000,
      burstLimit: 20
    }
  }
})
export class HeliusProvider extends BaseRegistryProvider {
  private tokenSymbolCache = new Map<string, string>();

  constructor() {
    super('solana', 'helius', 'mainnet');

    // Helius needs API key in URL, so reinitialize HTTP client
    if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
      const heliusUrl = `${this.baseUrl}/?api-key=${this.apiKey}`;
      this.reinitializeHttpClient({
        baseUrl: heliusUrl,
        defaultHeaders: {
          'Content-Type': 'application/json'
        }
      });
    }
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getHealth'
      });
      return response && response.result === 'ok';
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getHealth'
      });
      this.logger.debug(`Connection test successful - Health: ${response?.result}`);
      return response && response.result === 'ok';
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getTokenTransactions':
          return this.getTokenTransactions(operation.params as { address: string; contractAddress?: string; since?: number }) as T;
        case 'getTokenBalances':
          return this.getTokenBalances(operation.params as { address: string; contractAddresses?: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address transactions with token account discovery - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Step 1: Get direct transactions for the address
      const directTransactions = await this.getDirectAddressTransactions(address, since);

      // Step 2: Get token accounts owned by the address  
      const tokenAccounts = await this.getTokenAccountsOwnedByAddress(address);

      // Step 3: Fetch transactions for each token account
      const tokenAccountTransactions = await this.fetchTokenAccountTransactions(tokenAccounts, since, address);

      // Step 4: Combine and deduplicate all transactions
      const allTransactions = this.deduplicateTransactions([...directTransactions, ...tokenAccountTransactions]);

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions with token account discovery - Address: ${maskAddress(address)}, DirectTransactions: ${directTransactions.length}, TokenAccounts: ${tokenAccounts.length}, TokenAccountTransactions: ${tokenAccountTransactions.length}, TotalUniqueTransactions: ${allTransactions.length}, Network: ${this.network}`);

      return allTransactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getDirectAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    // Get signatures for address (direct involvement)
    const signaturesResponse = await this.httpClient.post('/', {
      jsonrpc: '2.0',
      id: 1,
      method: 'getSignaturesForAddress',
      params: [
        address,
        {
          limit: 100
        }
      ]
    });

    if (!signaturesResponse?.result) {
      this.logger.debug(`No direct signatures found - Address: ${maskAddress(address)}`);
      return [];
    }

    const transactions: BlockchainTransaction[] = [];
    const signatures = signaturesResponse.result.slice(0, 50);

    this.logger.debug(`Retrieved direct signatures - Address: ${maskAddress(address)}, Count: ${signatures.length}`);

    // Fetch transaction details individually (free tier doesn't support batch requests)
    for (const sig of signatures) {
      try {
        const txResponse = await this.httpClient.post('/', {
          jsonrpc: '2.0',
          id: 1,
          method: 'getTransaction',
          params: [
            sig.signature,
            {
              encoding: 'json',
              maxSupportedTransactionVersion: 0
            }
          ]
        });

        if (txResponse?.result) {
          const blockchainTx = await this.transformTransaction(txResponse.result, address);
          if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
            transactions.push(blockchainTx);
          }
        }
      } catch (error) {
        this.logger.debug(`Failed to fetch direct transaction details - Signature: ${sig.signature}, Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    return transactions;
  }

  private async getTokenAccountsOwnedByAddress(address: string): Promise<string[]> {
    try {
      // Get all token accounts owned by the address
      const tokenAccountsResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getTokenAccountsByOwner',
        params: [
          address,
          {
            programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' // SPL Token Program ID
          },
          {
            encoding: 'jsonParsed'
          }
        ]
      });

      if (!tokenAccountsResponse?.result?.value) {
        this.logger.debug(`No token accounts found - Address: ${maskAddress(address)}`);
        return [];
      }

      const tokenAccountAddresses = tokenAccountsResponse.result.value.map((account: any) => account.pubkey);

      this.logger.debug(`Found token accounts owned by address - Address: ${maskAddress(address)}, TokenAccountCount: ${tokenAccountAddresses.length}`);

      return tokenAccountAddresses;
    } catch (error) {
      this.logger.warn(`Failed to get token accounts - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  private async fetchTokenAccountTransactions(tokenAccountAddresses: string[], since?: number, ownerAddress?: string): Promise<BlockchainTransaction[]> {
    const allTokenTransactions: BlockchainTransaction[] = [];

    for (const tokenAccount of tokenAccountAddresses) {
      try {
        // Get signatures for this token account
        const signaturesResponse = await this.httpClient.post('/', {
          jsonrpc: '2.0',
          id: 1,
          method: 'getSignaturesForAddress',
          params: [
            tokenAccount,
            {
              limit: 50 // Limit per token account to avoid overwhelming
            }
          ]
        });

        if (!signaturesResponse?.result?.length) {
          continue;
        }

        // Fetch transaction details for token account signatures
        for (const sig of signaturesResponse.result.slice(0, 20)) {
          try {
            const txResponse = await this.httpClient.post('/', {
              jsonrpc: '2.0',
              id: 1,
              method: 'getTransaction',
              params: [
                sig.signature,
                {
                  encoding: 'json',
                  maxSupportedTransactionVersion: 0
                }
              ]
            });

            if (txResponse?.result) {
              // Transform transaction but link it back to the owner address
              // For token account transactions, we bypass the relevance check since we found it via token account
              const blockchainTx = await this.transformTokenAccountTransaction(txResponse.result, ownerAddress || tokenAccount);
              if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
                allTokenTransactions.push(blockchainTx);
              }
            }
          } catch (error) {
            this.logger.debug(`Failed to fetch token account transaction - TokenAccount: ${maskAddress(tokenAccount)}, Signature: ${sig.signature}, Error: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      } catch (error) {
        this.logger.warn(`Failed to get signatures for token account - TokenAccount: ${maskAddress(tokenAccount)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    return allTokenTransactions;
  }

  private deduplicateTransactions(transactions: BlockchainTransaction[]): BlockchainTransaction[] {
    const seen = new Set<string>();
    const unique: BlockchainTransaction[] = [];

    for (const tx of transactions) {
      if (!seen.has(tx.hash)) {
        seen.add(tx.hash);
        unique.push(tx);
      }
    }

    this.logger.debug(`Deduplicated transactions - Original: ${transactions.length}, Unique: ${unique.length}`);

    return unique;
  }

  private async transformTokenAccountTransaction(tx: HeliusTransaction, userAddress: string): Promise<BlockchainTransaction | null> {
    try {
      // For token account transactions, we bypass the accountKeys relevance check
      // since we already know this transaction affects the user's token accounts

      // First check for token transfers - these are more important than SOL transfers
      const tokenTransaction = await this.extractTokenTransaction(tx, userAddress);
      if (tokenTransaction) {
        return tokenTransaction;
      }

      // Fall back to SOL transfer handling (similar to transformTransaction but without relevance check)
      const accountKeys = tx.transaction.message.accountKeys;
      const userIndex = accountKeys.findIndex(key => key === userAddress);

      if (userIndex !== -1) {
        // User is directly involved, use normal processing
        const preBalance = tx.meta.preBalances[userIndex] || 0;
        const postBalance = tx.meta.postBalances[userIndex] || 0;
        const rawBalanceChange = postBalance - preBalance;

        // For fee payer, add back the fee to get the actual transfer amount
        const isFeePayerIndex = userIndex === 0;
        const feeAdjustment = isFeePayerIndex ? tx.meta.fee : 0;
        const balanceChange = rawBalanceChange + feeAdjustment;

        const amount = lamportsToSol(Math.abs(balanceChange));
        const type: 'transfer_in' | 'transfer_out' = balanceChange > 0 ? 'transfer_in' : 'transfer_out';
        const fee = lamportsToSol(tx.meta.fee);

        // Skip transactions with no meaningful amount (pure fee transactions)
        if (amount.toNumber() <= fee.toNumber() && amount.toNumber() < 0.000001) {
          this.logger.debug(`Skipping fee-only token account transaction - Hash: ${tx.transaction.signatures?.[0]}, Amount: ${amount.toNumber()}, Fee: ${fee.toNumber()}`);
          return null;
        }

        return {
          hash: tx.transaction.signatures?.[0] || '',
          blockNumber: tx.slot,
          blockHash: '',
          timestamp: tx.blockTime || 0,
          from: accountKeys?.[0] || '',
          to: '',
          value: createMoney(amount.toNumber(), 'SOL'),
          fee: createMoney(fee.toNumber(), 'SOL'),
          gasUsed: undefined,
          gasPrice: undefined,
          status: tx.meta.err ? 'failed' : 'success',
          type,
          tokenContract: undefined,
          tokenSymbol: 'SOL',
          nonce: undefined,
          confirmations: 1
        };
      }

      // User not directly involved but we found this via token account - still check for token changes
      this.logger.debug(`Token account transaction found via token account but user not in accountKeys - Signature: ${tx.transaction.signatures?.[0]}, UserAddress: ${maskAddress(userAddress)}`);

      return null;
    } catch (error) {
      this.logger.warn(`Failed to transform token account transaction - Signature: ${tx.transaction.signatures?.[0]}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance> {
    const { address } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getBalance',
        params: [address]
      });

      if (!response?.result || response.result.value === undefined) {
        throw new Error('Failed to fetch balance from Helius RPC');
      }

      const lamports = new Decimal(response.result.value);
      const solBalance = lamportsToSol(lamports.toNumber());

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceSOL: ${solBalance.toNumber()}, Network: ${this.network}`);

      return {
        currency: 'SOL',
        balance: solBalance.toNumber(),
        used: 0,
        total: solBalance.toNumber()
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async transformTransaction(tx: HeliusTransaction, userAddress: string): Promise<BlockchainTransaction | null> {
    try {
      const accountKeys = tx.transaction.message.accountKeys;
      const userIndex = accountKeys.findIndex(key => key === userAddress);

      if (userIndex === -1) {
        this.logger.debug(`Transaction not relevant to user - Signature: ${tx.transaction.signatures?.[0]}`);
        return null;
      }

      // First check for token transfers - these are more important than SOL transfers
      const tokenTransaction = await this.extractTokenTransaction(tx, userAddress);
      if (tokenTransaction) {
        return tokenTransaction;
      }

      // Fall back to SOL transfer handling
      const preBalance = tx.meta.preBalances[userIndex] || 0;
      const postBalance = tx.meta.postBalances[userIndex] || 0;
      const rawBalanceChange = postBalance - preBalance;

      // For fee payer, add back the fee to get the actual transfer amount
      const isFeePayerIndex = userIndex === 0;
      const feeAdjustment = isFeePayerIndex ? tx.meta.fee : 0;
      const balanceChange = rawBalanceChange + feeAdjustment;

      const amount = lamportsToSol(Math.abs(balanceChange));
      const type: 'transfer_in' | 'transfer_out' = balanceChange > 0 ? 'transfer_in' : 'transfer_out';
      const fee = lamportsToSol(tx.meta.fee);

      // Skip transactions with no meaningful amount (pure fee transactions)
      if (amount.toNumber() <= fee.toNumber() && amount.toNumber() < 0.000001) {
        this.logger.debug(`Skipping fee-only transaction - Hash: ${tx.transaction.signatures?.[0]}, Amount: ${amount.toNumber()}, Fee: ${fee.toNumber()}`);
        return null;
      }

      return {
        hash: tx.transaction.signatures?.[0] || '',
        blockNumber: tx.slot,
        blockHash: '',
        timestamp: tx.blockTime || 0,
        from: accountKeys?.[0] || '',
        to: '',
        value: createMoney(amount.toNumber(), 'SOL'),
        fee: createMoney(fee.toNumber(), 'SOL'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.meta.err ? 'failed' : 'success',
        type,
        tokenContract: undefined,
        tokenSymbol: 'SOL',
        nonce: undefined,
        confirmations: 1
      };
    } catch (error) {
      this.logger.warn(`Failed to transform transaction - Signature: ${tx.transaction.signatures?.[0]}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  private async getTokenTransactions(params: { address: string; contractAddress?: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, contractAddress, since } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching token transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get signatures for address (same as regular transactions)
      const signaturesResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getSignaturesForAddress',
        params: [
          address,
          {
            limit: 1000  // Increase limit to find historical token transactions
          }
        ]
      });

      if (!signaturesResponse?.result) {
        this.logger.debug(`No signatures found for token transactions - Address: ${maskAddress(address)}`);
        return [];
      }

      const signatures = signaturesResponse.result.slice(0, 100); // Process more signatures for token transactions
      const tokenTransactions: BlockchainTransaction[] = [];

      // Process signatures individually to find token transactions (free tier doesn't support batch requests)
      for (const sig of signatures) {
        try {
          const txResponse = await this.httpClient.post('/', {
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [
              sig.signature,
              {
                encoding: 'json',
                maxSupportedTransactionVersion: 0
              }
            ]
          });

          if (txResponse?.result) {
            const tokenTx = await this.extractTokenTransaction(txResponse.result, address, contractAddress);
            if (tokenTx && (!since || tokenTx.timestamp >= since)) {
              tokenTransactions.push(tokenTx);
            }
          }
        } catch (error) {
          this.logger.debug(`Failed to fetch token transaction details - Signature: ${sig.signature}, Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      tokenTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved token transactions - Address: ${maskAddress(address)}, TotalTransactions: ${tokenTransactions.length}, Network: ${this.network}`);

      return tokenTransactions;

    } catch (error) {
      this.logger.error(`Failed to get token transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenBalances(params: { address: string; contractAddresses?: string[] }): Promise<Balance[]> {
    const { address, contractAddresses } = params;

    if (!isValidSolanaAddress(address)) {
      throw new Error(`Invalid Solana address: ${address}`);
    }

    this.logger.debug(`Fetching token balances - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get all token accounts owned by the address
      const tokenAccountsResponse = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getTokenAccountsByOwner',
        params: [
          address,
          {
            programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' // SPL Token Program ID
          },
          {
            encoding: 'jsonParsed'
          }
        ]
      });

      if (!tokenAccountsResponse?.result?.value) {
        this.logger.debug(`No token accounts found - Address: ${maskAddress(address)}`);
        return [];
      }

      const tokenAccounts = tokenAccountsResponse.result.value;
      const balances: Balance[] = [];

      for (const account of tokenAccounts) {
        const accountData = account.account.data.parsed;
        if (!accountData || !accountData.info) continue;

        const tokenInfo = accountData.info;
        const mintAddress = tokenInfo.mint;
        const tokenAmount = tokenInfo.tokenAmount;

        // If specific contract addresses are provided, filter by them
        if (contractAddresses && contractAddresses.length > 0) {
          if (!contractAddresses.includes(mintAddress)) {
            continue;
          }
        }

        // Skip zero balances
        if (!tokenAmount.uiAmount || tokenAmount.uiAmount === 0) {
          continue;
        }

        balances.push({
          currency: mintAddress.slice(0, 8), // Use truncated mint address as symbol for now
          balance: tokenAmount.uiAmount,
          used: 0,
          total: tokenAmount.uiAmount,
          contractAddress: mintAddress
        });
      }

      this.logger.debug(`Successfully retrieved token balances - Address: ${maskAddress(address)}, TotalTokens: ${balances.length}, Network: ${this.network}`);

      return balances;

    } catch (error) {
      this.logger.error(`Failed to get token balances - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async extractTokenTransaction(tx: HeliusTransaction, userAddress: string, targetContract?: string): Promise<BlockchainTransaction | null> {
    try {
      // Look for token balance changes in preTokenBalances and postTokenBalances
      const preTokenBalances = tx.meta.preTokenBalances || [];
      const postTokenBalances = tx.meta.postTokenBalances || [];

      // Find changes for token accounts owned by the user
      for (const postBalance of postTokenBalances) {
        // Check if this token account is owned by the user
        if (postBalance.owner !== userAddress) {
          continue;
        }

        const preBalance = preTokenBalances.find(pre =>
          pre.accountIndex === postBalance.accountIndex &&
          pre.mint === postBalance.mint
        );

        const preAmount = preBalance ? parseFloat(preBalance.uiTokenAmount.uiAmountString || '0') : 0;
        const postAmount = parseFloat(postBalance.uiTokenAmount.uiAmountString || '0');
        const change = postAmount - preAmount;

        // Skip if no meaningful change
        if (Math.abs(change) < 0.000001) {
          continue;
        }

        // If a specific contract is specified, filter by it
        if (targetContract && postBalance.mint !== targetContract) {
          continue;
        }

        // Log any significant token transaction
        this.logger.debug(`Found SPL token transaction - Signature: ${tx.transaction.signatures?.[0]}, Mint: ${postBalance.mint}, Owner: ${postBalance.owner}, Change: ${Math.abs(change)}, Type: ${change > 0 ? 'transfer_in' : 'transfer_out'}`);

        // Determine transfer direction
        const type: 'transfer_in' | 'transfer_out' = change > 0 ? 'transfer_in' : 'transfer_out';

        // Get proper token symbol using hybrid approach (cache + API)
        const tokenSymbol = await this.getTokenSymbol(postBalance.mint);

        return {
          hash: tx.transaction.signatures?.[0] || '',
          blockNumber: tx.slot,
          blockHash: '',
          timestamp: tx.blockTime || 0,
          from: type === 'transfer_out' ? userAddress : '',
          to: type === 'transfer_in' ? userAddress : '',
          value: createMoney(Math.abs(change), tokenSymbol),
          fee: createMoney(lamportsToSol(tx.meta.fee).toNumber(), 'SOL'),
          gasUsed: undefined,
          gasPrice: undefined,
          status: tx.meta.err ? 'failed' : 'success',
          type: 'token_transfer',
          tokenContract: postBalance.mint,
          tokenSymbol,
          nonce: undefined,
          confirmations: 1
        };
      }

      return null;
    } catch (error) {
      this.logger.debug(`Failed to extract token transaction - Signature: ${tx.transaction.signatures?.[0]}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }


  /**
   * Static token registry for common Solana tokens
   * This provides fast lookups for well-known tokens
   */
  private static readonly KNOWN_TOKENS = new Map<string, string>([
    // Popular SPL Tokens
    ['rndrizKT3MK1iimdxRdWabcF7Zg7AR5T4nud4EkHBof', 'RENDER'], // Render Network
    ['hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux', 'HNT'], // Helium Network Token
    ['4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R', 'RAY'], // Raydium
    ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', 'USDC'], // USD Coin (official)
    ['Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', 'USDT'], // Tether USD
    ['mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', 'mSOL'], // Marinade Staked SOL
    ['7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj', 'stSOL'], // Lido Staked SOL
    ['J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn', 'jitoSOL'], // Jito Staked SOL
    ['bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1', 'bSOL'], // BlazeStake Staked SOL
    ['DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', 'BONK'], // Bonk
    ['5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm', 'INF'], // Infinity Protocol
    ['7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs', 'ETH'], // Wrapped Ethereum
    ['9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E', 'BTC'], // Wrapped Bitcoin
    // ['BvkjtktEZyjix9rSKEiA3ftMU1UCS61XEERFxtMqN1zd', 'UNKNOWN'] // Remove to test API fallback for scam token
  ]);

  /**
   * Get token symbol using hybrid approach: static registry first, then API fallback
   */
  private async getTokenSymbol(mintAddress: string): Promise<string> {
    // Check cache first
    if (this.tokenSymbolCache.has(mintAddress)) {
      return this.tokenSymbolCache.get(mintAddress)!;
    }

    // Check static registry
    const knownSymbol = HeliusProvider.KNOWN_TOKENS.get(mintAddress);
    if (knownSymbol) {
      this.tokenSymbolCache.set(mintAddress, knownSymbol);
      this.logger.debug(`Found token symbol in static registry - Mint: ${maskAddress(mintAddress)}, Symbol: ${knownSymbol}`);
      return knownSymbol;
    }

    // Fallback to Helius DAS API
    try {
      const symbol = await this.fetchTokenSymbolFromAPI(mintAddress);
      this.tokenSymbolCache.set(mintAddress, symbol);
      this.logger.debug(`Fetched token symbol from API - Mint: ${maskAddress(mintAddress)}`);
      return symbol;
    } catch (error) {
      // Final fallback to truncated mint address
      const fallbackSymbol = `${mintAddress.slice(0, 6)}...`;
      this.tokenSymbolCache.set(mintAddress, fallbackSymbol);
      this.logger.warn(`Failed to fetch token symbol, using fallback - Mint: ${maskAddress(mintAddress)}, Symbol: ${fallbackSymbol}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return fallbackSymbol;
    }
  }

  /**
   * Fetch token symbol from Helius DAS API
   */
  private async fetchTokenSymbolFromAPI(mintAddress: string): Promise<string> {
    try {
      const response = await this.httpClient.post('/', {
        jsonrpc: '2.0',
        id: 1,
        method: 'getAsset',
        params: {
          id: mintAddress,
          displayOptions: {
            showFungible: true
          }
        }
      });

      if (response?.result?.content?.metadata?.symbol) {
        // Store metadata for potential scam detection
        const metadata = response.result.content.metadata;
        this.storeTokenMetadata(mintAddress, metadata);
        return response.result.content.metadata.symbol;
      }

      if (response?.result?.content?.metadata?.name) {
        // Use name if symbol not available
        const metadata = response.result.content.metadata;
        this.storeTokenMetadata(mintAddress, metadata);
        return response.result.content.metadata.name;
      }

      throw new Error('No symbol or name found in metadata');
    } catch (error) {
      throw new Error(`API lookup failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Store token metadata for scam detection
   */
  private tokenMetadataCache = new Map<string, any>();

  private storeTokenMetadata(mintAddress: string, metadata: any): void {
    this.tokenMetadataCache.set(mintAddress, {
      symbol: metadata.symbol || '',
      name: metadata.name || '',
      description: metadata.description,
      image: metadata.image,
      external_url: metadata.external_url,
      attributes: metadata.attributes
    });
  }

}===== ./src/blockchains/solana/utils.ts =====
import { Decimal } from 'decimal.js';

/**
 * Solana address validation
 */
export function isValidSolanaAddress(address: string): boolean {
  // Solana addresses are base58 encoded and typically 32-44 characters
  const base58Regex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
  return base58Regex.test(address);
}

/**
 * Convert lamports to SOL
 */
export function lamportsToSol(lamports: number | string): Decimal {
  return new Decimal(lamports).dividedBy(new Decimal(10).pow(9));
}

/**
 * Convert SOL to lamports
 */
export function solToLamports(sol: number | string): Decimal {
  return new Decimal(sol).mul(new Decimal(10).pow(9));
}===== ./src/blockchains/solana/types.ts =====
import { Decimal } from 'decimal.js';

/**
 * Solana transaction from Solscan API
 */
export interface SolscanTransaction {
  txHash: string;
  blockTime: number;
  slot: number;
  fee: number;
  status: 'Success' | 'Fail';
  lamport: number;
  signer: string[];
  logMessage: string[];
  inputAccount: Array<{
    account: string;
    signer: boolean;
    writable: boolean;
    preBalance: number;
    postBalance: number;
  }>;
  recentBlockhash: string;
  parsedInstruction: Array<{
    program: string;
    programId: string;
    type: string;
    params?: any;
  }>;
}

/**
 * Solana account balance from Solscan API
 */
export interface SolscanBalance {
  account: string;
  lamports: number;
  ownerProgram: string;
  type: string;
  rentEpoch: number;
  executable: boolean;
}

/**
 * Solana RPC transaction response
 */
export interface SolanaRPCTransaction {
  slot: number;
  transaction: {
    message: {
      accountKeys: string[];
      header: {
        numReadonlySignedAccounts: number;
        numReadonlyUnsignedAccounts: number;
        numRequiredSignatures: number;
      };
      instructions: Array<{
        accounts: number[];
        data: string;
        programIdIndex: number;
      }>;
      recentBlockhash: string;
    };
    signatures: string[];
  };
  meta: {
    err: any;
    fee: number;
    innerInstructions: any[];
    logMessages: string[];
    postBalances: number[];
    postTokenBalances: any[];
    preBalances: number[];
    preTokenBalances: any[];
    rewards: any[];
    status: { Ok: null } | { Err: any };
  };
  blockTime: number;
}

/**
 * Parse Solana transaction type from instructions
 */
export function parseSolanaTransactionType(
  instructions: any[],
  userAddress: string,
  preBalances: number[],
  postBalances: number[],
  accountKeys: string[]
): 'transfer_in' | 'transfer_out' | 'swap' | 'stake' | 'unstake' | 'other' {
  // Find user's account index
  const userIndex = accountKeys.findIndex(key => key === userAddress);
  if (userIndex === -1) return 'other';

  const preBalance = preBalances[userIndex] || 0;
  const postBalance = postBalances[userIndex] || 0;
  const balanceChange = postBalance - preBalance;

  // Check for system program transfers (most common)
  const hasSystemTransfer = instructions.some(ix =>
    ix.program === 'system' || ix.programId === '11111111111111111111111111111112'
  );

  if (hasSystemTransfer) {
    // Positive balance change = receiving SOL
    // Negative balance change = sending SOL
    return balanceChange > 0 ? 'transfer_in' : 'transfer_out';
  }

  // Check for token program instructions
  const hasTokenProgram = instructions.some(ix =>
    ix.program === 'spl-token' || ix.programId === 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
  );

  if (hasTokenProgram) {
    return 'swap'; // Most token operations are swaps/trades
  }

  // Check for staking programs
  const hasStakeProgram = instructions.some(ix =>
    ix.program === 'stake' || ix.programId === 'Stake11111111111111111111111111111111111111'
  );

  if (hasStakeProgram) {
    return balanceChange < 0 ? 'stake' : 'unstake';
  }

  return 'other';
}

/**
 * Solana transaction processing result
 */
export interface ProcessedSolanaTransaction {
  hash: string;
  slot: number;
  blockTime: number;
  fee: number;
  status: 'success' | 'failed';
  type: 'transfer_in' | 'transfer_out' | 'swap' | 'stake' | 'unstake' | 'other';
  amount: Decimal;
  from?: string;
  to?: string;
  program: string;
  instructions: Array<{
    program: string;
    type: string;
    data?: any;
  }>;
}===== ./src/blockchains/solana/adapter.ts =====


import type { BlockchainBalance, BlockchainInfo, BlockchainTransaction } from '@crypto/core';


import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';
import { isValidSolanaAddress } from './utils.ts';

export class SolanaAdapter extends BaseBlockchainAdapter {
  private providerManager: BlockchainProviderManager;

  constructor(explorerConfig: BlockchainExplorersConfig) {
    super('solana', 'SolanaAdapter');

    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('solana', 'mainnet');

    this.logger.info(`Initialized Solana adapter with registry-based provider manager - ProvidersCount: ${this.providerManager.getProviders('solana').length}`);
  }

  async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    this.logger.info(`SolanaAdapter: Fetching transactions for address: ${address.substring(0, 20)}...`);
    this.logger.debug(`SolanaAdapter.getAddressTransactions called - Address: ${address}, Since: ${since}`);

    try {
      // Fetch regular SOL transactions
      const regularTxs = await this.providerManager.executeWithFailover('solana', {
        type: 'getAddressTransactions',
        params: { address, since },
        getCacheKey: (params: any) => `solana_tx_${params.address}_${params.since || 'all'}`
      }) as BlockchainTransaction[];

      // Try to fetch SPL token transactions (if provider supports it)
      let tokenTxs: BlockchainTransaction[] = [];
      try {
        tokenTxs = await this.providerManager.executeWithFailover('solana', {
          type: 'getTokenTransactions',
          params: { address, since },
          getCacheKey: (params: any) => `solana_token_tx_${params.address}_${params.since || 'all'}`
        }) as BlockchainTransaction[];
      } catch (error) {
        this.logger.debug(`Provider does not support token transactions or failed to fetch - Error: ${error instanceof Error ? error.message : String(error)}`);
        // Continue without token transactions if provider doesn't support them
      }

      this.logger.info(`SolanaAdapter transaction breakdown for ${address.substring(0, 20)}... - Regular: ${regularTxs.length}, Token: ${tokenTxs.length}, Total: ${regularTxs.length + tokenTxs.length}`);

      // Combine all transactions (following Ethereum pattern)
      const allTransactions = [...regularTxs, ...tokenTxs];

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      // Remove any duplicate transactions (by hash)
      const uniqueTransactions = allTransactions.reduce((acc, tx) => {
        if (!acc.find(existing => existing.hash === tx.hash)) {
          acc.push(tx);
        }
        return acc;
      }, [] as BlockchainTransaction[]);

      this.logger.info(`SolanaAdapter: Found ${uniqueTransactions.length} unique transactions for address ${address.substring(0, 20)}...`);
      return uniqueTransactions;

    } catch (error) {
      this.logger.error(`Failed to fetch transactions for ${address} - Error: ${error}`);
      throw error;
    }
  }

  async getAddressBalance(address: string): Promise<BlockchainBalance[]> {
    this.logger.info(`Getting balance for address: ${address.substring(0, 20)}...`);

    try {
      // Use provider manager to fetch balance with failover
      const balances = await this.providerManager.executeWithFailover('solana', {
        type: 'getAddressBalance',
        params: { address },
        getCacheKey: (params: any) => `solana_balance_${params.address}`
      }) as BlockchainBalance[];

      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch balance for ${address} - Error: ${error}`);
      throw error;
    }
  }

  validateAddress(address: string): boolean {
    // Solana addresses are Base58 encoded, 32 bytes (44 characters)
    return isValidSolanaAddress(address);
  }

  async testConnection(): Promise<boolean> {
    this.logger.debug('SolanaAdapter.testConnection called');
    try {
      const providers = this.providerManager.getProviders('solana');
      this.logger.debug(`Found ${providers.length} providers`);
      if (providers.length === 0) {
        this.logger.warn('No providers available for connection test');
        return false;
      }

      // Test the first provider
      const result = await providers[0]?.testConnection() || false;
      this.logger.debug(`Connection test result: ${result}`);
      return result;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error}`);
      return false;
    }
  }

  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: 'solana',
      name: 'Solana',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: true, // Solana supports SPL tokens
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  // Solana supports SPL token transactions
  async getTokenTransactions(address: string, tokenContract?: string): Promise<BlockchainTransaction[]> {
    this.logger.debug(`SolanaAdapter.getTokenTransactions called - Address: ${address}, TokenContract: ${tokenContract}`);

    try {
      // Use provider manager to fetch token transactions with failover
      const transactions = await this.providerManager.executeWithFailover('solana', {
        type: 'getTokenTransactions',
        params: { address, contractAddress: tokenContract },
        getCacheKey: (params: any) => `solana_token_tx_${params.address}_${params.contractAddress || 'all'}`
      }) as BlockchainTransaction[];

      this.logger.info(`SolanaAdapter: Found ${transactions.length} token transactions for address ${address.substring(0, 20)}...`);
      return transactions;

    } catch (error) {
      this.logger.error(`Failed to fetch token transactions for ${address} - Error: ${error}`);
      throw error;
    }
  }

  async getTokenBalances(address: string): Promise<BlockchainBalance[]> {
    this.logger.debug(`SolanaAdapter.getTokenBalances called - Address: ${address}`);

    try {
      // Use provider manager to fetch token balances with failover
      const balances = await this.providerManager.executeWithFailover('solana', {
        type: 'getTokenBalances',
        params: { address },
        getCacheKey: (params: any) => `solana_token_balance_${params.address}`
      }) as BlockchainBalance[];

      this.logger.info(`SolanaAdapter: Found ${balances.length} token balances for address ${address.substring(0, 20)}...`);
      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch token balances for ${address} - Error: ${error}`);
      throw error;
    }
  }

  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info('Solana adapter closed successfully');
    } catch (error) {
      this.logger.warn(`Error during Solana adapter close - Error: ${error}`);
    }
  }
}===== ./src/blockchains/shared/types.ts =====
import type { RateLimitConfig, DataSourceCapabilities } from '@crypto/core';

export interface IBlockchainProvider<TConfig = any> {
  readonly name: string;
  readonly blockchain: string;
  readonly capabilities: ProviderCapabilities;
  readonly rateLimit: RateLimitConfig;

  // Health and connectivity
  isHealthy(): Promise<boolean>;
  testConnection(): Promise<boolean>;

  // Universal execution method - all operations go through this
  execute<T>(operation: ProviderOperation<T>, config: TConfig): Promise<T>;
}

export interface ProviderOperation<T> {
  type: 'getAddressTransactions' | 'getAddressBalance' | 'getTokenTransactions' | 'getTokenBalances' | 'getRawAddressTransactions' | 'getAddressInfo' | 'parseWalletTransaction' | 'testConnection' | 'custom';
  params: Record<string, any>;
  transform?: (response: any) => T;
  getCacheKey?: (params: Record<string, any>) => string; // For request-scoped caching
}

// Provider-specific operation types for capabilities
export type ProviderOperationType = 
  | 'getAddressTransactions' 
  | 'getAddressBalance' 
  | 'getTokenTransactions' 
  | 'getTokenBalances' 
  | 'getRawAddressTransactions' 
  | 'getAddressInfo' 
  | 'parseWalletTransaction';

export interface ProviderCapabilities extends DataSourceCapabilities<ProviderOperationType> {
  /** Whether the provider supports real-time data access */
  supportsRealTimeData: boolean;
  
  /** Whether the provider supports token-specific operations */
  supportsTokenData: boolean;
}

export interface ProviderHealth {
  isHealthy: boolean;
  lastChecked: number;
  consecutiveFailures: number;
  averageResponseTime: number;
  errorRate: number;
  lastError?: string;
  rateLimitEvents: number;           // Total rate limit events encountered
  rateLimitRate: number;             // Percentage of requests that were rate limited (0-1)
  lastRateLimitTime?: number;        // Timestamp of last rate limit event
}===== ./src/blockchains/shared/registry/decorators.ts =====

import type { IBlockchainProvider } from '../types.ts';
import { ProviderRegistry, type ProviderFactory, type ProviderMetadata } from './provider-registry.ts';


/**
 * Decorator to register a provider class with the registry
 */
export function RegisterProvider(metadata: ProviderMetadata) {
  return function <TConfig, T extends new (...args: any[]) => IBlockchainProvider<TConfig>>(
    constructor: T
  ): T {
    // Create factory that instantiates the provider class
    const factory: ProviderFactory<TConfig> = {
      metadata,
      create: (config: TConfig) => new constructor(config)
    };

    // Register the factory
    ProviderRegistry.register(factory);

    return constructor;
  };
}===== ./src/blockchains/shared/registry/base-registry-provider.ts =====

import type { RateLimitConfig } from '@crypto/core';
import type { Logger } from '@crypto/shared-logger';
import { getLogger } from '@crypto/shared-logger';
import { HttpClient } from '@crypto/shared-utils';
import type { IBlockchainProvider, ProviderCapabilities, ProviderOperation } from '../types.ts';
import { ProviderRegistry, type ProviderMetadata } from './provider-registry.ts';

/**
 * Abstract base class for registry-based providers
 * Handles all common provider functionality using registry metadata
 */
export abstract class BaseRegistryProvider implements IBlockchainProvider {
  protected readonly metadata: ProviderMetadata;
  protected readonly httpClient: HttpClient;
  protected readonly logger: Logger;
  protected readonly apiKey: string;
  protected readonly baseUrl: string;
  protected readonly network: string;

  constructor(blockchain: string, providerName: string, network: string = 'mainnet') {
    // Get metadata from registry
    const metadata = ProviderRegistry.getMetadata(blockchain, providerName);
    if (!metadata) {
      throw new Error(`Provider '${providerName}' not found in registry for blockchain '${blockchain}'`);
    }
    this.metadata = metadata;

    this.logger = getLogger(`${this.metadata.displayName.replace(/\s+/g, '')}`);
    this.network = network;

    // Get base URL for the specified network
    this.baseUrl = this.getNetworkBaseUrl(network);

    // Get API key from environment if required
    this.apiKey = this.getApiKey();

    // Initialize HTTP client with registry metadata
    this.httpClient = new HttpClient({
      baseUrl: this.baseUrl,
      timeout: this.metadata.defaultConfig.timeout,
      retries: this.metadata.defaultConfig.retries,
      rateLimit: this.metadata.defaultConfig.rateLimit,
      providerName: this.metadata.name
    });

    this.logger.debug(`Initialized ${this.metadata.displayName} - Network: ${this.network}, BaseUrl: ${this.baseUrl}, HasApiKey: ${this.apiKey !== 'YourApiKeyToken'}`);
  }

  // Provider interface properties from metadata
  get name(): string {
    return this.metadata.name;
  }

  get blockchain(): string {
    return this.metadata.blockchain;
  }

  get capabilities(): ProviderCapabilities {
    return this.metadata.capabilities;
  }

  get rateLimit(): RateLimitConfig {
    return this.metadata.defaultConfig.rateLimit;
  }

  // Common provider methods
  async testConnection(): Promise<boolean> {
    return this.isHealthy();
  }

  // Abstract methods that must be implemented by concrete providers
  abstract isHealthy(): Promise<boolean>;
  abstract execute<T>(operation: ProviderOperation<T>): Promise<T>;

  // Helper methods
  private getNetworkBaseUrl(network: string): string {
    const networks = this.metadata.networks as any;
    const networkConfig = networks[network];

    if (!networkConfig?.baseUrl) {
      const availableNetworks = Object.keys(this.metadata.networks);
      throw new Error(
        `Network '${network}' not supported by ${this.metadata.displayName}. ` +
        `Available networks: ${availableNetworks.join(', ')}`
      );
    }

    return networkConfig.baseUrl;
  }

  private getApiKey(): string {
    if (!this.metadata.requiresApiKey) {
      return '';
    }

    const envVar = this.metadata.apiKeyEnvVar || `${this.metadata.name.toUpperCase()}_API_KEY`;
    const apiKey = process.env[envVar];

    if (!apiKey || apiKey === 'YourApiKeyToken') {
      this.logger.warn(
        `No API key found for ${this.metadata.displayName}. ` +
        `Set environment variable: ${envVar}`
      );
      return 'YourApiKeyToken';
    }

    return apiKey;
  }

  // Common validation helper
  protected validateApiKey(): void {
    if (this.metadata.requiresApiKey && this.apiKey === 'YourApiKeyToken') {
      const envVar = this.metadata.apiKeyEnvVar || `${this.metadata.name.toUpperCase()}_API_KEY`;
      throw new Error(
        `Valid API key required for ${this.metadata.displayName}. ` +
        `Set environment variable: ${envVar}`
      );
    }
  }

  /**
   * Reinitialize HTTP client with custom configuration
   * Useful for providers that need special URL formatting or headers
   */
  protected reinitializeHttpClient(config: {
    baseUrl?: string;
    timeout?: number;
    retries?: number;
    rateLimit?: RateLimitConfig;
    providerName?: string;
    defaultHeaders?: Record<string, string>;
  }): void {
    const clientConfig = {
      baseUrl: config.baseUrl || this.baseUrl,
      timeout: config.timeout || this.metadata.defaultConfig.timeout,
      retries: config.retries || this.metadata.defaultConfig.retries,
      rateLimit: config.rateLimit || this.metadata.defaultConfig.rateLimit,
      providerName: config.providerName || this.metadata.name,
      ...(config.defaultHeaders && { defaultHeaders: config.defaultHeaders })
    };

    (this as any).httpClient = new HttpClient(clientConfig);
  }
}===== ./src/blockchains/shared/registry/index.ts =====
export * from './base-registry-provider.ts';
export * from './decorators.ts';
export * from './provider-registry.ts';
===== ./src/blockchains/shared/registry/provider-registry.ts =====
import type { RateLimitConfig } from '@crypto/core';
import type { IBlockchainProvider, ProviderCapabilities } from '../types.ts';

/**
 * Network configuration for a provider
 */
export interface NetworkEndpoint {
  baseUrl: string;
  websocketUrl?: string;
}

/**
 * Provider metadata that's embedded in the provider class
 */
export interface ProviderMetadata {
  name: string;
  blockchain: string;
  displayName: string;
  description?: string;
  requiresApiKey?: boolean;
  apiKeyEnvVar?: string; // Environment variable name for API key
  type?: 'rest' | 'rpc' | 'websocket';
  capabilities: ProviderCapabilities;
  defaultConfig: {
    timeout: number;
    retries: number;
    rateLimit: RateLimitConfig;
  };
  networks: {
    mainnet: NetworkEndpoint;
    testnet?: NetworkEndpoint;
    devnet?: NetworkEndpoint;
  };
}

/**
 * Factory function to create provider instances
 */
export type ProviderFactory<TConfig = any> = {
  metadata: ProviderMetadata;
  create: (config: TConfig) => IBlockchainProvider<TConfig>;
};

/**
 * Information about an available provider
 */
export interface ProviderInfo {
  name: string;
  blockchain: string;
  displayName: string;
  description?: string;
  requiresApiKey: boolean;
  type: string;
  capabilities: ProviderCapabilities;
  defaultConfig: ProviderMetadata['defaultConfig'];
  supportedNetworks: string[];
}

/**
 * Central registry for blockchain providers
 */
export class ProviderRegistry {
  private static providers = new Map<string, ProviderFactory>();

  /**
   * Register a provider with the registry
   */
  static register<TConfig>(factory: ProviderFactory<TConfig>): void {
    const key = `${factory.metadata.blockchain}:${factory.metadata.name}`;

    if (this.providers.has(key)) {
      throw new Error(`Provider ${key} is already registered`);
    }

    this.providers.set(key, factory);
  }

  /**
   * Get all available providers for a blockchain
   */
  static getAvailable(blockchain: string): ProviderInfo[] {
    return Array.from(this.providers.entries())
      .filter(([key]) => key.startsWith(`${blockchain}:`))
      .map(([_, factory]) => {
        // Create a temporary instance to get capabilities
        const tempInstance = factory.create({});

        return {
          name: factory.metadata.name,
          blockchain: factory.metadata.blockchain,
          displayName: factory.metadata.displayName,
          description: factory.metadata.description || '',
          requiresApiKey: factory.metadata.requiresApiKey || false,
          type: factory.metadata.type || 'rest',
          capabilities: tempInstance.capabilities,
          defaultConfig: factory.metadata.defaultConfig,
          supportedNetworks: Object.keys(factory.metadata.networks)
        };
      });
  }

  /**
   * Get all registered providers
   */
  static getAllProviders(): ProviderInfo[] {
    const blockchains = new Set(
      Array.from(this.providers.keys()).map(key => key.split(':')[0])
    );

    return Array.from(blockchains)
      .filter(blockchain => blockchain !== undefined)
      .flatMap(blockchain => this.getAvailable(blockchain!));
  }

  /**
   * Create a provider instance
   */
  static createProvider<TConfig>(
    blockchain: string,
    name: string,
    config: TConfig
  ): IBlockchainProvider<TConfig> {
    const key = `${blockchain}:${name}`;
    const factory = this.providers.get(key);

    if (!factory) {
      const available = this.getAvailable(blockchain).map(p => p.name);
      throw new Error(
        `Provider ${name} not found for blockchain ${blockchain}. ` +
        `Available providers: ${available.join(', ')}`
      );
    }

    return factory.create(config);
  }

  /**
   * Check if a provider is registered
   */
  static isRegistered(blockchain: string, name: string): boolean {
    return this.providers.has(`${blockchain}:${name}`);
  }

  /**
   * Get provider metadata
   */
  static getMetadata(blockchain: string, name: string): ProviderMetadata | null {
    const key = `${blockchain}:${name}`;
    const factory = this.providers.get(key);
    return factory?.metadata || null;
  }

  /**
   * Validate provider configuration against registered providers
   */
  static validateConfig(config: any): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    for (const [blockchain, blockchainConfig] of Object.entries(config)) {
      if (!blockchainConfig || typeof blockchainConfig !== 'object') {
        continue;
      }

      const { explorers = [] } = blockchainConfig as any;
      const availableProviders = this.getAvailable(blockchain);
      const availableNames = availableProviders.map(p => p.name);

      for (const explorer of explorers) {
        if (!explorer.name) {
          errors.push(`Missing name for explorer in blockchain ${blockchain}`);
          continue;
        }

        if (!availableNames.includes(explorer.name)) {
          errors.push(
            `Unknown provider '${explorer.name}' for blockchain '${blockchain}'. ` +
            `Available: ${availableNames.join(', ')}`
          );
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}===== ./src/blockchains/shared/blockchain-provider-manager.ts =====
import type { ProviderHealth } from './types.ts';
import { getLogger } from '@crypto/shared-logger';

import type { BlockchainExplorersConfig } from './explorer-config.ts';

import { CircuitBreaker } from '../../utils/circuit-breaker.ts';
import { ProviderRegistry } from './registry/provider-registry.ts';
import type { IBlockchainProvider, ProviderCapabilities, ProviderOperation } from './types.ts';


const logger = getLogger('BlockchainProviderManager');

interface CacheEntry {
  result: any;
  expiry: number;
}

export class BlockchainProviderManager {
  private providers = new Map<string, IBlockchainProvider[]>();
  private healthStatus = new Map<string, ProviderHealth>();
  private circuitBreakers = new Map<string, CircuitBreaker>();
  private requestCache = new Map<string, CacheEntry>();
  private rateLimiters = new Map<string, { lastRequest: number; tokens: number }>(); // Simple token bucket
  private readonly cacheTimeout = 30000; // 30 seconds
  private readonly healthCheckInterval = 60000; // 1 minute
  private healthCheckTimer?: NodeJS.Timeout;
  private cacheCleanupTimer?: NodeJS.Timeout;

  constructor(private readonly explorerConfig: BlockchainExplorersConfig) {
    // Start periodic health checks
    this.healthCheckTimer = setInterval(() => this.performHealthChecks(), this.healthCheckInterval);

    // Start cache cleanup
    this.cacheCleanupTimer = setInterval(() => this.cleanupCache(), this.cacheTimeout);
  }

  /**
   * Cleanup resources and stop background tasks
   */
  destroy(): void {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = undefined;
    }

    if (this.cacheCleanupTimer) {
      clearInterval(this.cacheCleanupTimer);
      this.cacheCleanupTimer = undefined;
    }

    // Clear all caches and state
    this.providers.clear();
    this.healthStatus.clear();
    this.circuitBreakers.clear();
    this.requestCache.clear();
    this.rateLimiters.clear();
  }

  /**
   * Register providers for a specific blockchain
   */
  registerProviders(blockchain: string, providers: IBlockchainProvider[]): void {
    this.providers.set(blockchain, providers);

    // Initialize health status and circuit breakers for each provider
    for (const provider of providers) {
      this.healthStatus.set(provider.name, {
        isHealthy: true,
        lastChecked: 0,
        consecutiveFailures: 0,
        averageResponseTime: 0,
        errorRate: 0,
        rateLimitEvents: 0,
        rateLimitRate: 0,
        lastRateLimitTime: undefined
      });

      this.circuitBreakers.set(provider.name, new CircuitBreaker(provider.name));

      // Initialize rate limiter
      this.rateLimiters.set(provider.name, {
        lastRequest: 0,
        tokens: provider.rateLimit.burstLimit || 1
      });
    }
  }

  /**
   * Auto-register providers from configuration using the registry
   */
  autoRegisterFromConfig(blockchain: string, network: string = 'mainnet'): IBlockchainProvider[] {
    try {
      const config = this.explorerConfig;
      const blockchainConfig = config[blockchain];

      if (!blockchainConfig) {
        logger.warn(`No configuration found for blockchain: ${blockchain}`);
        return [];
      }

      const enabledExplorers = blockchainConfig.explorers
        .filter(explorer => explorer.enabled)
        .sort((a, b) => a.priority - b.priority);

      const providers: IBlockchainProvider[] = [];

      for (const explorerConfig of enabledExplorers) {
        try {
          // Check if provider is registered in the registry
          if (!ProviderRegistry.isRegistered(blockchain, explorerConfig.name)) {
            logger.warn(`Provider ${explorerConfig.name} not found in registry for ${blockchain}. Skipping.`);
            continue;
          }

          // Get provider metadata from registry
          const metadata = ProviderRegistry.getMetadata(blockchain, explorerConfig.name);
          if (!metadata) {
            logger.warn(`No metadata found for provider ${explorerConfig.name}. Skipping.`);
            continue;
          }

          // Build provider config by merging defaults with overrides
          const networkEndpoints = explorerConfig as any; // Explorer config has dynamic network properties
          const metadataNetworks = metadata.networks as any; // Metadata networks has dynamic properties

          const providerConfig = {
            ...metadata.defaultConfig,
            ...explorerConfig,
            // Set the base URL from the network configuration
            baseUrl: networkEndpoints[network]?.baseUrl || metadataNetworks[network]?.baseUrl,
            network
          };

          // Create provider instance from registry
          const provider = ProviderRegistry.createProvider(blockchain, explorerConfig.name, providerConfig);
          providers.push(provider);

          logger.debug(`Successfully created provider ${explorerConfig.name} for ${blockchain} - Priority: ${explorerConfig.priority}, BaseUrl: ${providerConfig.baseUrl}, RequiresApiKey: ${metadata.requiresApiKey}`);

        } catch (error) {
          logger.error(`Failed to create provider ${explorerConfig.name} for ${blockchain} - Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      // Register the providers with this manager
      if (providers.length > 0) {
        this.registerProviders(blockchain, providers);
        logger.debug(`Auto-registered ${providers.length} providers for ${blockchain}: ${providers.map(p => p.name).join(', ')}`);
      }

      return providers;

    } catch (error) {
      logger.error(`Failed to auto-register providers for ${blockchain} - Error: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  /**
   * Execute operation with intelligent failover and caching
   */
  async executeWithFailover<T>(
    blockchain: string,
    operation: ProviderOperation<T>
  ): Promise<T> {
    // Check cache first
    if (operation.getCacheKey) {
      const cacheKey = operation.getCacheKey(operation.params);
      const cached = this.requestCache.get(cacheKey);
      if (cached && cached.expiry > Date.now()) {
        return cached.result;
      }
    }

    // Execute with failover logic
    const result = await this.executeWithCircuitBreaker(blockchain, operation);

    // Cache result if cacheable
    if (operation.getCacheKey) {
      const cacheKey = operation.getCacheKey(operation.params);
      this.requestCache.set(cacheKey, {
        result,
        expiry: Date.now() + this.cacheTimeout
      });
    }

    return result;
  }

  /**
   * Execute with circuit breaker protection and automatic failover
   */
  private async executeWithCircuitBreaker<T>(
    blockchain: string,
    operation: ProviderOperation<T>
  ): Promise<T> {
    const providers = this.getProvidersInOrder(blockchain, operation);

    if (providers.length === 0) {
      throw new Error(`No providers available for ${blockchain} operation: ${operation.type}`);
    }

    let lastError: Error | null = null;
    let attemptNumber = 0;

    for (const provider of providers) {
      attemptNumber++;
      const circuitBreaker = this.getOrCreateCircuitBreaker(provider.name);

      // Log provider attempt with reason
      if (attemptNumber === 1) {
        logger.debug(`Using provider ${provider.name} for ${operation.type}`);
      } else {
        logger.info(`Switching to provider ${provider.name} for ${operation.type} - Reason: ${attemptNumber === 2 ? 'primary_failed' : 'multiple_failures'}, AttemptNumber: ${attemptNumber}, PreviousError: ${lastError?.message}`);
      }

      // Skip providers with open circuit breakers (unless all are open)
      if (circuitBreaker.isOpen() && this.hasAvailableProviders(providers)) {
        logger.debug(`Skipping provider ${provider.name} - circuit breaker is open`);
        continue;
      }

      // Log when using a provider with open circuit breaker (all providers are failing)
      if (circuitBreaker.isOpen()) {
        logger.warn(`Using provider ${provider.name} despite open circuit breaker - all providers unavailable`);
      } else if (circuitBreaker.isHalfOpen()) {
        logger.debug(`Testing provider ${provider.name} in half-open state`);
      }

      // Enforce rate limiting before execution
      const rateLimitDelay = await this.enforceRateLimit(provider);
      if (rateLimitDelay > 0) {
        // Track rate limit event
        this.recordRateLimitEvent(provider.name, rateLimitDelay);

        if (rateLimitDelay > 500) { // Only log significant delays
          logger.debug(`Rate limited ${provider.name} for ${Math.round(rateLimitDelay)}ms before ${operation.type}`);
        }
      }

      const startTime = Date.now();
      try {
        const result = await provider.execute(operation, {});
        const responseTime = Date.now() - startTime;

        // Record success
        circuitBreaker.recordSuccess();
        this.updateHealthMetrics(provider.name, true, responseTime);

        return result;
      } catch (error) {
        lastError = error as Error;
        const responseTime = Date.now() - startTime;

        // Log error without sensitive params details
        const logData: any = {
          error: error instanceof Error ? error.message : String(error),
          provider: provider.name,
          operation: operation.type,
          attemptNumber,
          willRetry: attemptNumber < providers.length
        };
        // Only log params for non-sensitive operations
        if (!operation.params?.address) {
          logData.params = operation.params;
        }

        if (attemptNumber < providers.length) {
          logger.warn(`Provider ${provider.name} failed, trying next provider: ${logData.error}`);
        } else {
          logger.error(`All providers failed for ${operation.type}: ${logData.error}`);
        }

        // Record failure
        circuitBreaker.recordFailure();
        this.updateHealthMetrics(provider.name, false, responseTime, lastError.message);

        // Continue to next provider
        continue;
      }
    }

    // All providers failed
    throw new Error(
      `All providers failed for ${blockchain} operation: ${operation.type}. Last error: ${lastError?.message}`
    );
  }

  /**
   * Get providers ordered by preference for the given operation
   */
  private getProvidersInOrder(
    blockchain: string,
    operation: ProviderOperation<any>
  ): IBlockchainProvider[] {
    const candidates = this.providers.get(blockchain) || [];

    // Filter by capability and health, then sort by score
    const scoredProviders = candidates
      .filter(p => this.supportsOperation(p.capabilities, operation.type))
      .map(p => ({
        provider: p,
        score: this.scoreProvider(p),
        health: this.healthStatus.get(p.name)!
      }))
      .sort((a, b) => b.score - a.score); // Higher score = better

    // Log provider selection details
    if (scoredProviders.length > 1) {
      logger.debug(`Provider selection for ${operation.type} - Providers: ${JSON.stringify(scoredProviders.map(item => ({
          name: item.provider.name,
          score: item.score,
          isHealthy: item.health.isHealthy,
          errorRate: Math.round(item.health.errorRate * 100),
          consecutiveFailures: item.health.consecutiveFailures,
          avgResponseTime: Math.round(item.health.averageResponseTime),
          rateLimitPerSec: item.provider.rateLimit.requestsPerSecond,
          rateLimitEvents: item.health.rateLimitEvents,
          rateLimitRate: Math.round(item.health.rateLimitRate * 100)
        })))}`);
    }

    return scoredProviders.map(item => item.provider);
  }

  /**
   * Check if provider supports the requested operation
   */
  private supportsOperation(
    capabilities: ProviderCapabilities,
    operationType: string
  ): boolean {
    return capabilities.supportedOperations.includes(operationType as any);
  }

  /**
   * Score a provider based on health, performance, and availability
   */
  private scoreProvider(provider: IBlockchainProvider): number {
    const health = this.healthStatus.get(provider.name);
    const circuitBreaker = this.circuitBreakers.get(provider.name);

    if (!health || !circuitBreaker) {
      return 0;
    }

    let score = 100; // Base score

    // Health penalties
    if (!health.isHealthy) score -= 50;
    if (circuitBreaker.isOpen()) score -= 100; // Severe penalty for open circuit
    if (circuitBreaker.isHalfOpen()) score -= 25; // Moderate penalty for half-open

    // Rate limit penalties - both configured limits and actual rate limiting events
    const rateLimit = provider.rateLimit.requestsPerSecond;
    if (rateLimit <= 0.5) score -= 40; // Very restrictive (like mempool.space 0.25/sec)
    else if (rateLimit <= 1.0) score -= 20; // Moderately restrictive
    else if (rateLimit >= 3.0) score += 10; // Generous rate limits get bonus

    // Dynamic rate limit penalties based on actual events
    const rateLimitPercentage = health.rateLimitRate * 100;
    if (rateLimitPercentage > 50) score -= 60; // Very frequently rate limited (>50% of requests)
    else if (rateLimitPercentage > 25) score -= 40; // Frequently rate limited (>25% of requests)
    else if (rateLimitPercentage > 10) score -= 20; // Occasionally rate limited (>10% of requests)
    else if (rateLimitPercentage < 1) score += 5; // Rarely rate limited bonus

    // Performance bonuses/penalties
    if (health.averageResponseTime < 1000) score += 20; // Fast response bonus
    if (health.averageResponseTime > 5000) score -= 30; // Slow response penalty

    // Error rate penalties
    score -= health.errorRate * 50; // Up to 50 point penalty for 100% error rate

    // Consecutive failure penalties
    score -= health.consecutiveFailures * 10;

    return Math.max(0, score); // Never go below 0
  }

  /**
   * Get or create circuit breaker for provider
   */
  private getOrCreateCircuitBreaker(providerName: string): CircuitBreaker {
    let circuitBreaker = this.circuitBreakers.get(providerName);
    if (!circuitBreaker) {
      circuitBreaker = new CircuitBreaker(providerName);
      this.circuitBreakers.set(providerName, circuitBreaker);
    }
    return circuitBreaker;
  }

  /**
   * Check if there are available providers (circuit not open)
   */
  private hasAvailableProviders(providers: IBlockchainProvider[]): boolean {
    return providers.some(p => {
      const circuitBreaker = this.circuitBreakers.get(p.name);
      return !circuitBreaker || !circuitBreaker.isOpen();
    });
  }

  /**
   * Record a rate limit event for scoring purposes
   */
  private recordRateLimitEvent(providerName: string, delayMs: number): void {
    const health = this.healthStatus.get(providerName);
    if (!health) return;

    health.rateLimitEvents++;
    health.lastRateLimitTime = Date.now();

    // Update rate limit rate (exponential moving average)
    // Each request either was rate limited (1) or not (0)
    const rateLimitWeight = 1; // This request was rate limited
    health.rateLimitRate = health.rateLimitRate * 0.9 + rateLimitWeight * 0.1;

    logger.debug(`Recorded rate limit event for ${providerName} - TotalEvents: ${health.rateLimitEvents}, RateLimitRate: ${Math.round(health.rateLimitRate * 100)}%, DelayMs: ${delayMs}`);
  }

  /**
   * Update health metrics for a provider
   */
  private updateHealthMetrics(
    providerName: string,
    success: boolean,
    responseTime: number,
    errorMessage?: string
  ): void {
    const health = this.healthStatus.get(providerName);
    if (!health) return;

    const now = Date.now();

    // Update basic metrics
    health.lastChecked = now;
    health.isHealthy = success;

    // Update response time (exponential moving average)
    if (success) {
      health.averageResponseTime = health.averageResponseTime === 0
        ? responseTime
        : (health.averageResponseTime * 0.8 + responseTime * 0.2);
    }

    // Update failure tracking
    if (success) {
      health.consecutiveFailures = 0;
    } else {
      health.consecutiveFailures++;
      health.lastError = errorMessage;
    }

    // Update error rate (simplified - could use sliding window)
    const errorWeight = success ? 0 : 1;
    health.errorRate = health.errorRate * 0.9 + errorWeight * 0.1;

    // Update rate limit rate for successful requests (they weren't rate limited)
    if (success) {
      const rateLimitWeight = 0; // This request was not rate limited
      health.rateLimitRate = health.rateLimitRate * 0.9 + rateLimitWeight * 0.1;
    }
  }

  /**
   * Perform periodic health checks on all providers
   */
  private async performHealthChecks(): Promise<void> {
    for (const [, providers] of this.providers.entries()) {
      for (const provider of providers) {
        try {
          const startTime = Date.now();
          const isHealthy = await provider.isHealthy();
          const responseTime = Date.now() - startTime;

          this.updateHealthMetrics(provider.name, isHealthy, responseTime);
        } catch (error) {
          this.updateHealthMetrics(
            provider.name,
            false,
            0,
            error instanceof Error ? error.message : 'Health check failed'
          );
        }
      }
    }
  }

  /**
   * Clean up expired cache entries
   */
  private cleanupCache(): void {
    const now = Date.now();
    for (const [key, entry] of this.requestCache.entries()) {
      if (entry.expiry <= now) {
        this.requestCache.delete(key);
      }
    }
  }

  /**
   * Get provider health status for monitoring
   */
  getProviderHealth(blockchain?: string): Map<string, ProviderHealth & { circuitState: string }> {
    const result = new Map<string, ProviderHealth & { circuitState: string }>();

    const providersToCheck = blockchain
      ? this.providers.get(blockchain) || []
      : Array.from(this.providers.values()).flat();

    for (const provider of providersToCheck) {
      const health = this.healthStatus.get(provider.name);
      const circuitBreaker = this.circuitBreakers.get(provider.name);

      if (health && circuitBreaker) {
        result.set(provider.name, {
          ...health,
          circuitState: circuitBreaker.getCurrentState()
        });
      }
    }

    return result;
  }

  /**
   * Reset circuit breaker for a specific provider
   */
  resetCircuitBreaker(providerName: string): void {
    const circuitBreaker = this.circuitBreakers.get(providerName);
    if (circuitBreaker) {
      circuitBreaker.reset();
    }
  }

  /**
   * Get registered providers for a blockchain
   */
  getProviders(blockchain: string): IBlockchainProvider[] {
    return this.providers.get(blockchain) || [];
  }

  /**
   * Enforce rate limiting using token bucket algorithm
   * @returns The delay time in milliseconds if rate limited
   */
  private async enforceRateLimit(provider: IBlockchainProvider): Promise<number> {
    const rateLimiter = this.rateLimiters.get(provider.name);
    if (!rateLimiter) {
      return 0; // No rate limiting data
    }

    const now = Date.now();
    const { requestsPerSecond, burstLimit } = provider.rateLimit;
    const maxTokens = burstLimit || 1;
    const refillRate = requestsPerSecond; // tokens per second

    // Calculate how many tokens to add based on time elapsed
    const timeSinceLastRequest = (now - rateLimiter.lastRequest) / 1000; // in seconds
    const tokensToAdd = timeSinceLastRequest * refillRate;

    // Update token count (don't exceed max)
    rateLimiter.tokens = Math.min(maxTokens, rateLimiter.tokens + tokensToAdd);
    rateLimiter.lastRequest = now;

    // If we don't have enough tokens, wait
    if (rateLimiter.tokens < 1) {
      const waitTime = (1 - rateLimiter.tokens) / refillRate * 1000; // convert to ms
      await this.delay(waitTime);

      // After waiting, we should have at least 1 token
      rateLimiter.tokens = 1;
      rateLimiter.lastRequest = Date.now();

      // Consume one token
      rateLimiter.tokens -= 1;
      return waitTime;
    }

    // Consume one token
    rateLimiter.tokens -= 1;
    return 0;
  }

  /**
   * Simple delay helper
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}===== ./src/blockchains/shared/index.ts =====
export * from './base-blockchain-adapter.ts';
export * from './blockchain-adapter-factory.ts';
export * from './blockchain-provider-manager.ts';
export * from './registry/index.ts';

===== ./src/blockchains/shared/base-blockchain-adapter.ts =====
import type {
  BlockchainBalance,
  BlockchainInfo,
  BlockchainTransaction,
  CryptoTransaction,
  IBlockchainAdapter,
  RateLimitConfig,
  TransactionType
} from '@crypto/core';
import { Database } from '@crypto/data';

import { getLogger, type Logger } from '@crypto/shared-logger';



export abstract class BaseBlockchainAdapter implements IBlockchainAdapter {
  protected logger: Logger;
  protected blockchain: string;
  protected network: any; // Each blockchain has different network types
  protected rateLimitConfig: RateLimitConfig;
  protected lastRequestTime: number = 0;
  protected requestCount: { [key: string]: number } = {};
  protected database?: Database;

  constructor(blockchain: string, loggerName: string) {
    this.blockchain = blockchain;
    this.network = 'mainnet'; // Default to mainnet string, adapters can override
    this.logger = getLogger(loggerName);
    this.rateLimitConfig = {
      requestsPerSecond: 5,
      requestsPerMinute: 100,
      requestsPerHour: 1000
    };
  }

  // Abstract methods that must be implemented by specific blockchain adapters
  abstract getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]>;
  abstract getAddressBalance(address: string): Promise<BlockchainBalance[]>;
  abstract validateAddress(address: string): boolean;
  abstract testConnection(): Promise<boolean>;
  abstract getBlockchainInfo(): Promise<BlockchainInfo>;

  // Optional token methods - subclasses can override if they support tokens
  getTokenTransactions?(address: string, tokenContract?: string): Promise<BlockchainTransaction[]>;
  getTokenBalances?(address: string): Promise<BlockchainBalance[]>;

  /**
   * Convert blockchain transaction to standard crypto transaction format
   * Now accepts userAddress to determine transaction direction
   */
  convertToCryptoTransaction(blockchainTx: BlockchainTransaction, userAddress: string): CryptoTransaction {
    // Determine transaction type based on user's address
    let type: TransactionType;
    const normalizedUserAddress = userAddress.toLowerCase();
    const isIncoming = blockchainTx.to.toLowerCase() === normalizedUserAddress;
    const isOutgoing = blockchainTx.from.toLowerCase() === normalizedUserAddress;

    if (isIncoming && !isOutgoing) {
      type = 'deposit';
    } else if (isOutgoing && !isIncoming) {
      type = 'withdrawal';
    } else {
      // This shouldn't happen with proper filtering, but default to transfer
      type = 'transfer';
    }

    return {
      id: blockchainTx.hash,
      type,
      timestamp: blockchainTx.timestamp,
      datetime: new Date(blockchainTx.timestamp).toISOString(),
      symbol: blockchainTx.tokenSymbol || blockchainTx.value.currency,
      side: undefined,
      amount: blockchainTx.value,
      price: undefined,
      fee: blockchainTx.fee,
      status: blockchainTx.status === 'success' ? 'closed' :
        blockchainTx.status === 'pending' ? 'open' : 'canceled',
      info: {
        blockNumber: blockchainTx.blockNumber,
        blockHash: blockchainTx.blockHash,
        from: blockchainTx.from,
        to: blockchainTx.to,
        gasUsed: blockchainTx.gasUsed,
        gasPrice: blockchainTx.gasPrice,
        nonce: blockchainTx.nonce,
        confirmations: blockchainTx.confirmations,
        tokenContract: blockchainTx.tokenContract,
        transactionType: blockchainTx.type,
        originalTransaction: blockchainTx
      }
    };
  }

  async close(): Promise<void> {
    // Base implementation - adapters can override for cleanup
    this.logger.debug('Base blockchain adapter closed');
  }
}===== ./src/blockchains/shared/blockchain-adapter-factory.ts =====
import type { IBlockchainAdapter } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import { AvalancheAdapter } from '../avalanche/adapter.ts';
import { BitcoinAdapter } from '../bitcoin/adapter.ts';
import { EthereumAdapter } from '../ethereum/adapter.ts';
import { InjectiveAdapter } from '../injective/adapter.ts';
import { SubstrateAdapter } from '../polkadot/adapter.ts';
import { SolanaAdapter } from '../solana/adapter.ts';
import type { BlockchainExplorersConfig } from './explorer-config.ts';

/**
 * Specialized factory for creating blockchain adapters
 */
export class BlockchainAdapterFactory {
  private logger = getLogger('BlockchainAdapterFactory');

  /**
   * Create a blockchain adapter based on configuration
   */
  async createBlockchainAdapter(
    blockchain: string,
    explorerConfig: BlockchainExplorersConfig
  ): Promise<IBlockchainAdapter> {
    this.logger.info(`Creating blockchain adapter for ${blockchain}`);

    switch (blockchain.toLowerCase()) {
      case 'bitcoin':
        return new BitcoinAdapter(explorerConfig);

      case 'ethereum':
        return new EthereumAdapter(explorerConfig);

      case 'injective':
        return new InjectiveAdapter(explorerConfig);

      case 'avalanche':
        return new AvalancheAdapter(explorerConfig);

      case 'bittensor':
      case 'polkadot':
      case 'kusama':
        return new SubstrateAdapter(explorerConfig);

      case 'solana':
        return new SolanaAdapter(explorerConfig);

      default:
        throw new Error(`Unsupported blockchain: ${blockchain}`);
    }
  }
}===== ./src/blockchains/shared/explorer-config.ts =====
import fs from 'fs';
import path from 'path';

interface ExplorerConfig {
  name: string;
  enabled: boolean;
  priority: number;
  requiresApiKey?: boolean;
  mainnet: {
    baseUrl: string;
  };
  testnet: {
    baseUrl: string;
  };
  rateLimit: {
    requestsPerSecond: number;
  };
  timeout: number;
  retries: number;
}

export interface BlockchainExplorersConfig {
  [blockchain: string]: {
    explorers: ExplorerConfig[];
  };
}

/**
 * Load blockchain explorer configuration from JSON
 */
export function loadExplorerConfig(): BlockchainExplorersConfig {
  // Get config path from environment variable or use default
  const configPath = process.env.BLOCKCHAIN_EXPLORERS_CONFIG 
    ? path.resolve(process.cwd(), process.env.BLOCKCHAIN_EXPLORERS_CONFIG)
    : path.join(process.cwd(), 'config/blockchain-explorers.json');
  
  try {
    const configData = fs.readFileSync(configPath, 'utf-8');
    return JSON.parse(configData);
  } catch (error) {
    throw new Error(`Failed to load blockchain explorer configuration from ${configPath}: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Get enabled explorers for a blockchain and network
 */
export function getEnabledExplorers(blockchain: string): ExplorerConfig[] {
  const config = loadExplorerConfig();
  const blockchainConfig = config[blockchain];
  
  if (!blockchainConfig) {
    throw new Error(`No explorer configuration found for blockchain: ${blockchain}`);
  }
  
  return blockchainConfig.explorers
    .filter(explorer => explorer.enabled)
    .sort((a, b) => a.priority - b.priority); // Sort by priority (lower number = higher priority)
}

/**
 * Get explorer configuration for a specific explorer
 */
export function getExplorerConfig(blockchain: string, explorerName: string): ExplorerConfig | null {
  const config = loadExplorerConfig();
  const blockchainConfig = config[blockchain];
  
  if (!blockchainConfig) {
    return null;
  }
  
  return blockchainConfig.explorers.find(explorer => explorer.name === explorerName) || null;
}===== ./src/blockchains/bitcoin/providers/BlockCypherProvider.ts =====
import { Decimal } from 'decimal.js';

import type { BlockchainTransaction } from '@crypto/core';
import { createMoney, maskAddress } from '@crypto/shared-utils';

import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { AddressInfo } from '../types.ts';


interface BlockCypherTransaction {
  hash: string;
  block_height: number;
  block_hash: string;
  block_index: number;
  received: string; // ISO 8601 date
  confirmed: string; // ISO 8601 date
  confirmations: number;
  double_spend: boolean;
  inputs: Array<{
    prev_hash: string;
    output_index: number;
    output_value: number;
    sequence: number;
    addresses: string[];
    script_type: string;
    age: number;
  }>;
  outputs: Array<{
    value: number;
    script: string;
    addresses: string[];
    script_type: string;
  }>;
  fees: number;
  size: number;
  vsize: number;
  preference: string;
  relayed_by: string;
  confidence: number;
  ver: number;
  lock_time: number;
  gas_limit?: number;
  gas_used?: number;
  gas_price?: number;
}

interface BlockCypherAddress {
  address: string;
  total_received: number;
  total_sent: number;
  balance: number;
  unconfirmed_balance: number;
  final_balance: number;
  n_tx: number;
  unconfirmed_n_tx: number;
  final_n_tx: number;
  txrefs?: Array<{
    tx_hash: string;
    block_height: number;
    tx_input_n: number;
    tx_output_n: number;
    value: number;
    ref_balance: number;
    spent: boolean;
    confirmations: number;
    confirmed: string;
    double_spend: boolean;
  }>;
  hasMore?: boolean;
  error?: string;
}

@RegisterProvider({
  name: 'blockcypher',
  blockchain: 'bitcoin',
  displayName: 'BlockCypher API',
  type: 'rest',
  requiresApiKey: true,
  apiKeyEnvVar: 'BLOCKCYPHER_API_KEY',
  description: 'Bitcoin blockchain API with high-performance transaction data and balance queries (requires API key for full functionality)',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getAddressInfo', 'parseWalletTransaction'],
    maxBatchSize: 50,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: false
  },
  networks: {
    mainnet: {
      baseUrl: 'https://api.blockcypher.com/v1/btc/main'
    },
    testnet: {
      baseUrl: 'https://api.blockcypher.com/v1/btc/test3'
    }
  },
  defaultConfig: {
    timeout: 15000, // Longer timeout for BlockCypher
    retries: 3,
    rateLimit: {
      requestsPerSecond: 3.0, // API key dependent - 3 req/sec for free tier
      requestsPerMinute: 180,
      requestsPerHour: 10800,
      burstLimit: 5
    }
  }
})
export class BlockCypherProvider extends BaseRegistryProvider {

  constructor() {
    super('bitcoin', 'blockcypher', 'mainnet');

    this.logger.debug(`Initialized BlockCypherProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}, HasApiKey: ${this.apiKey !== 'YourApiKeyToken'}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.get('/');
      return response && typeof response === 'object' && 'name' in response;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      // Test with a simple endpoint that should always work
      const chainInfo = await this.httpClient.get('/');
      this.logger.debug(`Connection test successful - ChainInfo: ${chainInfo.name}`);
      return chainInfo && typeof chainInfo === 'object' && 'name' in chainInfo;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getAddressInfo':
          return this.getAddressInfo(operation.params as { address: string }) as T;
        case 'parseWalletTransaction':
          return this.parseWalletTransaction(operation.params as { tx: any; walletAddresses: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}`);

    try {
      // Get address info with transaction references
      const addressInfo = await this.httpClient.get<BlockCypherAddress>(this.buildEndpoint(`/addrs/${address}?limit=50`));

      if (!addressInfo.txrefs || addressInfo.txrefs.length === 0) {
        this.logger.debug(`No transactions found for address - Address: ${maskAddress(address)}`);
        return [];
      }

      this.logger.debug(`Retrieved transaction references - Address: ${maskAddress(address)}, Count: ${addressInfo.txrefs.length}`);

      // Extract unique transaction hashes
      const uniqueTxHashes = Array.from(new Set(addressInfo.txrefs.map((ref: any) => ref.tx_hash)));

      // Fetch detailed transaction data
      const transactions: BlockchainTransaction[] = [];

      // Process transactions in batches to respect rate limits
      const batchSize = this.capabilities.maxBatchSize!;
      for (let i = 0; i < uniqueTxHashes.length; i += batchSize) {
        const batch = uniqueTxHashes.slice(i, i + batchSize);

        const batchTransactions = await Promise.all(
          batch.map(async (txHash) => {
            try {
              const tx = await this.httpClient.get<BlockCypherTransaction>(this.buildEndpoint(`/txs/${txHash}`));
              return this.transformTransaction(tx, address);
            } catch (error) {
              this.logger.warn(`Failed to fetch transaction details - Error: ${error instanceof Error ? error.message : String(error)}`);
              return null;
            }
          })
        );

        transactions.push(...batchTransactions.filter((tx): tx is BlockchainTransaction => tx !== null));

        // Rate limiting between batches
        if (i + batchSize < uniqueTxHashes.length) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay between batches
        }
      }

      // Filter by timestamp if 'since' is provided
      let filteredTransactions = transactions;
      if (since) {
        filteredTransactions = transactions.filter(tx => tx.timestamp >= since);
        this.logger.debug(`Filtered transactions by timestamp - OriginalCount: ${transactions.length}, FilteredCount: ${filteredTransactions.length}`);
      }

      // Sort by timestamp (newest first)
      filteredTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${filteredTransactions.length}`);

      return filteredTransactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<{ balance: string; token: string }> {
    const { address } = params;

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<BlockCypherAddress>(this.buildEndpoint(`/addrs/${address}/balance`));

      // BlockCypher returns balance in satoshis
      const balanceSats = addressInfo.final_balance;

      // Convert satoshis to BTC
      const balanceBTC = (balanceSats / 100000000).toString();

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, UnconfirmedBalance: ${addressInfo.unconfirmed_balance}`);

      return {
        balance: balanceBTC,
        token: 'BTC'
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Get lightweight address info for efficient gap scanning
   */
  private async getAddressInfo(params: { address: string }): Promise<AddressInfo> {
    const { address } = params;

    this.logger.debug(`Fetching lightweight address info - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<BlockCypherAddress>(this.buildEndpoint(`/addrs/${address}/balance`));

      // Get transaction count (final_n_tx includes confirmed transactions)
      const txCount = addressInfo.final_n_tx;

      // Get balance in BTC (BlockCypher returns in satoshis)
      const balanceBTC = (addressInfo.final_balance / 100000000).toString();

      this.logger.debug(`Successfully retrieved lightweight address info - Address: ${maskAddress(address)}`);

      return {
        txCount,
        balance: balanceBTC
      };

    } catch (error) {
      this.logger.error(`Failed to get address info - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private transformTransaction(tx: BlockCypherTransaction, userAddress?: string): BlockchainTransaction {
    // Calculate transaction value and determine type
    let valueAmount = new Decimal(0);
    let type: BlockchainTransaction['type'] = 'transfer_in';

    if (userAddress) {
      let inputValue = 0;
      let outputValue = 0;

      // Check inputs for user address
      for (const input of tx.inputs) {
        if (input.addresses.includes(userAddress)) {
          inputValue += input.output_value;
        }
      }

      // Check outputs for user address
      for (const output of tx.outputs) {
        if (output.addresses.includes(userAddress)) {
          outputValue += output.value;
        }
      }

      // Determine transaction type and value
      if (inputValue > 0 && outputValue === 0) {
        // Pure withdrawal: user sent money
        type = 'transfer_out';
        valueAmount = new Decimal(inputValue).div(100000000);
      } else if (inputValue === 0 && outputValue > 0) {
        // Pure deposit: user received money
        type = 'transfer_in';
        valueAmount = new Decimal(outputValue).div(100000000);
      } else if (inputValue > 0 && outputValue > 0) {
        // Mixed transaction: calculate net effect
        const netValue = outputValue - inputValue;
        if (netValue > 0) {
          type = 'transfer_in';
          valueAmount = new Decimal(netValue).div(100000000);
        } else {
          type = 'transfer_out';
          valueAmount = new Decimal(Math.abs(netValue)).div(100000000);
        }
      }
    } else {
      // Without user address context, just sum all outputs
      const totalValue = tx.outputs.reduce((sum, output) => sum + output.value, 0);
      valueAmount = new Decimal(totalValue).div(100000000);
    }

    // Extract addresses
    const fromAddresses = tx.inputs
      .flatMap(input => input.addresses)
      .filter((addr, index, array) => array.indexOf(addr) === index); // Remove duplicates
    const toAddresses = tx.outputs
      .flatMap(output => output.addresses)
      .filter((addr, index, array) => array.indexOf(addr) === index); // Remove duplicates

    // Convert ISO date to timestamp
    const timestamp = tx.confirmed ?
      Math.floor(new Date(tx.confirmed).getTime() / 1000) :
      Math.floor(Date.now() / 1000);

    return {
      hash: tx.hash,
      blockNumber: tx.block_height || 0,
      blockHash: tx.block_hash || '',
      timestamp,
      from: fromAddresses[0] || '',
      to: toAddresses[0] || '',
      value: { amount: valueAmount, currency: 'BTC' },
      fee: { amount: new Decimal(tx.fees).div(100000000), currency: 'BTC' },
      status: tx.confirmations > 0 ? 'success' : 'pending',
      type,
      confirmations: tx.confirmations
    };
  }


  private buildEndpoint(endpoint: string): string {
    if (this.apiKey) {
      const separator = endpoint.includes('?') ? '&' : '?';
      return `${endpoint}${separator}token=${this.apiKey}`;
    }
    return endpoint;
  }


  /**
   * Parse a BlockCypher transaction considering multiple wallet addresses (for xpub scenarios)
   */
  private parseWalletTransaction(params: { tx: any; walletAddresses: string[] }): BlockchainTransaction {
    const { tx, walletAddresses } = params;

    try {
      const timestamp = tx.confirmed ? new Date(tx.confirmed).getTime() : Date.now();

      // Calculate transaction value considering all wallet addresses
      let totalValueChange = 0;
      let isIncoming = false;
      let isOutgoing = false;
      const relevantAddresses = new Set(walletAddresses);

      // Check inputs - money going out of our wallet (BlockCypher format uses arrays)
      for (const input of tx.inputs) {
        if (input.addresses) {
          for (const address of input.addresses) {
            if (relevantAddresses.has(address)) {
              isOutgoing = true;
              if (input.output_value) {
                totalValueChange -= input.output_value;
              }
              break; // Found a match in this input
            }
          }
        }
      }

      // Check outputs - money coming into our wallet (BlockCypher format uses arrays)
      for (const output of tx.outputs) {
        if (output.addresses) {
          for (const address of output.addresses) {
            if (relevantAddresses.has(address)) {
              isIncoming = true;
              totalValueChange += output.value;
              break; // Found a match in this output
            }
          }
        }
      }

      // Determine transaction type
      let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';

      if (isIncoming && !isOutgoing) {
        type = 'transfer_in';
      } else if (isOutgoing && !isIncoming) {
        type = 'transfer_out';
      } else if (isIncoming && isOutgoing) {
        // Internal transfer within our wallet - treat based on net change
        type = totalValueChange >= 0 ? 'internal_transfer_in' : 'internal_transfer_out';
      } else {
        // Neither incoming nor outgoing (shouldn't happen with proper filtering)
        type = 'transfer_out';
      }

      const totalValue = Math.abs(totalValueChange);
      const fee = isOutgoing ? tx.fees : 0;

      // Determine from/to addresses (first relevant address found)
      let fromAddress = '';
      let toAddress = '';

      // For from address, look for wallet addresses in inputs
      for (const input of tx.inputs) {
        if (input.addresses) {
          for (const address of input.addresses) {
            if (relevantAddresses.has(address)) {
              fromAddress = address;
              break;
            }
          }
          if (fromAddress) break;
        }
      }

      // For to address, look for wallet addresses in outputs
      for (const output of tx.outputs) {
        if (output.addresses) {
          for (const address of output.addresses) {
            if (relevantAddresses.has(address)) {
              toAddress = address;
              break;
            }
          }
          if (toAddress) break;
        }
      }

      // Fallback to first addresses if no wallet addresses found
      if (!fromAddress && tx.inputs.length > 0 && tx.inputs[0]?.addresses?.length > 0) {
        fromAddress = tx.inputs[0].addresses[0];
      }

      if (!toAddress && tx.outputs.length > 0 && tx.outputs[0]?.addresses?.length > 0) {
        toAddress = tx.outputs[0].addresses[0];
      }

      return {
        hash: tx.hash,
        blockNumber: tx.block_height || 0,
        blockHash: tx.block_hash || '',
        timestamp,
        from: fromAddress,
        to: toAddress,
        value: createMoney(totalValue / 100000000, 'BTC'),
        fee: createMoney(fee / 100000000, 'BTC'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.confirmations > 0 ? 'success' : 'pending',
        type,
        tokenContract: undefined,
        tokenSymbol: 'BTC',
        nonce: undefined,
        confirmations: tx.confirmations || 0
      };
    } catch (error) {
      this.logger.error(`Failed to parse BlockCypher wallet transaction ${tx.hash} - Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}, TxData: ${JSON.stringify(tx)}`);
      throw error;
    }
  }


}===== ./src/blockchains/bitcoin/providers/BlockstreamProvider.ts =====
import { Decimal } from 'decimal.js';

import type { BlockchainTransaction } from '@crypto/core';
import { createMoney, maskAddress } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { AddressInfo, BlockstreamTransaction } from '../types.ts';

interface BlockstreamAddressInfo {
  address: string;
  chain_stats: {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
  };
  mempool_stats: {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
  };
}

@RegisterProvider({
  name: 'blockstream.info',
  blockchain: 'bitcoin',
  displayName: 'Blockstream.info API',
  type: 'rest',
  requiresApiKey: false,
  description: 'Bitcoin blockchain explorer API with comprehensive transaction data and pagination support (no API key required)',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getRawAddressTransactions', 'getAddressInfo', 'parseWalletTransaction'],
    maxBatchSize: 25,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: false
  },
  networks: {
    mainnet: {
      baseUrl: 'https://blockstream.info/api'
    },
    testnet: {
      baseUrl: 'https://blockstream.info/testnet/api'
    }
  },
  defaultConfig: {
    timeout: 10000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 1.0, // More generous than mempool.space
      requestsPerMinute: 60,
      requestsPerHour: 3600,
      burstLimit: 5
    }
  }
})
export class BlockstreamProvider extends BaseRegistryProvider {

  constructor() {
    super('bitcoin', 'blockstream.info', 'mainnet');

    this.logger.debug(`Initialized BlockstreamProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.get<number>('/blocks/tip/height');
      return typeof response === 'number' && response > 0;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      // Test with a simple endpoint that should always work
      const blockHeight = await this.httpClient.get<number>('/blocks/tip/height');
      this.logger.debug(`Connection test successful - CurrentBlockHeight: ${blockHeight}`);
      return typeof blockHeight === 'number' && blockHeight > 0;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getRawAddressTransactions':
          return this.getRawAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getAddressInfo':
          return this.getAddressInfo(operation.params as { address: string }) as T;
        case 'parseWalletTransaction':
          return this.parseWalletTransaction(operation.params as { tx: any; walletAddresses: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${JSON.stringify(operation.params)}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}, Since: ${since}`);

    try {
      // Get address info first to check if there are transactions
      const addressInfo = await this.httpClient.get<BlockstreamAddressInfo>(`/address/${address}`);

      if (addressInfo.chain_stats.tx_count === 0 && addressInfo.mempool_stats.tx_count === 0) {
        this.logger.debug(`No transactions found for address - Address: ${maskAddress(address)}`);
        return [];
      }

      // Get transaction list with pagination
      const allTransactions: BlockchainTransaction[] = [];
      let lastSeenTxid: string | undefined;
      let hasMore = true;
      let batchCount = 0;
      const maxBatches = 50; // Safety limit

      while (hasMore && batchCount < maxBatches) {
        const endpoint = lastSeenTxid
          ? `/address/${address}/txs/chain/${lastSeenTxid}`
          : `/address/${address}/txs`;

        const transactions = await this.httpClient.get<BlockstreamTransaction[]>(endpoint);

        if (!Array.isArray(transactions) || transactions.length === 0) {
          hasMore = false;
          break;
        }

        this.logger.debug(`Retrieved transaction batch - Address: ${maskAddress(address)}, BatchSize: ${transactions.length}, Batch: ${batchCount + 1}`);

        // Transform the transactions we already have
        const batchTransactions = transactions.map(tx => {
          try {
            return this.transformTransaction(tx, address);
          } catch (error) {
            this.logger.warn(`Failed to transform transaction - Txid: ${tx.txid}, Error: ${error instanceof Error ? error.message : String(error)}`);
            return null;
          }
        });

        const validTransactions = batchTransactions.filter((tx): tx is BlockchainTransaction => tx !== null);
        allTransactions.push(...validTransactions);

        // Update pagination
        lastSeenTxid = transactions.length > 0 ? transactions[transactions.length - 1]?.txid : undefined;
        hasMore = transactions.length === 25; // Blockstream typically returns 25 per page
        batchCount++;

        // Rate limiting is handled by HttpClient automatically
      }

      // Filter by timestamp if 'since' is provided
      let filteredTransactions = allTransactions;
      if (since) {
        filteredTransactions = allTransactions.filter(tx => tx.timestamp >= since);
        this.logger.debug(`Filtered transactions by timestamp - OriginalCount: ${allTransactions.length}, FilteredCount: ${filteredTransactions.length}, Since: ${since}`);
      }

      // Sort by timestamp (newest first)
      filteredTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${filteredTransactions.length}, BatchesProcessed: ${batchCount}`);

      return filteredTransactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<{ balance: string; token: string }> {
    const { address } = params;

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<BlockstreamAddressInfo>(`/address/${address}`);

      // Calculate current balance: funded amount - spent amount
      const chainBalance = addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
      const mempoolBalance = addressInfo.mempool_stats.funded_txo_sum - addressInfo.mempool_stats.spent_txo_sum;
      const totalBalanceSats = chainBalance + mempoolBalance;

      // Convert satoshis to BTC
      const balanceBTC = (totalBalanceSats / 100000000).toString();

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceBTC: ${balanceBTC}, BalanceSats: ${totalBalanceSats}`);

      return {
        balance: balanceBTC,
        token: 'BTC'
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Get lightweight address info for efficient gap scanning
   */
  private async getAddressInfo(params: { address: string }): Promise<AddressInfo> {
    const { address } = params;

    this.logger.debug(`Fetching lightweight address info - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<BlockstreamAddressInfo>(`/address/${address}`);

      // Calculate transaction count
      const txCount = addressInfo.chain_stats.tx_count + addressInfo.mempool_stats.tx_count;

      // Calculate current balance: funded amount - spent amount
      const chainBalance = addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
      const mempoolBalance = addressInfo.mempool_stats.funded_txo_sum - addressInfo.mempool_stats.spent_txo_sum;
      const totalBalanceSats = chainBalance + mempoolBalance;

      // Convert satoshis to BTC
      const balanceBTC = (totalBalanceSats / 100000000).toString();

      this.logger.debug(`Successfully retrieved lightweight address info - Address: ${maskAddress(address)}, TxCount: ${txCount}, BalanceBTC: ${balanceBTC}`);

      return {
        txCount,
        balance: balanceBTC
      };

    } catch (error) {
      this.logger.error(`Failed to get address info - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Get raw transaction data without transformation for wallet-aware parsing
   */
  private async getRawAddressTransactions(params: { address: string; since?: number }): Promise<BlockstreamTransaction[]> {
    const { address, since } = params;

    this.logger.debug(`Fetching raw address transactions - Address: ${maskAddress(address)}, Since: ${since}`);

    try {
      // Get address info first to check if there are transactions
      const addressInfo = await this.httpClient.get<BlockstreamAddressInfo>(`/address/${address}`);

      if (addressInfo.chain_stats.tx_count === 0 && addressInfo.mempool_stats.tx_count === 0) {
        this.logger.debug(`No raw transactions found for address - Address: ${maskAddress(address)}`);
        return [];
      }

      // Get transaction list with pagination - return raw transactions directly
      const allRawTransactions: BlockstreamTransaction[] = [];
      let lastSeenTxid: string | undefined;
      let hasMore = true;
      let batchCount = 0;
      const maxBatches = 50; // Safety limit

      while (hasMore && batchCount < maxBatches) {
        const endpoint = lastSeenTxid
          ? `/address/${address}/txs/chain/${lastSeenTxid}`
          : `/address/${address}/txs`;

        const rawTransactions = await this.httpClient.get<BlockstreamTransaction[]>(endpoint);

        if (!Array.isArray(rawTransactions) || rawTransactions.length === 0) {
          hasMore = false;
          break;
        }

        this.logger.debug(`Retrieved raw transaction batch - Address: ${maskAddress(address)}, BatchSize: ${rawTransactions.length}, Batch: ${batchCount + 1}`);

        // We already have the raw transaction data - no need to fetch again
        const validRawTransactions = rawTransactions.filter((tx): tx is BlockstreamTransaction => tx !== null);
        allRawTransactions.push(...validRawTransactions);

        // Update pagination
        lastSeenTxid = rawTransactions.length > 0 ? rawTransactions[rawTransactions.length - 1]?.txid : undefined;
        hasMore = rawTransactions.length === 25; // Blockstream typically returns 25 per page
        batchCount++;
      }

      // Filter by timestamp if 'since' is provided
      let filteredRawTransactions = allRawTransactions;
      if (since) {
        filteredRawTransactions = allRawTransactions.filter(tx =>
          (tx.status.block_time || Math.floor(Date.now() / 1000)) >= since
        );
        this.logger.debug(`Filtered raw transactions by timestamp - OriginalCount: ${allRawTransactions.length}, FilteredCount: ${filteredRawTransactions.length}, Since: ${since}`);
      }

      // Sort by timestamp (newest first)
      filteredRawTransactions.sort((a, b) => {
        const aTime = a.status.block_time || 0;
        const bTime = b.status.block_time || 0;
        return bTime - aTime;
      });

      this.logger.debug(`Successfully retrieved raw address transactions - Address: ${maskAddress(address)}, TotalRawTransactions: ${filteredRawTransactions.length}, BatchesProcessed: ${batchCount}`);

      return filteredRawTransactions;

    } catch (error) {
      this.logger.error(`Failed to get raw address transactions - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private transformTransaction(tx: BlockstreamTransaction, userAddress?: string): BlockchainTransaction {
    // Calculate transaction value and determine type
    let valueAmount = new Decimal(0);
    let type: BlockchainTransaction['type'] = 'transfer_in';

    if (userAddress) {
      let inputValue = 0;
      let outputValue = 0;

      // Check inputs for user address
      for (const input of tx.vin) {
        if (input.prevout.scriptpubkey_address === userAddress) {
          inputValue += input.prevout.value;
        }
      }

      // Check outputs for user address
      for (const output of tx.vout) {
        if (output.scriptpubkey_address === userAddress) {
          outputValue += output.value;
        }
      }

      // Determine transaction type and value
      if (inputValue > 0 && outputValue === 0) {
        // Pure withdrawal: user sent money
        type = 'transfer_out';
        valueAmount = new Decimal(inputValue).div(100000000);
      } else if (inputValue === 0 && outputValue > 0) {
        // Pure deposit: user received money
        type = 'transfer_in';
        valueAmount = new Decimal(outputValue).div(100000000);
      } else if (inputValue > 0 && outputValue > 0) {
        // Mixed transaction: calculate net effect
        const netValue = outputValue - inputValue;
        if (netValue > 0) {
          type = 'transfer_in';
          valueAmount = new Decimal(netValue).div(100000000);
        } else {
          type = 'transfer_out';
          valueAmount = new Decimal(Math.abs(netValue)).div(100000000);
        }
      }
    } else {
      // Without user address context, just sum all outputs
      const totalValue = tx.vout.reduce((sum, output) => sum + output.value, 0);
      valueAmount = new Decimal(totalValue).div(100000000);
    }

    // Extract addresses
    const fromAddresses = tx.vin
      .map(input => input.prevout.scriptpubkey_address)
      .filter((addr): addr is string => addr !== undefined);
    const toAddresses = tx.vout
      .map(output => output.scriptpubkey_address)
      .filter((addr): addr is string => addr !== undefined);

    return {
      hash: tx.txid,
      blockNumber: tx.status.block_height || 0,
      blockHash: tx.status.block_hash || '',
      timestamp: tx.status.block_time || Math.floor(Date.now() / 1000),
      from: fromAddresses[0] || '',
      to: toAddresses[0] || '',
      value: { amount: valueAmount, currency: 'BTC' },
      fee: { amount: new Decimal(tx.fee).div(100000000), currency: 'BTC' },
      status: tx.status.confirmed ? 'success' : 'pending',
      type
    };
  }


  /**
   * Parse a Blockstream transaction considering multiple wallet addresses (for xpub scenarios)
   */
  private parseWalletTransaction(params: { tx: any; walletAddresses: string[] }): BlockchainTransaction {
    const { tx, walletAddresses } = params;

    try {
      const timestamp = tx.status.confirmed && tx.status.block_time
        ? tx.status.block_time * 1000
        : Date.now();

      // Calculate transaction value considering all wallet addresses
      let totalValueChange = 0;
      let isIncoming = false;
      let isOutgoing = false;
      const relevantAddresses = new Set(walletAddresses);

      // Check inputs - money going out of our wallet (Blockstream format)
      for (const input of tx.vin) {
        if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
          isOutgoing = true;
          if (input.prevout?.value) {
            totalValueChange -= input.prevout.value;
          }
        }
      }

      // Check outputs - money coming into our wallet (Blockstream format)
      for (const output of tx.vout) {
        if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
          isIncoming = true;
          totalValueChange += output.value;
        }
      }

      // Determine transaction type
      let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';

      if (isIncoming && !isOutgoing) {
        type = 'transfer_in';
      } else if (isOutgoing && !isIncoming) {
        type = 'transfer_out';
      } else if (isIncoming && isOutgoing) {
        // Internal transfer within our wallet - treat based on net change
        type = totalValueChange >= 0 ? 'internal_transfer_in' : 'internal_transfer_out';
      } else {
        // Neither incoming nor outgoing (shouldn't happen with proper filtering)
        type = 'transfer_out';
      }

      const totalValue = Math.abs(totalValueChange);
      const fee = isOutgoing ? tx.fee : 0;

      // Determine from/to addresses (first relevant address found)
      let fromAddress = '';
      let toAddress = '';

      // For from address, look for wallet addresses in inputs
      for (const input of tx.vin) {
        if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
          fromAddress = input.prevout.scriptpubkey_address;
          break;
        }
      }

      // For to address, look for wallet addresses in outputs
      for (const output of tx.vout) {
        if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
          toAddress = output.scriptpubkey_address;
          break;
        }
      }

      // Fallback to first addresses if no wallet addresses found
      if (!fromAddress && tx.vin.length > 0 && tx.vin[0]?.prevout?.scriptpubkey_address) {
        fromAddress = tx.vin[0].prevout.scriptpubkey_address;
      }

      if (!toAddress && tx.vout.length > 0 && tx.vout[0]?.scriptpubkey_address) {
        toAddress = tx.vout[0].scriptpubkey_address;
      }

      return {
        hash: tx.txid,
        blockNumber: tx.status.block_height || 0,
        blockHash: tx.status.block_hash || '',
        timestamp,
        from: fromAddress,
        to: toAddress,
        value: createMoney(totalValue / 100000000, 'BTC'),
        fee: createMoney(fee / 100000000, 'BTC'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.status.confirmed ? 'success' : 'pending',
        type,
        tokenContract: undefined,
        tokenSymbol: 'BTC',
        nonce: undefined,
        confirmations: tx.status.confirmed ? 1 : 0
      };
    } catch (error) {
      this.logger.error(`Failed to parse Blockstream wallet transaction ${tx.txid} - Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}, TxData: ${JSON.stringify(tx, null, 2)}`);
      throw error;
    }
  }


}===== ./src/blockchains/bitcoin/providers/MempoolSpaceProvider.ts =====
import { Decimal } from 'decimal.js';

import type { BlockchainTransaction } from '@crypto/core';
import { createMoney, maskAddress } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { AddressInfo, MempoolAddressInfo, MempoolTransaction } from '../types.ts';

@RegisterProvider({
  name: 'mempool.space',
  blockchain: 'bitcoin',
  displayName: 'Mempool.space API',
  type: 'rest',
  requiresApiKey: false,
  description: 'Bitcoin blockchain explorer API with comprehensive transaction and balance data (no API key required)',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getRawAddressTransactions', 'getAddressInfo', 'parseWalletTransaction'],
    maxBatchSize: 25,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: false
  },
  networks: {
    mainnet: {
      baseUrl: 'https://mempool.space/api'
    },
    testnet: {
      baseUrl: 'https://mempool.space/testnet/api'
    }
  },
  defaultConfig: {
    timeout: 10000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 0.25, // Conservative: 1 request per 4 seconds
      requestsPerMinute: 15,
      requestsPerHour: 600,
      burstLimit: 1
    }
  }
})
export class MempoolSpaceProvider extends BaseRegistryProvider {

  constructor() {
    super('bitcoin', 'mempool.space', 'mainnet');

    this.logger.debug(`Initialized MempoolSpaceProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.httpClient.get<number>('/blocks/tip/height');
      return typeof response === 'number' && response > 0;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      // Test with a simple endpoint that should always work
      const blockHeight = await this.httpClient.get<number>('/blocks/tip/height');
      this.logger.debug(`Connection test successful - CurrentBlockHeight: ${blockHeight}`);
      return typeof blockHeight === 'number' && blockHeight > 0;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getRawAddressTransactions':
          return this.getRawAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getAddressInfo':
          return this.getAddressInfo(operation.params as { address: string }) as T;
        case 'parseWalletTransaction':
          return this.parseWalletTransaction(operation.params as { tx: any; walletAddresses: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}`);

    try {
      // Get transaction list directly - mempool.space returns full transaction objects, not just IDs
      // No need to check address info first as empty addresses will just return empty array
      const rawTransactions = await this.httpClient.get<MempoolTransaction[]>(`/address/${address}/txs`);

      if (!Array.isArray(rawTransactions) || rawTransactions.length === 0) {
        this.logger.debug(`No transactions found - Address: ${maskAddress(address)}`);
        return [];
      }

      this.logger.debug(`Retrieved transactions - Address: ${maskAddress(address)}, Count: ${rawTransactions.length}`);

      // Transform the transactions directly since we already have the full data
      const transactions: BlockchainTransaction[] = [];

      for (const tx of rawTransactions) {
        try {
          const blockchainTx = this.transformTransaction(tx, address);
          transactions.push(blockchainTx);
        } catch (error) {
          this.logger.warn(`Failed to transform transaction - Txid: ${tx.txid}, Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      // Filter by timestamp if 'since' is provided
      let filteredTransactions = transactions;
      if (since) {
        filteredTransactions = transactions.filter(tx => tx.timestamp >= since);
        this.logger.debug(`Filtered transactions by timestamp - OriginalCount: ${transactions.length}, FilteredCount: ${filteredTransactions.length}`);
      }

      // Sort by timestamp (newest first)
      filteredTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${filteredTransactions.length}`);

      return filteredTransactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Get raw transaction data without transformation for wallet-aware parsing
   */
  private async getRawAddressTransactions(params: { address: string; since?: number }): Promise<MempoolTransaction[]> {
    const { address, since } = params;

    this.logger.debug(`Fetching raw address transactions - Address: ${maskAddress(address)}`);

    try {
      // Get raw transaction list directly - mempool.space returns full transaction objects
      // No need to check address info first as empty addresses will just return empty array
      const rawTransactions = await this.httpClient.get<MempoolTransaction[]>(`/address/${address}/txs`);

      if (!Array.isArray(rawTransactions) || rawTransactions.length === 0) {
        this.logger.debug(`No raw transactions found - Address: ${maskAddress(address)}`);
        return [];
      }

      this.logger.debug(`Retrieved raw transactions - Address: ${maskAddress(address)}, Count: ${rawTransactions.length}`);

      // Filter by timestamp if 'since' is provided
      let filteredTransactions = rawTransactions;
      if (since) {
        filteredTransactions = rawTransactions.filter(tx => {
          const timestamp = tx.status.confirmed && tx.status.block_time
            ? tx.status.block_time * 1000
            : Date.now();
          return timestamp >= since;
        });

        this.logger.debug(`Filtered raw transactions by timestamp - OriginalCount: ${rawTransactions.length}, FilteredCount: ${filteredTransactions.length}`);
      }

      // Sort by timestamp (newest first)
      filteredTransactions.sort((a, b) => {
        const timestampA = a.status.confirmed && a.status.block_time ? a.status.block_time : 0;
        const timestampB = b.status.confirmed && b.status.block_time ? b.status.block_time : 0;
        return timestampB - timestampA;
      });

      this.logger.debug(`Successfully retrieved raw address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${filteredTransactions.length}`);

      return filteredTransactions;

    } catch (error) {
      this.logger.error(`Failed to get raw address transactions - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<{ balance: string; token: string }> {
    const { address } = params;

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<MempoolAddressInfo>(`/address/${address}`);

      // Calculate current balance: funded amount - spent amount
      const chainBalance = addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
      const mempoolBalance = addressInfo.mempool_stats.funded_txo_sum - addressInfo.mempool_stats.spent_txo_sum;
      const totalBalanceSats = chainBalance + mempoolBalance;

      // Convert satoshis to BTC
      const balanceBTC = (totalBalanceSats / 100000000).toString();

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceSats: ${totalBalanceSats}`);

      return {
        balance: balanceBTC,
        token: 'BTC'
      };

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Parse a mempool transaction considering multiple wallet addresses (for xpub scenarios)
   */
  private parseWalletTransaction(params: { tx: any; walletAddresses: string[] }): BlockchainTransaction {
    const { tx, walletAddresses } = params;

    try {
      const timestamp = tx.status.confirmed && tx.status.block_time
        ? tx.status.block_time * 1000
        : Date.now();

      // Calculate transaction value considering all wallet addresses
      let totalValueChange = 0;
      let isIncoming = false;
      let isOutgoing = false;
      const relevantAddresses = new Set(walletAddresses);

      // Check inputs - money going out of our wallet
      for (const input of tx.vin) {
        if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
          isOutgoing = true;
          if (input.prevout?.value) {
            totalValueChange -= input.prevout.value;
          }
        }
      }

      // Check outputs - money coming into our wallet
      for (const output of tx.vout) {
        if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
          isIncoming = true;
          totalValueChange += output.value;
        }
      }

      // Determine transaction type
      let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';

      if (isIncoming && !isOutgoing) {
        type = 'transfer_in';
      } else if (isOutgoing && !isIncoming) {
        type = 'transfer_out';
      } else if (isIncoming && isOutgoing) {
        // Internal transfer within our wallet - treat based on net change
        type = totalValueChange >= 0 ? 'internal_transfer_in' : 'internal_transfer_out';
      } else {
        // Neither incoming nor outgoing (shouldn't happen with proper filtering)
        type = 'transfer_out';
      }

      const totalValue = Math.abs(totalValueChange);
      const fee = isOutgoing ? tx.fee : 0;

      // Determine from/to addresses (first relevant address found)
      let fromAddress = '';
      let toAddress = '';

      // For from address, look for wallet addresses in inputs
      for (const input of tx.vin) {
        if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
          fromAddress = input.prevout.scriptpubkey_address;
          break;
        }
      }

      // For to address, look for wallet addresses in outputs
      for (const output of tx.vout) {
        if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
          toAddress = output.scriptpubkey_address;
          break;
        }
      }

      // Fallback to first addresses if no wallet addresses found
      if (!fromAddress && tx.vin.length > 0 && tx.vin[0]?.prevout?.scriptpubkey_address) {
        fromAddress = tx.vin[0].prevout.scriptpubkey_address;
      }

      if (!toAddress && tx.vout.length > 0 && tx.vout[0]?.scriptpubkey_address) {
        toAddress = tx.vout[0].scriptpubkey_address;
      }

      return {
        hash: tx.txid,
        blockNumber: tx.status.block_height || 0,
        blockHash: tx.status.block_hash || '',
        timestamp,
        from: fromAddress,
        to: toAddress,
        value: createMoney(totalValue / 100000000, 'BTC'),
        fee: createMoney(fee / 100000000, 'BTC'),
        gasUsed: undefined,
        gasPrice: undefined,
        status: tx.status.confirmed ? 'success' : 'pending',
        type,
        tokenContract: undefined,
        tokenSymbol: 'BTC',
        nonce: undefined,
        confirmations: tx.status.confirmed ? 1 : 0
      };
    } catch (error) {
      this.logger.error(`Failed to parse wallet transaction ${tx.txid} - Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}, TxData: ${JSON.stringify(tx)}`);
      throw error;
    }
  }

  /**
   * Get lightweight address info for efficient gap scanning
   */
  private async getAddressInfo(params: { address: string }): Promise<AddressInfo> {
    const { address } = params;

    this.logger.debug(`Fetching address info - Address: ${maskAddress(address)}`);

    try {
      const addressInfo = await this.httpClient.get<MempoolAddressInfo>(`/address/${address}`);

      // Calculate transaction count
      const txCount = addressInfo.chain_stats.tx_count + addressInfo.mempool_stats.tx_count;

      // Calculate current balance: funded amount - spent amount
      const chainBalance = addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
      const mempoolBalance = addressInfo.mempool_stats.funded_txo_sum - addressInfo.mempool_stats.spent_txo_sum;
      const totalBalanceSats = chainBalance + mempoolBalance;

      // Convert satoshis to BTC
      const balanceBTC = (totalBalanceSats / 100000000).toString();

      this.logger.debug(`Successfully retrieved address info - Address: ${maskAddress(address)}`);

      return {
        txCount,
        balance: balanceBTC
      };

    } catch (error) {
      this.logger.error(`Failed to get address info - Address: ${maskAddress(address)}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }


  private transformTransaction(tx: MempoolTransaction, userAddress?: string): BlockchainTransaction {
    // Calculate transaction value and determine type
    let valueAmount = new Decimal(0);
    let type: BlockchainTransaction['type'] = 'transfer_in';

    if (userAddress) {
      let inputValue = 0;
      let outputValue = 0;

      // Check inputs for user address
      for (const input of tx.vin) {
        if (input.prevout?.scriptpubkey_address === userAddress) {
          inputValue += input.prevout.value;
        }
      }

      // Check outputs for user address
      for (const output of tx.vout) {
        if (output.scriptpubkey_address === userAddress) {
          outputValue += output.value;
        }
      }

      // Determine transaction type and value
      if (inputValue > 0 && outputValue === 0) {
        // Pure withdrawal: user sent money
        type = 'transfer_out';
        valueAmount = new Decimal(inputValue).div(100000000);
      } else if (inputValue === 0 && outputValue > 0) {
        // Pure deposit: user received money
        type = 'transfer_in';
        valueAmount = new Decimal(outputValue).div(100000000);
      } else if (inputValue > 0 && outputValue > 0) {
        // Mixed transaction: calculate net effect
        const netValue = outputValue - inputValue;
        if (netValue > 0) {
          type = 'transfer_in';
          valueAmount = new Decimal(netValue).div(100000000);
        } else {
          type = 'transfer_out';
          valueAmount = new Decimal(Math.abs(netValue)).div(100000000);
        }
      }
    } else {
      // Without user address context, just sum all outputs
      const totalValue = tx.vout.reduce((sum, output) => sum + output.value, 0);
      valueAmount = new Decimal(totalValue).div(100000000);
    }

    // Extract addresses
    const fromAddresses = tx.vin
      .map(input => input.prevout?.scriptpubkey_address)
      .filter((addr): addr is string => addr !== undefined);
    const toAddresses = tx.vout
      .map(output => output.scriptpubkey_address)
      .filter((addr): addr is string => addr !== undefined);

    return {
      hash: tx.txid,
      blockNumber: tx.status.block_height || 0,
      blockHash: tx.status.block_hash || '',
      timestamp: tx.status.block_time || Math.floor(Date.now() / 1000),
      from: fromAddresses[0] || '',
      to: toAddresses[0] || '',
      value: { amount: valueAmount, currency: 'BTC' },
      fee: { amount: new Decimal(tx.fee).div(100000000), currency: 'BTC' },
      status: tx.status.confirmed ? 'success' : 'pending',
      type
    };
  }



}===== ./src/blockchains/bitcoin/utils.ts =====
import { HDKey } from '@scure/bip32';
import * as bitcoin from 'bitcoinjs-lib';

import { getLogger } from '@crypto/shared-logger';

import type { AddressInfo, AddressType, BipStandard, BitcoinWalletAddress, SmartDetectionResult, XpubType } from './types.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';

const logger = getLogger('BitcoinUtils');

/**
 * Bitcoin HD wallet utilities for xpub management and address derivation
 */
export class BitcoinUtils {
  /**
   * Initialize an xpub wallet with smart detection and derivation
   */
  static async initializeXpubWallet(
    walletAddress: BitcoinWalletAddress,
    network: bitcoin.Network,
    providerManager: BlockchainProviderManager,
    addressGap: number = 20
  ): Promise<void> {
    try {
      // Smart detection to determine the correct account type
      const { hdNode, addressFunction, bipStandard, addressType } = await this.smartDetectAccountType(
        walletAddress.address,
        network,
        providerManager
      );

      // Update wallet address with detected values
      walletAddress.bipStandard = bipStandard;
      walletAddress.addressType = addressType;
      walletAddress.derivationPath = this.getDefaultDerivationPath(bipStandard);
      walletAddress.addressGap = addressGap;

      // Derive addresses
      const derivedAddresses: string[] = [];

      // Derive both external (0) and change (1) addresses following BIP standard
      // Interleave external and change addresses to ensure both chains are represented early  
      // Reduce initial derivation to minimize API calls during gap scanning
      const maxPerChain = Math.min(addressGap, 10); // Limit to 10 per chain initially
      for (let i = 0; i < maxPerChain; i++) {
        for (const change of [0, 1]) {
          const childKey = hdNode.deriveChild(change).deriveChild(i);

          if (!childKey.publicKey) {
            logger.warn(`Failed to derive public key for ${change}/${i}`);
            continue;
          }

          const address = addressFunction(Buffer.from(childKey.publicKey));
          derivedAddresses.push(address);
        }
      }

      walletAddress.derivedAddresses = derivedAddresses;

      logger.info(`Successfully derived ${derivedAddresses.length} addresses using ${bipStandard} - Xpub: ${walletAddress.address.substring(0, 20) + '...'}, AddressType: ${addressType}, BipStandard: ${bipStandard}, DerivationPath: ${walletAddress.derivationPath}, TotalAddresses: ${derivedAddresses.length}`);

      // Perform BIP44-compliant intelligent gap scanning
      await this.performAddressGapScanning(walletAddress, providerManager);

    } catch (error) {
      logger.error(`Failed to initialize xpub wallet - Error: ${error instanceof Error ? error.message : 'Unknown error'}, Xpub: ${walletAddress.address.substring(0, 20) + '...'}`);
      throw error;
    }
  }

  /**
   * Perform BIP44-compliant intelligent gap scanning to optimize derived address set
   */
  static async performAddressGapScanning(
    walletAddress: BitcoinWalletAddress,
    providerManager: BlockchainProviderManager
  ): Promise<void> {
    const allDerived = walletAddress.derivedAddresses || [];
    if (allDerived.length === 0) return;

    logger.info(`Performing intelligent gap scan for ${walletAddress.address.substring(0, 20)}...`);

    let lastUsedIndex = -1;
    let consecutiveUnusedCount = 0;
    const GAP_LIMIT = 10; // Reduced gap limit to minimize API calls

    for (let i = 0; i < allDerived.length; i++) {
      const address = allDerived[i];
      if (!address) continue; // Skip invalid addresses

      // Fetch lightweight address info using provider manager
      try {
        const addressInfo = await providerManager.executeWithFailover('bitcoin', {
          type: 'getAddressInfo',
          params: { address },
          getCacheKey: (params: any) => `bitcoin:address-info:${params.address}`
        }) as AddressInfo;

        const hasActivity = addressInfo.txCount > 0;
        if (hasActivity) {
          // Found an active address!
          lastUsedIndex = i;
          consecutiveUnusedCount = 0; // Reset the counter
          logger.debug(`Found activity at index ${i}: ${address} (${addressInfo.txCount} transactions)`);
        } else {
          // Unused address
          consecutiveUnusedCount++;
          logger.debug(`No activity at index ${i}, consecutive unused: ${consecutiveUnusedCount}`);

          // Early exit if we've hit the gap limit
          if (consecutiveUnusedCount >= GAP_LIMIT) {
            logger.info(`Reached gap limit of ${GAP_LIMIT} unused addresses, stopping scan at index ${i}`);
            break;
          }
        }
      } catch (error) {
        // If we can't check the address, treat it as unused
        consecutiveUnusedCount++;
        logger.warn(`Could not check activity for address ${address} - Error: ${error}`);
      }

      // If we've found at least one used address and then hit the gap limit, we can stop.
      if (lastUsedIndex > -1 && consecutiveUnusedCount >= GAP_LIMIT) {
        logger.info(`Gap limit of ${GAP_LIMIT} reached after last used address at index ${lastUsedIndex}.`);
        break;
      }
    }

    let finalAddressCount: number;
    if (lastUsedIndex === -1) {
      // No activity found at all. Just use the first 20 addresses (10 receive, 10 change).
      finalAddressCount = Math.min(allDerived.length, 20);
      logger.info('No activity found. Using default address set size.');
    } else {
      // We found activity. The set should include all addresses up to the last used one, plus the gap limit as a buffer.
      finalAddressCount = Math.min(allDerived.length, lastUsedIndex + GAP_LIMIT + 1);
      logger.info(`Scan complete. Using addresses up to index ${finalAddressCount - 1}.`);
    }

    // Optimize the derived addresses list in place.
    walletAddress.derivedAddresses = allDerived.slice(0, finalAddressCount);

    logger.info(`Optimized address set: ${walletAddress.derivedAddresses.length} addresses (was ${allDerived.length})`);
  }

  /**
   * Smart detection to determine the correct account type from xpub
   */
  static async smartDetectAccountType(
    xpub: string,
    network: bitcoin.Network,
    providerManager: BlockchainProviderManager
  ): Promise<SmartDetectionResult> {
    logger.info('Intelligently detecting account type from xpub...');

    // Handle unambiguous cases
    if (xpub.startsWith('zpub')) {
      logger.info('Detected zpub. Using BIP84 (Native SegWit).');
      return {
        hdNode: HDKey.fromExtendedKey(xpub),
        addressFunction: this.getAddressGenerator('bech32', network),
        bipStandard: 'bip84',
        addressType: 'bech32'
      };
    }

    if (xpub.startsWith('ypub')) {
      logger.info('Detected ypub. Using BIP49 (Nested SegWit).');
      return {
        hdNode: HDKey.fromExtendedKey(xpub),
        addressFunction: this.getAddressGenerator('segwit', network),
        bipStandard: 'bip49',
        addressType: 'segwit'
      };
    }

    // Complex case: xpub could be BIP44 (Legacy) or BIP84 (Ledger-style Native SegWit)
    if (xpub.startsWith('xpub')) {
      logger.info('Detected xpub. Attempting to determine account type...');

      // Test BIP44 (Legacy)
      const legacyHdNode = HDKey.fromExtendedKey(xpub);
      const legacyAddressGen = this.getAddressGenerator('legacy', network);
      const firstLegacyChild = legacyHdNode.deriveChild(0).deriveChild(0);

      if (firstLegacyChild.publicKey) {
        const firstLegacyAddress = legacyAddressGen(Buffer.from(firstLegacyChild.publicKey));

        logger.debug(`Checking Legacy address for activity: ${firstLegacyAddress}`);

        try {
          const addressInfo = await providerManager.executeWithFailover('bitcoin', {
            type: 'getAddressInfo',
            params: { address: firstLegacyAddress }
          }) as AddressInfo;
          const hasActivity = addressInfo.txCount > 0;
          if (hasActivity) {
            logger.info('Found activity on Legacy path (BIP44). Proceeding.');
            return {
              hdNode: legacyHdNode,
              addressFunction: legacyAddressGen,
              bipStandard: 'bip44',
              addressType: 'legacy'
            };
          }
        } catch (error) {
          logger.debug('No activity found on Legacy path');
        }
      }

      // Test BIP84 (Ledger-style Native SegWit)
      logger.info('No activity found on Legacy path. Checking for Native SegWit (Ledger-style)...');

      const segwitHdNode = HDKey.fromExtendedKey(xpub);
      const segwitAddressGen = this.getAddressGenerator('bech32', network);
      const firstSegwitChild = segwitHdNode.deriveChild(0).deriveChild(0);

      if (firstSegwitChild.publicKey) {
        const firstSegwitAddress = segwitAddressGen(Buffer.from(firstSegwitChild.publicKey));

        logger.debug(`Checking Native SegWit address for activity: ${firstSegwitAddress}`);

        try {
          const addressInfo = await providerManager.executeWithFailover('bitcoin', {
            type: 'getAddressInfo',
            params: { address: firstSegwitAddress }
          }) as AddressInfo;
          const hasActivity = addressInfo.txCount > 0;
          if (hasActivity) {
            logger.info('Found activity on Native SegWit path (BIP84). Proceeding.');
            return {
              hdNode: segwitHdNode,
              addressFunction: segwitAddressGen,
              bipStandard: 'bip84',
              addressType: 'bech32'
            };
          }
        } catch (error) {
          logger.debug('No activity found on Native SegWit path');
        }
      }

      // Fallback to Legacy
      logger.info('No activity found on any path. Defaulting to BIP44 (Legacy).');
      return {
        hdNode: legacyHdNode,
        addressFunction: legacyAddressGen,
        bipStandard: 'bip44',
        addressType: 'legacy'
      };
    }

    throw new Error('Unsupported extended public key format.');
  }

  /**
   * Get default derivation path for BIP standard
   */
  static getDefaultDerivationPath(bipStandard: BipStandard): string {
    switch (bipStandard) {
      case 'bip44': return "m/44'/0'/0'";
      case 'bip49': return "m/49'/0'/0'";
      case 'bip84': return "m/84'/0'/0'";
      default:
        throw new Error(`Unsupported BIP standard: ${bipStandard}`);
    }
  }

  /**
   * Get address generator function for address type
   */
  static getAddressGenerator(type: AddressType, network: bitcoin.Network): (pubkey: Buffer) => string {
    switch (type) {
      case 'legacy':
        return (pubkey: Buffer) => {
          const payment = bitcoin.payments.p2pkh({ pubkey, network });
          return payment.address!;
        };
      case 'segwit':
        return (pubkey: Buffer) => {
          const p2wpkh = bitcoin.payments.p2wpkh({ pubkey, network });
          const payment = bitcoin.payments.p2sh({ redeem: p2wpkh, network });
          return payment.address!;
        };
      case 'bech32':
        return (pubkey: Buffer) => {
          const payment = bitcoin.payments.p2wpkh({ pubkey, network });
          return payment.address!;
        };
      default:
        throw new Error(`Unsupported address type: ${type}`);
    }
  }

  /**
   * Get xpub type from address string
   */
  static getAddressType(address: string): XpubType {
    if (address.startsWith('xpub')) return 'xpub';
    if (address.startsWith('ypub')) return 'ypub';
    if (address.startsWith('zpub')) return 'zpub';
    return 'address';
  }

  /**
   * Check if address is an xpub
   */
  static isXpub(address: string): boolean {
    return address.startsWith('xpub') || address.startsWith('ypub') || address.startsWith('zpub');
  }

  /**
   * Check if address is an extended public key
   */
  static isExtendedPublicKey(address: string): boolean {
    return BitcoinUtils.isXpub(address);
  }

  /**
   * Derive addresses from xpub for wallet service
   */
  static async deriveAddressesFromXpub(xpub: string, gap: number = 20): Promise<Array<{
    address: string;
    type: string;
    derivationPath: string;
  }>> {
    const derivedAddresses: Array<{
      address: string;
      type: string;
      derivationPath: string;
    }> = [];

    const xpubType = BitcoinUtils.getAddressType(xpub);
    if (xpubType === 'address') {
      throw new Error('Invalid xpub format');
    }

    try {
      const node = HDKey.fromExtendedKey(xpub);
      const network = bitcoin.networks.bitcoin; // Default to mainnet
      const addressType = xpubType === 'xpub' ? 'legacy' :
        xpubType === 'ypub' ? 'segwit' : 'bech32';

      const addressGenerator = BitcoinUtils.getAddressGenerator(addressType, network);

      // Derive addresses for receiving chain (0) and change chain (1)
      for (const chain of [0, 1]) {
        for (let index = 0; index < gap; index++) {
          const childNode = node.deriveChild(chain).deriveChild(index);
          const publicKeyBuffer = Buffer.from(childNode.publicKey!);
          const address = addressGenerator(publicKeyBuffer);

          derivedAddresses.push({
            address,
            type: addressType,
            derivationPath: `m/${chain}/${index}`
          });
        }
      }

      return derivedAddresses;
    } catch (error) {
      logger.error(`Failed to derive addresses from xpub - Error: ${error}, Xpub: ${xpub.substring(0, 20) + '...'}`);
      throw error;
    }
  }
}===== ./src/blockchains/bitcoin/types.ts =====
// Bitcoin provider-specific API response types
export type XpubType = 'xpub' | 'ypub' | 'zpub' | 'address';
export type BipStandard = 'bip44' | 'bip49' | 'bip84';
export type AddressType = 'legacy' | 'segwit' | 'bech32';

export interface BitcoinWalletAddress {
  address: string;           // Original user-provided address (xpub or regular)
  type: XpubType;           // Type of address
  derivedAddresses?: string[]; // Internal derived addresses (if xpub)
  bipStandard?: BipStandard;   // Detected BIP standard
  addressType?: AddressType;   // Detected address type
  derivationPath?: string;     // Derivation path used
  addressGap?: number;         // Address gap used for derivation
}

export interface SmartDetectionResult {
  hdNode: any; // HDKey from @scure/bip32
  addressFunction: (pubkey: Buffer) => string;
  bipStandard: BipStandard;
  addressType: AddressType;
}

// Lightweight address info for efficient gap scanning
export interface AddressInfo {
  txCount: number;
  balance: string; // in BTC
}

// mempool.space API response types for Bitcoin mainnet
export interface MempoolTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: MempoolInput[];
  vout: MempoolOutput[];
  size: number;
  weight: number;
  fee: number;
  status: MempoolTransactionStatus;
}

export interface MempoolInput {
  txid: string;
  vout: number;
  prevout?: MempoolPrevout;
  scriptsig: string;
  scriptsig_asm: string;
  witness?: string[];
  sequence: number;
}

export interface MempoolPrevout {
  scriptpubkey: string;
  scriptpubkey_asm: string;
  scriptpubkey_type: string;
  scriptpubkey_address?: string;
  value: number;
}

export interface MempoolOutput {
  scriptpubkey: string;
  scriptpubkey_asm: string;
  scriptpubkey_type: string;
  scriptpubkey_address?: string;
  value: number;
}

export interface MempoolTransactionStatus {
  confirmed: boolean;
  block_height?: number;
  block_hash?: string;
  block_time?: number;
}

export interface MempoolAddressInfo {
  address: string;
  chain_stats: {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
  };
  mempool_stats: {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
  };
}

export interface MempoolAddressTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: MempoolInput[];
  vout: MempoolOutput[];
  size: number;
  weight: number;
  fee: number;
  status: MempoolTransactionStatus;
}

// blockstream.info API response types for Bitcoin mainnet
export interface BlockstreamTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: Array<{
    txid: string;
    vout: number;
    prevout: {
      scriptpubkey: string;
      scriptpubkey_asm: string;
      scriptpubkey_type: string;
      scriptpubkey_address?: string;
      value: number;
    };
    scriptsig: string;
    scriptsig_asm: string;
    witness: string[];
    is_coinbase: boolean;
    sequence: number;
  }>;
  vout: Array<{
    scriptpubkey: string;
    scriptpubkey_asm: string;
    scriptpubkey_type: string;
    scriptpubkey_address?: string;
    value: number;
  }>;
  size: number;
  weight: number;
  fee: number;
  status: {
    confirmed: boolean;
    block_height?: number;
    block_hash?: string;
    block_time?: number;
  };
}===== ./src/blockchains/bitcoin/adapter.ts =====
import * as bitcoin from 'bitcoinjs-lib';

import type { Balance, BlockchainInfo, BlockchainTransaction, CryptoTransaction, TransactionType } from '@crypto/core';
import { createMoney } from '@crypto/shared-utils';

import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';
import type { BitcoinWalletAddress } from './types.ts';
import { BitcoinUtils } from './utils.ts';

export class BitcoinAdapter extends BaseBlockchainAdapter {
  private walletAddresses: BitcoinWalletAddress[] = [];
  protected network: bitcoin.Network;
  private addressInfoCache = new Map<string, { balance: string; txCount: number }>(); // Simplified cache
  private providerManager: BlockchainProviderManager;
  private addressGap: number;

  constructor(
    explorerConfig: BlockchainExplorersConfig,
    options?: { addressGap?: number }
  ) {
    super('bitcoin', 'BitcoinAdapter');

    // Always use mainnet
    this.network = bitcoin.networks.bitcoin;

    // Set address gap for xpub derivation
    this.addressGap = options?.addressGap || 20;

    // Create and initialize provider manager with registry
    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('bitcoin', 'mainnet');

    this.logger.info(`Initialized Bitcoin adapter with registry-based provider manager - AddressGap: ${this.addressGap}, ProvidersCount: ${this.providerManager.getProviders('bitcoin').length}`);
  }

  /**
   * Initialize an xpub wallet using BitcoinUtils
   */
  private async initializeXpubWallet(walletAddress: BitcoinWalletAddress): Promise<void> {
    await BitcoinUtils.initializeXpubWallet(
      walletAddress,
      this.network,
      this.providerManager,
      this.addressGap
    );
  }


  /**
   * Get transactions for a user-provided address (handles xpub derivation transparently)
   */
  async getAddressTransactions(userAddress: string, since?: number): Promise<BlockchainTransaction[]> {
    this.logger.info(`Fetching transactions for address: ${userAddress.substring(0, 20)}...`);

    let wallet: BitcoinWalletAddress;

    // Check if we've already processed this address
    const existingWallet = this.walletAddresses.find(w => w.address === userAddress);
    if (existingWallet) {
      wallet = existingWallet;
    } else {
      // Initialize this specific address (handles both xpub and regular addresses)
      wallet = {
        address: userAddress,
        type: BitcoinUtils.getAddressType(userAddress)
      };

      if (BitcoinUtils.isXpub(userAddress)) {
        this.logger.info(`Processing xpub: ${userAddress.substring(0, 20)}...`);
        await this.initializeXpubWallet(wallet);
      } else {
        this.logger.info(`Processing regular address: ${userAddress}`);
      }

      this.walletAddresses.push(wallet);
    }

    if (wallet.derivedAddresses) {
      // Xpub wallet - fetch from all derived addresses and deduplicate
      this.logger.info(`Fetching from ${wallet.derivedAddresses.length} derived addresses`);

      const allTransactions = await this.fetchUniqueTransactionsForWalletWithProviders(wallet.derivedAddresses, since);
      this.logger.info(`Found ${allTransactions.length} unique transactions for wallet ${userAddress.substring(0, 20)}...`);
      return allTransactions;
    } else {
      // Regular address - use provider manager with raw transactions for wallet-aware parsing
      try {
        const rawTransactions = await this.providerManager.executeWithFailover('bitcoin', {
          type: 'getRawAddressTransactions',
          params: { address: userAddress, since },
          getCacheKey: (params: any) => `bitcoin:raw-txs:${params.address}:${params.since || 'all'}`
        }) as any[];

        // Parse raw transactions with wallet context (single address, local parsing)
        const transactions: BlockchainTransaction[] = [];
        for (const rawTx of rawTransactions) {
          try {
            const blockchainTx = this.parseWalletTransaction(rawTx, [userAddress]);
            transactions.push(blockchainTx);
          } catch (error) {
            this.logger.warn(`Failed to parse transaction ${rawTx.txid} - Error: ${error}`);
          }
        }

        this.logger.info(`Found ${transactions.length} transactions for wallet ${userAddress.substring(0, 20)}...`);
        return transactions;
      } catch (error) {
        this.logger.error(`Failed to fetch Bitcoin transactions for ${userAddress} - Error: ${error}`);
        throw error;
      }
    }
  }

  /**
   * Fetch unique raw transactions for an xpub wallet across all derived addresses using provider architecture
   */
  private async fetchUniqueTransactionsForWalletWithProviders(derivedAddresses: string[], since?: number): Promise<BlockchainTransaction[]> {
    // Collect all unique transaction hashes and their associated raw transactions
    const uniqueRawTransactions = new Map<string, any>();

    for (const address of derivedAddresses) {
      // Check cache first to see if this address has any transactions
      const cachedInfo = this.addressInfoCache.get(address);

      // Skip addresses that we know are empty from gap scanning
      if (cachedInfo && cachedInfo.txCount === 0) {
        this.logger.debug(`Skipping address ${address} - no transactions in cache`);
        continue;
      }

      try {
        const rawTransactions = await this.providerManager.executeWithFailover('bitcoin', {
          type: 'getRawAddressTransactions',
          params: { address, since },
          getCacheKey: (params: any) => `bitcoin:raw-txs:${params.address}:${params.since || 'all'}`
        }) as any[];

        // Add raw transactions to the unique set
        for (const rawTx of rawTransactions) {
          uniqueRawTransactions.set(rawTx.txid, rawTx);
        }

        this.logger.debug(`Found ${rawTransactions.length} transactions for address ${address}`);
      } catch (error) {
        this.logger.error(`Failed to fetch raw transactions for address ${address} - Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      }
    }

    this.logger.info(`Found ${uniqueRawTransactions.size} unique raw transactions across all addresses`);

    // Parse each unique transaction with wallet context (local parsing, no API calls)
    const blockchainTransactions: BlockchainTransaction[] = [];
    for (const [txid, rawTx] of uniqueRawTransactions) {
      try {
        const blockchainTx = this.parseWalletTransaction(rawTx, derivedAddresses);
        blockchainTransactions.push(blockchainTx);
      } catch (error) {
        this.logger.warn(`Failed to parse transaction ${txid} - Error: ${error}`);
      }
    }

    // Sort by timestamp (newest first)
    blockchainTransactions.sort((a, b) => b.timestamp - a.timestamp);

    return blockchainTransactions;
  }

  /**
   * Parse a raw Bitcoin transaction with wallet context (local parsing, no API calls)
   */
  private parseWalletTransaction(tx: any, walletAddresses: string[]): BlockchainTransaction {
    const timestamp = tx.status.confirmed && tx.status.block_time
      ? tx.status.block_time * 1000
      : Date.now();

    // Calculate transaction value considering all wallet addresses
    let totalValueChange = 0;
    let isIncoming = false;
    let isOutgoing = false;
    const relevantAddresses = new Set(walletAddresses);

    // Check inputs - money going out of our wallet
    for (const input of tx.vin) {
      if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
        isOutgoing = true;
        if (input.prevout?.value) {
          totalValueChange -= input.prevout.value;
        }
      }
    }

    // Check outputs - money coming into our wallet
    for (const output of tx.vout) {
      if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
        isIncoming = true;
        totalValueChange += output.value;
      }
    }

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';

    if (isIncoming && !isOutgoing) {
      type = 'transfer_in';
    } else if (isOutgoing && !isIncoming) {
      type = 'transfer_out';
    } else if (isIncoming && isOutgoing) {
      // Internal transfer within our wallet - treat based on net change
      type = totalValueChange >= 0 ? 'internal_transfer_in' : 'internal_transfer_out';
    } else {
      // Neither incoming nor outgoing (shouldn't happen with proper filtering)
      type = 'transfer_out';
    }

    const totalValue = Math.abs(totalValueChange);
    const fee = isOutgoing ? tx.fee : 0;

    // Determine from/to addresses (first relevant address found)
    let fromAddress = '';
    let toAddress = '';

    // For from address, look for wallet addresses in inputs
    for (const input of tx.vin) {
      if (input.prevout?.scriptpubkey_address && relevantAddresses.has(input.prevout.scriptpubkey_address)) {
        fromAddress = input.prevout.scriptpubkey_address;
        break;
      }
    }

    // For to address, look for wallet addresses in outputs
    for (const output of tx.vout) {
      if (output.scriptpubkey_address && relevantAddresses.has(output.scriptpubkey_address)) {
        toAddress = output.scriptpubkey_address;
        break;
      }
    }

    // Fallback to first addresses if no wallet addresses found
    if (!fromAddress && tx.vin.length > 0 && tx.vin[0]?.prevout?.scriptpubkey_address) {
      fromAddress = tx.vin[0].prevout.scriptpubkey_address;
    }

    if (!toAddress && tx.vout.length > 0 && tx.vout[0]?.scriptpubkey_address) {
      toAddress = tx.vout[0].scriptpubkey_address;
    }

    return {
      hash: tx.txid,
      blockNumber: tx.status.block_height || 0,
      blockHash: tx.status.block_hash || '',
      timestamp,
      from: fromAddress,
      to: toAddress,
      value: createMoney(totalValue / 100000000, 'BTC'),
      fee: createMoney(fee / 100000000, 'BTC'),
      gasUsed: undefined,
      gasPrice: undefined,
      status: tx.status.confirmed ? 'success' : 'pending',
      type,
      tokenContract: undefined,
      tokenSymbol: 'BTC',
      nonce: undefined,
      confirmations: tx.status.confirmed ? 1 : 0
    };
  }

  async getAddressBalance(address: string): Promise<Balance[]> {
    try {
      const result = await this.providerManager.executeWithFailover('bitcoin', {
        type: 'getAddressBalance',
        params: { address }
      }) as { balance: string; token: string };

      const balanceValue = parseFloat(result.balance);
      const balances: Balance[] = [];

      if (balanceValue > 0) {
        balances.push({
          currency: 'BTC',
          balance: balanceValue,
          used: 0,
          total: balanceValue,
          contractAddress: undefined
        });
      }

      return balances;

    } catch (error) {
      this.logger.error(`Failed to get Bitcoin balance for ${address} - Error: ${error}`);
      throw error;
    }
  }

  validateAddress(address: string): boolean {
    const legacyPattern = /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/;
    const segwitPattern = /^3[a-km-zA-HJ-NP-Z1-9]{25,34}$/;
    const bech32Pattern = /^bc1[a-z0-9]{39,59}$/;
    const xpubPattern = /^[xyz]pub[1-9A-HJ-NP-Za-km-z]{100,108}$/;

    return legacyPattern.test(address) || segwitPattern.test(address) ||
      bech32Pattern.test(address) || xpubPattern.test(address);
  }

  // Bitcoin doesn't support tokens, so optional token methods are not implemented

  async testConnection(): Promise<boolean> {
    try {
      // Test connection through provider manager
      const healthStatus = this.providerManager.getProviderHealth('bitcoin');
      const hasHealthyProvider = Array.from(healthStatus.values()).some(health =>
        health.isHealthy && health.circuitState !== 'OPEN'
      );

      this.logger.info(`Bitcoin provider connection test result - HasHealthyProvider: ${hasHealthyProvider}, TotalProviders: ${healthStatus.size}`);

      return hasHealthyProvider;
    } catch (error) {
      this.logger.error(`Bitcoin connection test failed - Error: ${error}`);
      return false;
    }
  }

  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info('Bitcoin adapter closed successfully');
    } catch (error) {
      this.logger.warn(`Error during Bitcoin adapter close - Error: ${error}`);
    }
  }


  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: 'bitcoin',
      name: 'Bitcoin Blockchain',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: false,
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  /**
   * Override convertToCryptoTransaction to handle xpub derived addresses properly
   */
  convertToCryptoTransaction(blockchainTx: BlockchainTransaction): CryptoTransaction {
    // Use the Bitcoin adapter's own transaction type classification
    let type: TransactionType;

    if (blockchainTx.type === 'transfer_in' || blockchainTx.type === 'internal_transfer_in') {
      type = 'deposit';
    } else if (blockchainTx.type === 'transfer_out' || blockchainTx.type === 'internal_transfer_out') {
      type = 'withdrawal';
    } else {
      // Fallback - shouldn't happen with proper Bitcoin transaction classification
      type = 'withdrawal';
    }

    return {
      id: blockchainTx.hash,
      type,
      timestamp: blockchainTx.timestamp,
      datetime: new Date(blockchainTx.timestamp).toISOString(),
      symbol: blockchainTx.tokenSymbol || undefined,
      side: undefined,
      amount: blockchainTx.value,
      price: undefined,
      fee: blockchainTx.fee,
      status: blockchainTx.status === 'success' ? 'closed' :
        blockchainTx.status === 'pending' ? 'open' : 'canceled',
      info: {
        blockNumber: blockchainTx.blockNumber,
        blockHash: blockchainTx.blockHash,
        from: blockchainTx.from,
        to: blockchainTx.to,
        confirmations: blockchainTx.confirmations,
        transactionType: blockchainTx.type,
        originalTransaction: blockchainTx
      }
    };
  }

}===== ./src/blockchains/avalanche/providers/SnowtraceProvider.ts =====
import type { Balance, BlockchainTransaction } from '@crypto/core';
import { AuthenticationError, ServiceError } from '@crypto/core';
import { createMoney, maskAddress, parseDecimal } from '@crypto/shared-utils';
import { Decimal } from 'decimal.js';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import type { ProviderOperation } from '../../shared/types.ts';
import type { SnowtraceApiResponse, SnowtraceInternalTransaction, SnowtraceTokenTransfer, SnowtraceTransaction } from '../types.ts';
import { isValidAvalancheAddress } from '../types.ts';

@RegisterProvider({
  name: 'snowtrace',
  blockchain: 'avalanche',
  displayName: 'Snowtrace API',
  type: 'rest',
  requiresApiKey: false,
  apiKeyEnvVar: 'SNOWTRACE_API_KEY',
  description: 'Avalanche blockchain explorer API with comprehensive transaction and balance data',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://api.snowtrace.io/api'
    },
    testnet: {
      baseUrl: 'https://api-testnet.snowtrace.io/api'
    }
  },
  defaultConfig: {
    timeout: 10000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 1,
      requestsPerMinute: 30,
      requestsPerHour: 100,
      burstLimit: 3
    }
  }
})
export class SnowtraceProvider extends BaseRegistryProvider {

  constructor() {
    super('avalanche', 'snowtrace', 'mainnet');

    this.logger.debug(`Initialized SnowtraceProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}, HasApiKey: ${this.apiKey !== 'YourApiKeyToken'}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a simple API call
      const params = new URLSearchParams({
        module: 'stats',
        action: 'ethsupply'
      });

      if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
        params.append('apikey', this.apiKey);
      }

      const response = await this.httpClient.get(`?${params.toString()}`);
      return response && response.status === '1';
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const result = await this.isHealthy();
      if (!result) {
        this.logger.warn(`Connection test failed - Provider unhealthy`);
      }
      return result;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getTokenTransactions':
          return this.getTokenTransactions(operation.params as { address: string; contractAddress?: string; since?: number }) as T;
        case 'getTokenBalances':
          return this.getTokenBalances(operation.params as { address: string; contractAddresses?: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    if (!isValidAvalancheAddress(address)) {
      throw new Error(`Invalid Avalanche address: ${address}`);
    }

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get normal transactions
      const normalTransactions = await this.getNormalTransactions(address, since);

      // Get internal transactions
      const internalTransactions = await this.getInternalTransactions(address, since);

      // Note: Token transfers are handled separately via getTokenTransactions
      const allTransactions = [...normalTransactions, ...internalTransactions];

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      this.logger.debug(`Retrieved ${allTransactions.length} transactions for ${maskAddress(address)}`);

      return allTransactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance> {
    const { address } = params;

    if (!isValidAvalancheAddress(address)) {
      throw new Error(`Invalid Avalanche address: ${address}`);
    }

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      // Get AVAX balance
      const avaxBalance = await this.getAVAXBalance(address);

      this.logger.debug(`Retrieved balance for ${maskAddress(address)}: ${avaxBalance.balance} AVAX`);

      return avaxBalance;
    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenTransactions(params: { address: string; contractAddress?: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, contractAddress, since } = params;
    return this.getTokenTransfers(address, since, contractAddress);
  }

  private async getTokenBalances(params: { address: string; contractAddresses?: string[] }): Promise<Balance[]> {
    const { address, contractAddresses } = params;
    return this.getTokenBalancesForAddress(address, contractAddresses);
  }

  private async getNormalTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const params = new URLSearchParams({
      module: 'account',
      action: 'txlist',
      address: address,
      startblock: '0',
      endblock: '99999999',
      sort: 'asc'
    });

    if (since) {
      // Convert timestamp to approximate block number (simplified)
      // In production, you'd want to use a more accurate method
      params.set('startblock', Math.floor(since / 1000).toString());
    }

    if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
      params.append('apikey', this.apiKey);
    }

    const response = await this.httpClient.get(`?${params.toString()}`) as SnowtraceApiResponse<SnowtraceTransaction>;

    if (response.status !== '1') {
      if (response.message === 'NOTOK' && response.result && (response.result as any).includes('Invalid API Key')) {
        throw new AuthenticationError('Invalid Snowtrace API key', this.name, 'getNormalTransactions');
      }
      throw new ServiceError(`Snowtrace API error: ${response.message}`, this.name, 'getNormalTransactions');
    }

    return response.result.map(tx => this.convertNormalTransaction(tx, address));
  }

  private async getInternalTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const params = new URLSearchParams({
      module: 'account',
      action: 'txlistinternal',
      address: address,
      startblock: '0',
      endblock: '99999999',
      sort: 'asc'
    });

    if (since) {
      params.set('startblock', Math.floor(since / 1000).toString());
    }

    if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
      params.append('apikey', this.apiKey);
    }

    try {
      const response = await this.httpClient.get(`?${params.toString()}`) as SnowtraceApiResponse<SnowtraceInternalTransaction>;

      if (response.status !== '1') {
        // Internal transactions might not be available for all addresses
        this.logger.debug(`No internal transactions found - Message: ${response.message}`);
        return [];
      }

      return response.result.map(tx => this.convertInternalTransaction(tx, address));
    } catch (error) {
      this.logger.warn(`Failed to fetch internal transactions`);
      return [];
    }
  }

  private async getTokenTransfers(address: string, since?: number, contractAddress?: string): Promise<BlockchainTransaction[]> {
    const params = new URLSearchParams({
      module: 'account',
      action: 'tokentx',
      address: address,
      startblock: '0',
      endblock: '99999999',
      sort: 'asc'
    });

    if (since) {
      params.set('startblock', Math.floor(since / 1000).toString());
    }

    if (contractAddress) {
      params.append('contractaddress', contractAddress);
    }

    if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
      params.append('apikey', this.apiKey);
    }

    try {
      const response = await this.httpClient.get(`?${params.toString()}`) as SnowtraceApiResponse<SnowtraceTokenTransfer>;

      if (response.status !== '1') {
        this.logger.debug(`No token transfers found - Message: ${response.message}`);
        return [];
      }

      return response.result.map(tx => this.convertTokenTransfer(tx, address));
    } catch (error) {
      this.logger.warn(`Failed to fetch token transfers`);
      return [];
    }
  }

  private async getAVAXBalance(address: string): Promise<Balance> {
    const params = new URLSearchParams({
      module: 'account',
      action: 'balance',
      address: address,
      tag: 'latest'
    });

    if (this.apiKey && this.apiKey !== 'YourApiKeyToken') {
      params.append('apikey', this.apiKey);
    }

    const response = await this.httpClient.get(`?${params.toString()}`) as SnowtraceApiResponse<string>;

    if (response.status !== '1') {
      throw new ServiceError(`Failed to fetch AVAX balance: ${response.message}`, this.name, 'getAVAXBalance');
    }

    // Convert from wei to AVAX
    const balanceWei = new Decimal(response.result as any);
    const balanceAvax = balanceWei.dividedBy(new Decimal(10).pow(18));

    return {
      currency: 'AVAX',
      balance: balanceAvax.toNumber(),
      used: 0,
      total: balanceAvax.toNumber()
    };
  }

  private async getTokenBalancesForAddress(_address: string, _contractAddresses?: string[]): Promise<Balance[]> {
    // Snowtrace doesn't have a direct "get all token balances" endpoint like some other explorers
    // For now, return empty array - in production you might want to track known token contracts
    this.logger.debug('Token balance fetching not implemented for Snowtrace - use specific contract addresses');
    return [];
  }

  private convertNormalTransaction(tx: SnowtraceTransaction, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out';
    if (isFromUser && isToUser) {
      type = 'transfer_in'; // Self-transfer, treat as incoming
    } else if (isFromUser) {
      type = 'transfer_out';
    } else {
      type = 'transfer_in';
    }

    // Convert value from wei to AVAX
    const valueWei = new Decimal(tx.value);
    const valueAvax = valueWei.dividedBy(new Decimal(10).pow(18));

    // Calculate fee
    const gasUsed = new Decimal(tx.gasUsed);
    const gasPrice = new Decimal(tx.gasPrice);
    const feeWei = gasUsed.mul(gasPrice);
    const feeAvax = feeWei.dividedBy(new Decimal(10).pow(18));

    return {
      hash: tx.hash,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: tx.blockHash,
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(valueAvax.toNumber(), 'AVAX'),
      fee: createMoney(feeAvax.toNumber(), 'AVAX'),
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: parseDecimal(tx.gasPrice).toNumber(),
      status: tx.txreceipt_status === '1' ? 'success' : 'failed',
      type,
      confirmations: parseInt(tx.confirmations)
    };
  }

  private convertInternalTransaction(tx: SnowtraceInternalTransaction, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    let type: 'internal_transfer_in' | 'internal_transfer_out';
    if (isFromUser && isToUser) {
      type = 'internal_transfer_in';
    } else if (isFromUser) {
      type = 'internal_transfer_out';
    } else {
      type = 'internal_transfer_in';
    }

    const valueWei = new Decimal(tx.value);
    const valueAvax = valueWei.dividedBy(new Decimal(10).pow(18));

    return {
      hash: tx.hash,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: '',
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(valueAvax.toNumber(), 'AVAX'),
      fee: createMoney(0, 'AVAX'),
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: 0,
      status: tx.isError === '0' ? 'success' : 'failed',
      type
    };
  }

  private convertTokenTransfer(tx: SnowtraceTokenTransfer, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    let type: 'token_transfer_in' | 'token_transfer_out';
    if (isFromUser && isToUser) {
      type = 'token_transfer_in';
    } else if (isFromUser) {
      type = 'token_transfer_out';
    } else {
      type = 'token_transfer_in';
    }

    // Convert value using token decimals
    const decimals = parseInt(tx.tokenDecimal);
    const valueRaw = new Decimal(tx.value);
    const value = valueRaw.dividedBy(new Decimal(10).pow(decimals));

    return {
      hash: tx.hash,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: tx.blockHash,
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(value.toNumber(), tx.tokenSymbol),
      fee: createMoney(0, 'AVAX'),
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: parseDecimal(tx.gasPrice).toNumber(),
      status: 'success',
      type,
      tokenContract: tx.contractAddress,
      tokenSymbol: tx.tokenSymbol,
      confirmations: parseInt(tx.confirmations)
    };
  }

}===== ./src/blockchains/avalanche/types.ts =====
// Avalanche C-Chain specific types and interfaces

export interface SnowtraceTransaction {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  transactionIndex: string;
  from: string;
  to: string;
  value: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  cumulativeGasUsed: string;
  input: string;
  confirmations: string;
  isError?: string;
  txreceipt_status?: string;
  functionName?: string;
  methodId?: string;
}

export interface SnowtraceInternalTransaction {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  from: string;
  to: string;
  value: string;
  contractAddress: string;
  input: string;
  type: string;
  gas: string;
  gasUsed: string;
  traceId: string;
  isError: string;
  errCode: string;
}

export interface SnowtraceTokenTransfer {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  from: string;
  contractAddress: string;
  to: string;
  value: string;
  tokenName: string;
  tokenSymbol: string;
  tokenDecimal: string;
  transactionIndex: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  cumulativeGasUsed: string;
  input: string;
  confirmations: string;
}

export interface SnowtraceApiResponse<T> {
  status: string;
  message: string;
  result: T[];
}

export interface SnowtraceBalance {
  account: string;
  balance: string;
}

export interface SnowtraceTokenBalance {
  TokenAddress: string;
  TokenName: string;
  TokenSymbol: string;
  TokenQuantity: string;
  TokenDivisor: string;
}

// Avalanche-specific atomic transaction types
export interface AtomicTransaction {
  id: string;
  timestamp: string;
  type: 'import' | 'export';
  sourceChain: 'P' | 'X' | 'C';
  destinationChain: 'P' | 'X' | 'C';
  amount: string;
  asset: string;
  fee: string;
  status: 'accepted' | 'processing' | 'rejected';
}

// Network configuration for Avalanche C-Chain
export interface AvalancheNetwork {
  name: string;
  chainId: number;
  nativeCurrency: {
    name: string;
    symbol: string;
    decimals: number;
  };
  rpcUrls: string[];
  blockExplorerUrls: string[];
  apiUrl: string;
  apiKey?: string;
}

// Avalanche address validation
export function isValidAvalancheAddress(address: string): boolean {
  // Avalanche C-Chain uses Ethereum-style addresses but they are case-sensitive
  const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
  return ethAddressRegex.test(address);
}

// Convert address to checksum (important for Avalanche case-sensitivity)
export function toChecksumAddress(address: string): string {
  // Basic implementation - in production you'd want to use a proper checksum library
  if (!isValidAvalancheAddress(address)) {
    throw new Error('Invalid Avalanche address format');
  }
  return address; // For now, return as-is, but in production implement proper checksumming
}===== ./src/blockchains/avalanche/adapter.ts =====
import type {
  Balance,
  BlockchainInfo,
  BlockchainTransaction
} from '@crypto/core';

import './providers/SnowtraceProvider.ts';

import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';

export class AvalancheAdapter extends BaseBlockchainAdapter {
  private providerManager: BlockchainProviderManager;

  constructor(explorerConfig: BlockchainExplorersConfig) {
    super('avalanche', 'AvalancheAdapter');

    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('avalanche', 'mainnet');

    this.logger.debug(`Initialized Avalanche adapter with ${this.providerManager.getProviders('avalanche').length} providers`);
  }


  async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    this.logger.info(`AvalancheAdapter: Fetching transactions for address: ${address.substring(0, 20)}...`);
    this.logger.debug(`AvalancheAdapter.getAddressTransactions called - Address: ${address}, Since: ${since}`);

    try {
      // Fetch regular AVAX transactions
      const regularTxs = await this.providerManager.executeWithFailover('avalanche', {
        type: 'getAddressTransactions',
        params: { address, since },
        getCacheKey: (params: any) => `avax_tx_${params.address}_${params.since || 'all'}`
      }) as BlockchainTransaction[];

      // Try to fetch ERC-20 token transactions (if provider supports it)
      let tokenTxs: BlockchainTransaction[] = [];
      try {
        tokenTxs = await this.providerManager.executeWithFailover('avalanche', {
          type: 'getTokenTransactions',
          params: { address, since },
          getCacheKey: (params: any) => `avax_token_tx_${params.address}_${params.since || 'all'}`
        }) as BlockchainTransaction[];
      } catch (error) {
        this.logger.debug(`Provider does not support separate token transactions or failed to fetch: ${error instanceof Error ? error.message : String(error)}`);
        // Continue without separate token transactions - provider may already include them in getAddressTransactions
      }

      this.logger.debug(`Transaction breakdown: ${regularTxs.length} regular, ${tokenTxs.length} token`);

      // Combine all transactions (following the same pattern as Ethereum/Solana)
      const allTransactions = [...regularTxs, ...tokenTxs];

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      // Remove any duplicate transactions (by hash) - some providers may include tokens in regular transactions
      const uniqueTransactions = allTransactions.reduce((acc, tx) => {
        if (!acc.find(existing => existing.hash === tx.hash)) {
          acc.push(tx);
        }
        return acc;
      }, [] as BlockchainTransaction[]);

      this.logger.debug(`Found ${uniqueTransactions.length} unique transactions`);
      return uniqueTransactions;

    } catch (error) {
      this.logger.error(`Failed to fetch address transactions via provider manager - Address: ${address}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  async getAddressBalance(address: string): Promise<Balance[]> {
    this.logger.debug(`AvalancheAdapter.getAddressBalance called - Address: ${address}`);

    try {
      // Use provider manager to fetch balance with failover
      const balances = await this.providerManager.executeWithFailover('avalanche', {
        type: 'getAddressBalance',
        params: { address },
        getCacheKey: (params: any) => `avax_balance_${params.address}`
      }) as Balance[];

      this.logger.info(`AvalancheAdapter: Found ${balances.length} balances for address`);
      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch address balance via provider manager - Address: ${address}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  validateAddress(address: string): boolean {
    // Avalanche C-Chain uses Ethereum-style addresses but they are case-sensitive
    const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
    const isValid = ethAddressRegex.test(address);

    this.logger.debug(`Address validation - Address: ${address}, IsValid: ${isValid}`);
    return isValid;
  }

  async testConnection(): Promise<boolean> {
    this.logger.debug('AvalancheAdapter.testConnection called');

    try {
      // Test connection using provider manager
      const providers = this.providerManager.getProviders('avalanche');
      if (providers.length === 0) {
        this.logger.warn('No Avalanche providers available for connection test');
        return false;
      }

      // Test the first healthy provider
      for (const provider of providers) {
        try {
          const isHealthy = await provider.isHealthy();
          if (isHealthy) {
            this.logger.info(`Connection test successful with provider: ${provider.name}`);
            return true;
          }
        } catch (error) {
          this.logger.debug(`Provider ${provider.name} failed health check - Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      this.logger.warn('All Avalanche providers failed connection test');
      return false;

    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: 'avalanche',
      name: 'Avalanche C-Chain',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: true,
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  async getTokenTransactions(address: string, tokenContract?: string): Promise<BlockchainTransaction[]> {
    this.logger.debug(`AvalancheAdapter.getTokenTransactions called - Address: ${address}, TokenContract: ${tokenContract}`);

    try {
      const transactions = await this.providerManager.executeWithFailover('avalanche', {
        type: 'getTokenTransactions',
        params: { address, contractAddress: tokenContract },
        getCacheKey: (params: any) => `avax_token_tx_${params.address}_${params.contractAddress || 'all'}`
      }) as BlockchainTransaction[];

      this.logger.info(`AvalancheAdapter: Found ${transactions.length} token transactions for address`);
      return transactions;

    } catch (error) {
      this.logger.error(`Failed to fetch token transactions via provider manager - Address: ${address}, TokenContract: ${tokenContract}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  async getTokenBalances(address: string): Promise<Balance[]> {
    this.logger.debug(`AvalancheAdapter.getTokenBalances called - Address: ${address}`);

    try {
      const balances = await this.providerManager.executeWithFailover('avalanche', {
        type: 'getTokenBalances',
        params: { address },
        getCacheKey: (params: any) => `avax_token_balance_${params.address}`
      }) as Balance[];

      this.logger.info(`AvalancheAdapter: Found ${balances.length} token balances for address`);
      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch token balances via provider manager - Address: ${address}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info('Avalanche adapter closed successfully');
    } catch (error) {
      this.logger.warn(`Error during Avalanche adapter close - Error: ${error}`);
    }
  }
}===== ./src/blockchains/registry/register-providers.ts =====
// Import all blockchain providers to trigger their registration
// This must be imported before using the ProviderRegistry

// Bitcoin Providers
import '../bitcoin/providers/BlockCypherProvider.ts';
import '../bitcoin/providers/BlockstreamProvider.ts';
import '../bitcoin/providers/MempoolSpaceProvider.ts';

// Ethereum Providers
import '../ethereum/providers/AlchemyProvider.ts';
import '../ethereum/providers/EtherscanProvider.ts';
import '../ethereum/providers/MoralisProvider.ts';

// Solana Providers
import '../solana/providers/HeliusProvider.ts';
import '../solana/providers/SolanaRPCProvider.ts';
import '../solana/providers/SolscanProvider.ts';

// Avalanche Providers
import '../avalanche/providers/SnowtraceProvider.ts';

// Injective Providers
import '../injective/providers/InjectiveExplorerProvider.ts';
import '../injective/providers/InjectiveLCDProvider.ts';

// Polkadot/Substrate Providers
import '../polkadot/providers/SubstrateProvider.ts';===== ./src/blockchains/injective/providers/InjectiveExplorerProvider.ts =====

import type { BlockchainTransaction } from '@crypto/core';
import { createMoney, maskAddress, parseDecimal } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { InjectiveApiResponse, InjectiveTransaction } from '../types.ts';

@RegisterProvider({
  name: 'injective-explorer',
  blockchain: 'injective',
  displayName: 'Injective Explorer API',
  type: 'rest',
  requiresApiKey: false,
  description: 'Direct connection to Injective Protocol blockchain explorer with comprehensive transaction data',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getRawAddressTransactions'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://sentry.exchange.grpc-web.injective.network'
    },
    testnet: {
      baseUrl: 'https://k8s.testnet.tm.injective.network'
    }
  },
  defaultConfig: {
    timeout: 15000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 2,
      requestsPerMinute: 60,
      requestsPerHour: 500,
      burstLimit: 5
    }
  }
})
export class InjectiveExplorerProvider extends BaseRegistryProvider {
  private readonly INJECTIVE_DENOM = 'inj';

  constructor() {
    super('injective', 'injective-explorer', 'mainnet');

    this.logger.debug(`Initialized InjectiveExplorerProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a known address to check if the API is responsive
      const testAddress = 'inj1qq6hgelyft8z5fnm6vyyn3ge3w2nway4ykdf6a'; // Injective Foundation address
      const endpoint = `/api/explorer/v1/accountTxs/${testAddress}`;

      const response = await this.httpClient.get(endpoint);
      return response && typeof response === 'object';
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const result = await this.isHealthy();
      this.logger.debug(`Connection test result - Healthy: ${result}`);
      return result;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getRawAddressTransactions':
          return this.getRawAddressTransactions(operation.params as { address: string; since?: number }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    if (!this.validateAddress(address)) {
      throw new Error(`Invalid Injective address: ${address}`);
    }

    this.logger.debug(`Fetching address transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const endpoint = `/api/explorer/v1/accountTxs/${address}`;
      const data = await this.httpClient.get(endpoint) as InjectiveApiResponse;

      if (!data.data || !Array.isArray(data.data)) {
        this.logger.debug(`No transactions found in API response - Address: ${maskAddress(address)}, HasData: ${!!data.data}`);
        return [];
      }

      const transactions: BlockchainTransaction[] = [];

      for (const tx of data.data) {
        try {
          const blockchainTx = this.parseInjectiveTransaction(tx, address);

          // Skip transactions that are not relevant to our wallet
          if (!blockchainTx) {
            continue;
          }

          // Apply time filter if specified
          if (since && blockchainTx.timestamp < since) {
            continue;
          }

          transactions.push(blockchainTx);
        } catch (error) {
          this.logger.warn(`Failed to parse transaction - TxHash: ${tx.hash || tx.id}, Error: ${error instanceof Error ? error.message : error}`);
        }
      }

      this.logger.debug(`Successfully retrieved address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${transactions.length}, Network: ${this.network}`);

      return transactions;

    } catch (error) {
      this.logger.error(`Failed to get address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getRawAddressTransactions(params: { address: string; since?: number }): Promise<InjectiveTransaction[]> {
    const { address, since } = params;

    if (!this.validateAddress(address)) {
      throw new Error(`Invalid Injective address: ${address}`);
    }

    this.logger.debug(`Fetching raw address transactions - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const endpoint = `/api/explorer/v1/accountTxs/${address}`;
      const data = await this.httpClient.get(endpoint) as InjectiveApiResponse;

      if (!data.data || !Array.isArray(data.data)) {
        return [];
      }

      let transactions = data.data;

      // Apply time filter if specified
      if (since) {
        transactions = transactions.filter(tx => {
          const timestamp = new Date(tx.block_timestamp).getTime();
          return timestamp >= since;
        });
      }

      this.logger.debug(`Successfully retrieved raw address transactions - Address: ${maskAddress(address)}, TotalTransactions: ${transactions.length}, Network: ${this.network}`);

      return transactions;
    } catch (error) {
      this.logger.error(`Failed to get raw address transactions - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private validateAddress(address: string): boolean {
    // Injective addresses start with 'inj' and are bech32 encoded
    const injectiveAddressRegex = /^inj1[a-z0-9]{38}$/;
    return injectiveAddressRegex.test(address);
  }

  private parseInjectiveTransaction(tx: InjectiveTransaction, relevantAddress: string): BlockchainTransaction | null {
    const timestamp = new Date(tx.block_timestamp).getTime();

    // Extract transaction details from properly typed Injective transaction
    let value = createMoney(0, this.INJECTIVE_DENOM);
    let fee = createMoney(0, this.INJECTIVE_DENOM);
    let from = '';
    let to = '';
    let tokenSymbol = this.INJECTIVE_DENOM;

    // Parse fee from gas_fee field
    if (tx.gas_fee && tx.gas_fee.amount && Array.isArray(tx.gas_fee.amount) && tx.gas_fee.amount.length > 0) {
      // gas_fee.amount is an array of {denom, amount} objects
      const firstFee = tx.gas_fee.amount[0];
      if (firstFee && firstFee.amount && firstFee.denom) {
        fee = createMoney(
          parseDecimal(firstFee.amount).div(Math.pow(10, 18)).toNumber(),
          this.formatDenom(firstFee.denom)
        );
      }
    }

    // Parse messages to extract transfer information and determine relevance
    let isRelevantTransaction = false;
    let transactionType: 'transfer_in' | 'transfer_out' | 'transfer' = 'transfer';

    for (const message of tx.messages) {
      // Handle bank transfer messages
      if (message.type === '/cosmos.bank.v1beta1.MsgSend') {
        from = message.value.from_address || '';
        to = message.value.to_address || '';

        if (message.value.amount && message.value.amount.length > 0) {
          const transferAmount = message.value.amount[0];
          if (transferAmount) {
            value = createMoney(
              parseDecimal(transferAmount.amount).div(Math.pow(10, 18)).toNumber(),
              this.formatDenom(transferAmount.denom)
            );
            tokenSymbol = this.formatDenom(transferAmount.denom);
          }
        }

        // Determine if this transaction is relevant to our wallet
        if (to === relevantAddress && value.amount.toNumber() > 0) {
          // We are receiving funds - this is a transfer in
          isRelevantTransaction = true;
          transactionType = 'transfer_in';
        } else if (from === relevantAddress && value.amount.toNumber() > 0) {
          // We are sending funds - this is a transfer out
          isRelevantTransaction = true;
          transactionType = 'transfer_out';
        }
        break; // Use first transfer message
      }

      // Handle IBC transfer messages
      else if (message.type === '/ibc.applications.transfer.v1.MsgTransfer') {
        from = message.value.sender || '';
        to = message.value.receiver || '';

        if (message.value.token) {
          value = createMoney(
            parseDecimal(message.value.token.amount).div(Math.pow(10, 18)).toNumber(),
            this.formatDenom(message.value.token.denom)
          );
          tokenSymbol = this.formatDenom(message.value.token.denom);
        }

        // Determine if this transaction is relevant to our wallet
        if (to === relevantAddress && value.amount.toNumber() > 0) {
          // We are receiving funds - this is a transfer in
          isRelevantTransaction = true;
          transactionType = 'transfer_in';
        } else if (from === relevantAddress && value.amount.toNumber() > 0) {
          // We are sending funds - this is a transfer out
          isRelevantTransaction = true;
          transactionType = 'transfer_out';
        }
        break;
      }

      // Handle Peggy bridge deposit messages (when funds come from Ethereum)
      else if (message.type === '/injective.peggy.v1.MsgDepositClaim') {
        // This is typically an inbound deposit from Ethereum bridge
        const messageValue = message.value as any; // Type assertion for bridge-specific properties
        if (messageValue.ethereum_receiver === relevantAddress ||
          messageValue.injective_receiver === relevantAddress) {
          isRelevantTransaction = true;
          transactionType = 'transfer_in'; // Bridge deposits are incoming
          to = relevantAddress;

          // Extract amount from the deposit claim if available
          if (messageValue.amount && messageValue.token_contract) {
            value = createMoney(
              parseDecimal(messageValue.amount).div(Math.pow(10, 18)).toNumber(),
              'INJ' // or determine from token_contract
            );
            tokenSymbol = 'INJ';
          }
        }
      }
    }

    // Only return transactions that are relevant to our wallet
    if (!isRelevantTransaction) {
      this.logger.debug(`Skipping irrelevant transaction - Hash: ${tx.hash}, From: ${maskAddress(from)}, To: ${maskAddress(to)}, RelevantAddress: ${maskAddress(relevantAddress)}, Value: ${value.amount.toNumber()}`);
      return null;
    }

    return {
      hash: tx.hash,
      blockNumber: tx.block_number,
      blockHash: '', // Not provided in the API response
      timestamp,
      from,
      to,
      value,
      fee,
      gasUsed: tx.gas_used,
      gasPrice: tx.gas_fee && Array.isArray(tx.gas_fee.amount) && tx.gas_fee.amount.length > 0 ? (() => {
        const firstFee = tx.gas_fee.amount[0];
        if (firstFee && firstFee.amount && firstFee.denom) {
          return parseDecimal(firstFee.amount).div(tx.gas_used || 1).toNumber();
        }
        return 0;
      })() : 0,
      status: tx.code === 0 ? 'success' : 'failed',
      type: transactionType,
      tokenSymbol,
      confirmations: 1 // Simplified - would need current block height to calculate
    };
  }

  private formatDenom(denom: string | undefined): string {
    // Handle undefined/null denom
    if (!denom) {
      return 'INJ'; // Default to INJ for undefined denoms
    }

    // Convert denom to readable token symbol
    if (denom === 'inj' || denom === 'uinj') {
      return 'INJ';
    }

    // Handle other token denoms as needed
    return denom.toUpperCase();
  }

}===== ./src/blockchains/injective/providers/InjectiveLCDProvider.ts =====

import type { Balance } from '@crypto/core';
import { maskAddress, parseDecimal } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import { ProviderOperation } from '../../shared/types.ts';
import type { InjectiveBalanceResponse } from '../types.ts';

@RegisterProvider({
  name: 'injective-lcd',
  blockchain: 'injective',
  displayName: 'Injective LCD API',
  type: 'rest',
  requiresApiKey: false,
  description: 'Injective Protocol LCD (Light Client Daemon) API for balance queries and token data',
  capabilities: {
    supportedOperations: ['getAddressBalance', 'getTokenBalances'],
    maxBatchSize: 1,
    supportsHistoricalData: false,
    supportsPagination: false,
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  networks: {
    mainnet: {
      baseUrl: 'https://sentry.lcd.injective.network'
    },
    testnet: {
      baseUrl: 'https://k8s.testnet.lcd.injective.network'
    }
  },
  defaultConfig: {
    timeout: 10000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 3,
      requestsPerMinute: 100,
      requestsPerHour: 1000,
      burstLimit: 10
    }
  }
})
export class InjectiveLCDProvider extends BaseRegistryProvider {

  constructor() {
    super('injective', 'injective-lcd', 'mainnet');

    this.logger.debug(`Initialized InjectiveLCDProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a simple node info call
      const data = await this.httpClient.get('/cosmos/base/tendermint/v1beta1/node_info');

      this.logger.debug(`Health check successful - Network: ${data.default_node_info?.network}, Version: ${data.application_version?.version}`);

      return true;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      const result = await this.isHealthy();
      this.logger.debug(`Connection test result - Healthy: ${result}`);
      return result;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        case 'getTokenBalances':
          return this.getTokenBalances(operation.params as { address: string; contractAddresses?: string[] }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${operation.params}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance[]> {
    const { address } = params;

    if (!this.validateAddress(address)) {
      throw new Error(`Invalid Injective address: ${address}`);
    }

    this.logger.debug(`Fetching address balance - Address: ${maskAddress(address)}, Network: ${this.network}`);

    try {
      const endpoint = `/cosmos/bank/v1beta1/balances/${address}`;
      const data = await this.httpClient.get(endpoint) as InjectiveBalanceResponse;

      const balances: Balance[] = data.balances.map(balance => {
        const amount = parseDecimal(balance.amount).div(Math.pow(10, 18)).toNumber();
        return {
          currency: this.formatDenom(balance.denom),
          balance: amount,
          used: 0,
          total: amount,
          contractAddress: undefined
        };
      });

      this.logger.debug(`Successfully retrieved address balance - Address: ${maskAddress(address)}, BalanceCount: ${balances.length}, Network: ${this.network}`);

      return balances;

    } catch (error) {
      this.logger.error(`Failed to get address balance - Address: ${maskAddress(address)}, Network: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenBalances(params: { address: string; contractAddresses?: string[] }): Promise<Balance[]> {
    const { address, contractAddresses } = params;

    this.logger.debug(`Fetching token balances - Address: ${maskAddress(address)}, Network: ${this.network}`);

    // For Injective, all balances (including tokens) are returned by getAddressBalance
    // Token filtering by contract addresses is not directly supported in LCD API
    const allBalances = await this.getAddressBalance({ address });

    if (contractAddresses && contractAddresses.length > 0) {
      // Filter balances by contract addresses if provided
      // Note: Injective uses denoms instead of contract addresses for most tokens
      this.logger.warn(`Contract address filtering not fully supported for Injective LCD API`);
    }

    this.logger.debug(`Successfully retrieved token balances - Address: ${maskAddress(address)}, BalanceCount: ${allBalances.length}, Network: ${this.network}`);

    return allBalances;
  }

  private validateAddress(address: string): boolean {
    // Injective addresses start with 'inj' and are bech32 encoded
    const injectiveAddressRegex = /^inj1[a-z0-9]{38}$/;
    return injectiveAddressRegex.test(address);
  }

  private formatDenom(denom: string | undefined): string {
    // Handle undefined/null denom
    if (!denom) {
      return 'INJ'; // Default to INJ for undefined denoms
    }

    // Convert denom to readable token symbol
    if (denom === 'inj' || denom === 'uinj') {
      return 'INJ';
    }

    // Handle other token denoms as needed
    return denom.toUpperCase();
  }

}===== ./src/blockchains/injective/types.ts =====
export interface InjectiveApiResponse {
  data: InjectiveTransaction[];
  paging?: {
    total: number;
    from?: number;
    to?: number;
  };
}

export interface InjectiveTransaction {
  id: string;
  block_number: number;
  block_timestamp: string;
  hash: string;
  code: number;
  info: string;
  gas_wanted: number;
  gas_used: number;
  gas_fee: InjectiveGasFee;
  tx_type: string;
  messages: InjectiveMessage[];
  signatures: any[];
  memo?: string;
  timeout_height: number;
  extension_options: any[];
  non_critical_extension_options: any[];
}

export interface InjectiveMessage {
  type: string;
  value: InjectiveMessageValue;
}

export interface InjectiveMessageValue {
  from_address?: string;
  to_address?: string;
  amount?: InjectiveAmount[];
  sender?: string;
  receiver?: string;
  source_port?: string;
  source_channel?: string;
  token?: InjectiveAmount;
  timeout_height?: any;
  timeout_timestamp?: string;
  memo?: string;
}

export interface InjectiveAmount {
  denom: string;
  amount: string;
}

export interface InjectiveGasFee {
  amount: InjectiveAmount[];
  gas_limit: number;
  payer: string;
  granter: string;
}

export interface InjectiveBalance {
  denom: string;
  amount: string;
}

export interface InjectiveBalanceResponse {
  balances: InjectiveBalance[];
  pagination: {
    next_key?: string;
    total: string;
  };
}===== ./src/blockchains/injective/adapter.ts =====
import type { Balance, BlockchainInfo, BlockchainTransaction } from '@crypto/core';

import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';

export class InjectiveAdapter extends BaseBlockchainAdapter {
  private providerManager: BlockchainProviderManager;

  constructor(explorerConfig: BlockchainExplorersConfig) {
    super('injective', 'InjectiveAdapter');

    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('injective', 'mainnet');

    this.logger.info(`Initialized Injective adapter with registry-based provider manager - ProvidersCount: ${this.providerManager.getProviders('injective').length}`);
  }

  validateAddress(address: string): boolean {
    // Injective addresses start with 'inj' and are bech32 encoded
    const injectiveAddressRegex = /^inj1[a-z0-9]{38}$/;
    return injectiveAddressRegex.test(address);
  }

  async testConnection(): Promise<boolean> {
    try {
      // Test connection through provider manager
      const healthStatus = this.providerManager.getProviderHealth('injective');
      const hasHealthyProvider = Array.from(healthStatus.values()).some(health =>
        health.isHealthy && health.circuitState !== 'OPEN'
      );

      this.logger.info(`Injective provider connection test result - HasHealthyProvider: ${hasHealthyProvider}, TotalProviders: ${healthStatus.size}`);

      return hasHealthyProvider;
    } catch (error) {
      this.logger.error(`Injective connection test failed - Error: ${error}`);
      return false;
    }
  }


  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: 'injective',
      name: 'Injective Protocol Blockchain',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: true,
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    if (!this.validateAddress(address)) {
      throw new Error(`Invalid Injective address: ${address}`);
    }

    this.logger.info(`InjectiveAdapter: Fetching transactions for address: ${address.substring(0, 20)}...`);

    try {
      // Fetch regular INJ transactions
      const regularTxs = await this.providerManager.executeWithFailover('injective', {
        type: 'getAddressTransactions',
        params: { address, since },
        getCacheKey: (params: any) => `inj_tx_${params.address}_${params.since || 'all'}`
      }) as BlockchainTransaction[];

      // Try to fetch token transactions (if provider supports it)
      // Note: In Injective, tokens are represented as different denoms, not separate contracts
      let tokenTxs: BlockchainTransaction[] = [];
      try {
        tokenTxs = await this.providerManager.executeWithFailover('injective', {
          type: 'getTokenTransactions',
          params: { address, since },
          getCacheKey: (params: any) => `inj_token_tx_${params.address}_${params.since || 'all'}`
        }) as BlockchainTransaction[];
      } catch (error) {
        this.logger.debug(`Provider does not support separate token transactions or failed to fetch - Error: ${error instanceof Error ? error.message : String(error)}`);
        // Continue without separate token transactions - provider may already include them in getAddressTransactions
      }

      this.logger.info(`InjectiveAdapter transaction breakdown for ${address.substring(0, 20)}... - Regular: ${regularTxs.length}, Token: ${tokenTxs.length}, Total: ${regularTxs.length + tokenTxs.length}`);

      // Combine all transactions (following the same pattern as other adapters)
      const allTransactions = [...regularTxs, ...tokenTxs];

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      // Remove any duplicate transactions (by hash)
      const uniqueTransactions = allTransactions.reduce((acc, tx) => {
        if (!acc.find((existing: any) => existing.hash === tx.hash)) {
          acc.push(tx);
        }
        return acc;
      }, [] as BlockchainTransaction[]);

      this.logger.info(`InjectiveAdapter: Found ${uniqueTransactions.length} unique transactions for address ${address.substring(0, 20)}...`);
      return uniqueTransactions;

    } catch (error) {
      this.logger.error(`Failed to fetch transactions for ${address} - Error: ${error}`);
      throw error;
    }
  }

  async getAddressBalance(address: string): Promise<Balance[]> {
    if (!this.validateAddress(address)) {
      throw new Error(`Invalid Injective address: ${address}`);
    }

    this.logger.info(`Getting balance for address: ${address.substring(0, 20)}...`);

    try {
      // Use provider manager to fetch balance with failover
      const balances = await this.providerManager.executeWithFailover('injective', {
        type: 'getAddressBalance',
        params: { address },
        getCacheKey: (params: any) => `inj_balance_${params.address}`
      }) as Balance[];

      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch balance for ${address} - Error: ${error}`);
      throw error;
    }
  }

  async getTokenTransactions(address: string, tokenContract?: string): Promise<BlockchainTransaction[]> {
    // For Injective, tokens are represented as different denoms, not contracts
    // This method can be used to filter transactions by specific token denom
    const allTransactions = await this.getAddressTransactions(address);

    if (tokenContract) {
      return allTransactions.filter(tx =>
        tx.tokenContract === tokenContract ||
        tx.tokenSymbol === tokenContract
      );
    }

    return allTransactions;
  }

  async getTokenBalances(address: string): Promise<Balance[]> {
    // For Injective, all balances are returned by getAddressBalance
    return this.getAddressBalance(address);
  }



  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info('Injective adapter closed successfully');
    } catch (error) {
      this.logger.warn(`Error during Injective adapter close - Error: ${error}`);
    }
  }
}===== ./src/blockchains/polkadot/providers/SubstrateProvider.ts =====
import { Decimal } from 'decimal.js';

import type { Balance, BlockchainTransaction } from '@crypto/core';
import { createMoney, maskAddress } from '@crypto/shared-utils';

import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/decorators.ts';
import type { SubstrateAccountInfo, SubstrateChainConfig } from '../types.ts';
import { SUBSTRATE_CHAINS } from '../types.ts';

import { ProviderOperation } from '../../shared/types.ts';
import { isValidSS58Address } from '../utils.ts';

@RegisterProvider({
  name: 'subscan',
  blockchain: 'polkadot',
  displayName: 'Substrate Networks Provider',
  type: 'rest',
  requiresApiKey: false,
  description: 'Multi-chain Substrate provider supporting Polkadot, Kusama, and Bittensor networks with explorer APIs and RPC fallback',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance'],
    maxBatchSize: 1,
    supportsHistoricalData: true,
    supportsPagination: true,
    supportsRealTimeData: true,
    supportsTokenData: false // Substrate native tokens only for now
  },
  networks: {
    mainnet: {
      baseUrl: 'https://polkadot.api.subscan.io'
    },
    testnet: {
      baseUrl: 'https://westend.api.subscan.io'
    }
  },
  defaultConfig: {
    timeout: 10000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 1,
      requestsPerMinute: 30,
      requestsPerHour: 500,
      burstLimit: 3
    }
  }
})
export class SubstrateProvider extends BaseRegistryProvider {
  private readonly chainConfig: SubstrateChainConfig;
  private readonly rpcClient?: any; // TODO: Implement proper RPC client if needed

  constructor() {
    super('polkadot', 'subscan', 'mainnet'); // Subscan provider for Polkadot

    // Initialize chain config for Polkadot by default
    const chainConfig = SUBSTRATE_CHAINS['polkadot'];
    if (!chainConfig) {
      throw new Error('Substrate chain configuration not found');
    }

    this.chainConfig = chainConfig;

    this.logger.debug(`Initialized SubstrateProvider from registry metadata - Network: ${this.network}, BaseUrl: ${this.baseUrl}, DisplayName: ${chainConfig.displayName}, TokenSymbol: ${chainConfig.tokenSymbol}, Ss58Format: ${chainConfig.ss58Format}`);
  }

  /**
   * Set the specific substrate chain (polkadot, kusama, bittensor)
   */
  setChain(chain: string): void {
    const chainConfig = SUBSTRATE_CHAINS[chain];
    if (!chainConfig) {
      throw new Error(`Unsupported Substrate chain: ${chain}`);
    }

    // Update the chain config
    (this as any).chainConfig = chainConfig;

    // Update network and base URL based on chain
    const networkUrls: Record<string, string> = {
      polkadot: 'https://polkadot.api.subscan.io',
      kusama: 'https://kusama.api.subscan.io',
      bittensor: 'https://api.taostats.io'
    };

    const baseUrl = networkUrls[chain];
    if (baseUrl) {
      (this as any).network = chain;
      (this as any).baseUrl = baseUrl;

      // Reinitialize HTTP client with new base URL
      (this as any).httpClient = this.initializeHttpClient(baseUrl);
    }

    this.logger.debug(`Switched to ${chain} chain - DisplayName: ${chainConfig.displayName}, TokenSymbol: ${chainConfig.tokenSymbol}, BaseUrl: ${this.baseUrl}`);
  }

  /**
   * Initialize HTTP client with custom base URL
   */
  private initializeHttpClient(baseUrl: string): any {
    const { HttpClient } = require('../../utils/http-client');
    return new HttpClient({
      baseUrl,
      timeout: 10000,
      retries: 3,
      rateLimit: {
        requestsPerSecond: 1,
        requestsPerMinute: 30,
        requestsPerHour: 500,
        burstLimit: 3
      },
      providerName: this.name,
      defaultHeaders: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    });
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Try explorer API first if available
      if (this.httpClient) {
        const response = await this.testExplorerApi();
        if (response) return true;
      }

      // Fallback to RPC if available
      if (this.rpcClient) {
        const response = await this.testRpcConnection();
        if (response) return true;
      }

      return false;
    } catch (error) {
      this.logger.warn(`Health check failed - Chain: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    return this.isHealthy();
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    this.logger.debug(`Executing operation - Type: ${operation.type}, Address: ${operation.params?.address ? maskAddress(operation.params.address) : 'N/A'}`);

    try {
      switch (operation.type) {
        case 'getAddressTransactions':
          return this.getAddressTransactions(operation.params as { address: string; since?: number }) as T;
        case 'getAddressBalance':
          return this.getAddressBalance(operation.params as { address: string }) as T;
        default:
          throw new Error(`Unsupported operation: ${operation.type}`);
      }
    } catch (error) {
      this.logger.error(`Operation execution failed - Type: ${operation.type}, Params: ${JSON.stringify(operation.params)}, Error: ${error instanceof Error ? error.message : String(error)}, Stack: ${error instanceof Error ? error.stack : undefined}`);
      throw error;
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;
    if (!isValidSS58Address(address)) {
      throw new Error(`Invalid SS58 address for ${this.blockchain}: ${address}`);
    }

    try {
      this.logger.debug(`Fetching transactions for ${this.network} address: ${maskAddress(address)}`);

      // Try explorer API first
      if (this.httpClient) {
        try {
          const transactions = await this.getTransactionsFromExplorer(address, since);
          if (transactions.length > 0) {
            return transactions;
          }
        } catch (error) {
          this.logger.warn(`Explorer API failed, trying RPC fallback - Error: ${error}`);
        }
      }

      // Fallback to RPC if available
      if (this.rpcClient) {
        return await this.getTransactionsFromRPC(address, since);
      }

      this.logger.warn('No available data sources for transactions');
      return [];

    } catch (error) {
      this.logger.error(`Failed to fetch transactions for ${this.network} address - Address: ${maskAddress(address)}, Error: ${error}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance[]> {
    const { address } = params;
    if (!isValidSS58Address(address)) {
      throw new Error(`Invalid SS58 address for ${this.blockchain}: ${address}`);
    }

    try {
      this.logger.debug(`Fetching balance for ${this.network} address: ${maskAddress(address)}`);

      // Try RPC first for most accurate balance
      if (this.rpcClient) {
        try {
          const balance = await this.getBalanceFromRPC(address);
          if (balance) {
            return [balance];
          }
        } catch (error) {
          this.logger.warn(`RPC balance query failed, trying explorer API - Error: ${error}`);
        }
      }

      // Fallback to explorer API
      if (this.httpClient) {
        const balance = await this.getBalanceFromExplorer(address);
        if (balance) {
          return [balance];
        }
      }

      this.logger.warn('No available data sources for balance');
      return [];

    } catch (error) {
      this.logger.error(`Failed to fetch balance for ${this.network} address - Address: ${maskAddress(address)}, Error: ${error}`);
      throw error;
    }
  }

  private async testExplorerApi(): Promise<boolean> {
    try {
      // Use Subscan's metadata endpoint for health check - it's available on all Subscan APIs
      const response = await this.httpClient.post('/api/scan/metadata', {});
      return response && response.code === 0;
    } catch (error) {
      this.logger.debug(`Explorer API health check failed - Chain: ${this.network}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  private async testRpcConnection(): Promise<boolean> {
    if (!this.rpcClient) return false;

    try {
      const response = await this.rpcClient.post('', {
        id: 1,
        jsonrpc: '2.0',
        method: 'system_properties',
        params: []
      });

      return response && response.result;
    } catch (error) {
      return false;
    }
  }

  private async getTransactionsFromExplorer(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const transactions: BlockchainTransaction[] = [];

    if (this.network === 'bittensor') {
      // Taostats API implementation
      try {
        const response = await this.httpClient.get(`/api/account/${address}/transactions`);
        if (response && response.data) {
          for (const tx of response.data) {
            const blockchainTx = this.convertTaostatsTransaction(tx, address);
            if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
              transactions.push(blockchainTx);
            }
          }
        }
      } catch (error) {
        this.logger.debug(`Taostats API transaction fetch failed - Error: ${error}`);
      }
    } else if (this.network === 'polkadot' || this.network === 'kusama') {
      // Subscan API implementation
      try {
        this.logger.debug(`Calling Subscan API for ${this.network} transactions - Address: ${maskAddress(address)}`);

        const response = await this.httpClient.post('/api/v2/scan/transfers', {
          address: address,
          page: 0,
          row: 100
        });

        this.logger.debug(`Subscan API response received - HasResponse: ${!!response}, Code: ${response?.code}, HasData: ${!!response?.data}, TransferCount: ${response?.data?.transfers?.length || 0}`);

        if (response && response.code === 0 && response.data && response.data.transfers) {
          for (const transfer of response.data.transfers) {
            this.logger.debug(`Processing transfer - From: ${transfer.from}, To: ${transfer.to}, UserAddress: ${maskAddress(address)}, Amount: ${transfer.amount}`);

            const blockchainTx = this.convertSubscanTransaction(transfer, address);
            this.logger.debug(`Converted transaction result - HasTransaction: ${!!blockchainTx}, Since: ${since}, TxTimestamp: ${blockchainTx?.timestamp}`);

            if (blockchainTx && (!since || blockchainTx.timestamp >= since)) {
              transactions.push(blockchainTx);
            }
          }
        }
      } catch (error) {
        this.logger.warn(`Subscan API transaction fetch failed - Error: ${error instanceof Error ? error.message : String(error)}, Blockchain: ${this.network}`);
      }
    }

    this.logger.debug(`Found ${transactions.length} transactions via explorer API for ${this.network}`);
    return transactions;
  }

  private async getTransactionsFromRPC(_address: string, _since?: number): Promise<BlockchainTransaction[]> {
    // RPC-based transaction fetching is more complex and would require
    // iterating through blocks and filtering extrinsics
    // For now, return empty array as fallback
    this.logger.debug('RPC transaction fetching not implemented yet');
    return [];
  }

  private async getBalanceFromRPC(address: string): Promise<Balance | null> {
    if (!this.rpcClient) return null;

    try {
      const response = await this.rpcClient.post('', {
        id: 1,
        jsonrpc: '2.0',
        method: 'system_account',
        params: [address]
      });

      if (response && response.result) {
        const accountInfo = response.result as SubstrateAccountInfo;
        const freeBalance = new Decimal(accountInfo.data.free);
        const reservedBalance = new Decimal(accountInfo.data.reserved);
        const totalBalance = freeBalance.plus(reservedBalance);

        // Convert from smallest unit to main unit using chain decimals
        const divisor = new Decimal(10).pow(this.chainConfig.tokenDecimals);
        const balanceInMainUnit = totalBalance.dividedBy(divisor);
        const freeInMainUnit = freeBalance.dividedBy(divisor);
        const reservedInMainUnit = reservedBalance.dividedBy(divisor);

        return {
          currency: this.chainConfig.tokenSymbol,
          balance: freeInMainUnit.toNumber(),
          used: reservedInMainUnit.toNumber(),
          total: balanceInMainUnit.toNumber()
        };
      }

      return null;
    } catch (error) {
      this.logger.debug(`RPC balance query failed - Address: ${maskAddress(address)}, Error: ${error}`);
      return null;
    }
  }

  private async getBalanceFromExplorer(address: string): Promise<Balance | null> {
    try {
      if (this.network === 'bittensor') {
        // Taostats balance endpoint
        const response = await this.httpClient.get(`/api/account/${address}/balance`);
        if (response && response.balance !== undefined) {
          const balance = new Decimal(response.balance);
          return {
            currency: 'TAO',
            balance: balance.toNumber(),
            used: 0, // Taostats might not provide reserved balance
            total: balance.toNumber()
          };
        }
      } else {
        // Subscan balance endpoint
        const response = await this.httpClient.post('/api/scan/account', {
          key: address
        });

        if (response && response.code === 0 && response.data) {
          const freeBalance = new Decimal(response.data.balance || '0');
          const reservedBalance = new Decimal(response.data.reserved || '0');
          const totalBalance = freeBalance.plus(reservedBalance);

          const divisor = new Decimal(10).pow(this.chainConfig.tokenDecimals);
          const balanceInMainUnit = totalBalance.dividedBy(divisor);
          const freeInMainUnit = freeBalance.dividedBy(divisor);
          const reservedInMainUnit = reservedBalance.dividedBy(divisor);

          return {
            currency: this.chainConfig.tokenSymbol,
            balance: freeInMainUnit.toNumber(),
            used: reservedInMainUnit.toNumber(),
            total: balanceInMainUnit.toNumber()
          };
        }
      }

      return null;
    } catch (error) {
      this.logger.debug(`Explorer balance query failed - Address: ${maskAddress(address)}, Error: ${error}`);
      return null;
    }
  }

  private convertTaostatsTransaction(tx: any, userAddress: string): BlockchainTransaction | null {
    try {
      const isFromUser = tx.from === userAddress;
      const isToUser = tx.to === userAddress;

      if (!isFromUser && !isToUser) {
        return null; // Not relevant to this address
      }

      const amount = new Decimal(tx.amount || '0');
      const fee = new Decimal(tx.fee || '0');

      const type = isFromUser ? 'transfer_out' : 'transfer_in';

      return {
        hash: tx.hash,
        blockNumber: tx.block_number || 0,
        blockHash: tx.block_hash || '',
        timestamp: new Date(tx.timestamp).getTime(),
        from: tx.from,
        to: tx.to,
        value: createMoney(amount.toNumber(), 'TAO'),
        fee: createMoney(fee.toNumber(), 'TAO'),
        status: tx.success ? 'success' : 'failed',
        type,
        confirmations: tx.confirmations || 1
      };
    } catch (error) {
      this.logger.warn(`Failed to convert Taostats transaction - Tx: ${JSON.stringify(tx)}, Error: ${error}`);
      return null;
    }
  }

  private convertSubscanTransaction(transfer: any, userAddress: string): BlockchainTransaction | null {
    try {
      const isFromUser = transfer.from === userAddress;
      const isToUser = transfer.to === userAddress;

      this.logger.debug(`Checking transaction relevance - From: ${transfer.from}, To: ${transfer.to}, UserAddress: ${maskAddress(userAddress)}, IsFromUser: ${isFromUser}, IsToUser: ${isToUser}`);

      if (!isFromUser && !isToUser) {
        this.logger.debug('Transaction not relevant to user address');
        return null; // Not relevant to this address
      }

      const amount = new Decimal(transfer.amount || '0');
      const divisor = new Decimal(10).pow(this.chainConfig.tokenDecimals);
      const amountInMainUnit = amount.dividedBy(divisor);

      const fee = new Decimal(transfer.fee || '0');
      const feeInMainUnit = fee.dividedBy(divisor);

      const type = isFromUser ? 'transfer_out' : 'transfer_in';

      return {
        hash: transfer.hash,
        blockNumber: transfer.block_num || 0,
        blockHash: transfer.block_hash || '',
        timestamp: transfer.block_timestamp * 1000, // Convert to milliseconds
        from: transfer.from,
        to: transfer.to,
        value: createMoney(amountInMainUnit.toNumber(), this.chainConfig.tokenSymbol),
        fee: createMoney(feeInMainUnit.toNumber(), this.chainConfig.tokenSymbol),
        status: transfer.success ? 'success' : 'failed',
        type,
        confirmations: 1
      };
    } catch (error) {
      this.logger.warn(`Failed to convert Subscan transaction - Transfer: ${JSON.stringify(transfer)}, Error: ${error}`);
      return null;
    }
  }

}===== ./src/blockchains/polkadot/utils.ts =====
// Address validation for SS58 format
export function isValidSS58Address(address: string, ss58Format?: number): boolean {
  // Basic SS58 address validation - starts with specific prefix based on network
  // This is a simplified version - in production you'd want to use @polkadot/util-crypto
  const ss58Regex = /^[1-9A-HJ-NP-Za-km-z]{47,48}$/;
  return ss58Regex.test(address);
}

// Convert between different SS58 formats if needed
export function encodeAddress(publicKey: Uint8Array, ss58Format: number): string {
  // This would typically use @polkadot/util-crypto's encodeAddress
  // For now, return placeholder - implement with proper SS58 encoding library
  throw new Error('SS58 encoding not implemented - use @polkadot/util-crypto');
}===== ./src/blockchains/polkadot/types.ts =====
// Substrate provider-specific API response types
// Chain-specific configurations
export interface SubstrateChainConfig {
  name: string;
  displayName: string;
  chainId?: string;
  ss58Format: number;
  tokenSymbol: string;
  tokenDecimals: number;
  rpcEndpoints: string[];
  explorerUrls: string[];
  explorerApiUrl?: string;
  apiKey?: string;
  genesisHash?: string;
}

// Supported Substrate chains
export const SUBSTRATE_CHAINS: { [key: string]: SubstrateChainConfig } = {
  polkadot: {
    name: 'polkadot',
    displayName: 'Polkadot Relay Chain',
    ss58Format: 0,
    tokenSymbol: 'DOT',
    tokenDecimals: 10,
    rpcEndpoints: [
      'wss://rpc.polkadot.io',
      'wss://polkadot.api.onfinality.io/public-ws',
      'wss://polkadot-rpc.dwellir.com'
    ],
    explorerUrls: [
      'https://polkadot.subscan.io',
      'https://polkadot.js.org/apps'
    ],
    explorerApiUrl: 'https://polkadot.api.subscan.io',
    genesisHash: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3'
  },
  kusama: {
    name: 'kusama',
    displayName: 'Kusama Relay Chain',
    ss58Format: 2,
    tokenSymbol: 'KSM',
    tokenDecimals: 12,
    rpcEndpoints: [
      'wss://kusama-rpc.polkadot.io',
      'wss://kusama.api.onfinality.io/public-ws',
      'wss://kusama-rpc.dwellir.com'
    ],
    explorerUrls: [
      'https://kusama.subscan.io',
      'https://polkadot.js.org/apps/?rpc=wss://kusama-rpc.polkadot.io#/explorer'
    ],
    explorerApiUrl: 'https://kusama.api.subscan.io',
    genesisHash: '0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe'
  },
  bittensor: {
    name: 'bittensor',
    displayName: 'Bittensor Network',
    ss58Format: 42,
    tokenSymbol: 'TAO',
    tokenDecimals: 9,
    rpcEndpoints: [
      'wss://entrypoint-finney.opentensor.ai:443',
      'wss://bittensor-finney.api.onfinality.io/public-ws'
    ],
    explorerUrls: [
      'https://taostats.io',
      'https://bittensor.com/scan'
    ],
    explorerApiUrl: 'https://taostats.io/api',
    genesisHash: '0x5c0d1176a568c1f92944340dbfed9e9c530ebca703c85910e7164cb7d1c9e47b'
  }
};

export interface SubstrateTransaction {
  hash: string;
  blockNumber: number;
  blockHash: string;
  timestamp: number;
  from: string;
  to?: string;
  amount: string;
  fee: string;
  success: boolean;
  module: string;
  call: string;
  args?: any;
  events?: SubstrateEvent[];
}

export interface SubstrateEvent {
  method: string;
  section: string;
  data: any[];
}

export interface SubstrateExtrinsic {
  hash: string;
  method: string;
  section: string;
  args: any;
  signer: string;
  nonce: number;
  signature: string;
  tip: string;
  success: boolean;
  error?: {
    module: string;
    name: string;
    docs: string[];
  };
}

export interface SubstrateBalance {
  free: string;
  reserved: string;
  frozen: string;
  total: string;
}

export interface SubstrateAccountInfo {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: SubstrateBalance;
}

export interface SubstrateBlock {
  hash: string;
  number: number;
  parentHash: string;
  timestamp: number;
  extrinsics: SubstrateExtrinsic[];
  events: SubstrateEvent[];
}

// Substrate RPC methods
export interface SubstrateRPCMethods {
  // System methods
  'system_account': (address: string) => Promise<SubstrateAccountInfo>;
  'system_properties': () => Promise<{
    ss58Format: number;
    tokenDecimals: number[];
    tokenSymbol: string[];
  }>;
  
  // Chain methods
  'chain_getBlock': (blockHash?: string) => Promise<any>;
  'chain_getBlockHash': (blockNumber?: number) => Promise<string>;
  'chain_getFinalizedHead': () => Promise<string>;
  
  // State methods
  'state_getStorage': (key: string, blockHash?: string) => Promise<string>;
  'state_call': (method: string, data: string, blockHash?: string) => Promise<string>;
}

// Substrate transaction types
export type SubstrateTransactionType = 
  | 'transfer'
  | 'transfer_keep_alive' 
  | 'force_transfer'
  | 'staking_bond'
  | 'staking_unbond'
  | 'staking_withdraw_unbonded'
  | 'staking_nominate'
  | 'staking_chill'
  | 'democracy_vote'
  | 'council_vote'
  | 'treasury_propose'
  | 'utility_batch'
  | 'proxy_proxy'
  | 'identity_set_identity'
  | 'multisig_approve_as_multi'
  | 'vesting_vest'
  | 'session_set_keys'
  | 'custom';

// Parse Substrate method to transaction type
export function parseSubstrateTransactionType(module: string, method: string): SubstrateTransactionType {
  const key = `${module}_${method}`.toLowerCase();
  
  switch (key) {
    case 'balances_transfer':
    case 'balances_transfer_all':
      return 'transfer';
    case 'balances_transfer_keep_alive':
      return 'transfer_keep_alive';
    case 'balances_force_transfer':
      return 'force_transfer';
    case 'staking_bond':
      return 'staking_bond';
    case 'staking_unbond':
      return 'staking_unbond';
    case 'staking_withdraw_unbonded':
      return 'staking_withdraw_unbonded';
    case 'staking_nominate':
      return 'staking_nominate';
    case 'staking_chill':
      return 'staking_chill';
    case 'utility_batch':
      return 'utility_batch';
    default:
      return 'custom';
  }
}===== ./src/blockchains/polkadot/adapter.ts =====


import type { Balance, BlockchainInfo, BlockchainTransaction } from '@crypto/core';
import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';
import { SUBSTRATE_CHAINS, type SubstrateChainConfig } from './types.ts';

export class SubstrateAdapter extends BaseBlockchainAdapter {
  private chainConfig: SubstrateChainConfig;
  private providerManager: BlockchainProviderManager;

  constructor(explorerConfig: BlockchainExplorersConfig) {
    super('polkadot', 'SubstrateAdapter');

    // Always use Polkadot mainnet as default
    this.chainConfig = SUBSTRATE_CHAINS.polkadot!;

    // Create and initialize provider manager with registry
    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('polkadot', 'mainnet');

    this.logger.info(`Initialized Substrate adapter with registry-based provider manager - Chain: ${this.chainConfig.name}, DisplayName: ${this.chainConfig.displayName}, TokenSymbol: ${this.chainConfig.tokenSymbol}, SS58Format: ${this.chainConfig.ss58Format}, ProvidersCount: ${this.providerManager.getProviders('polkadot').length}`);
  }


  async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    this.logger.info(`SubstrateAdapter: Fetching transactions for address: ${address.substring(0, 20)}...`);
    this.logger.debug(`SubstrateAdapter.getAddressTransactions called - Address: ${address}, Since: ${since}, Chain: ${this.chainConfig.name}`);

    try {
      // Use provider manager to fetch transactions with failover
      const transactions = await this.providerManager.executeWithFailover('polkadot', {
        type: 'getAddressTransactions',
        params: { address, since },
        getCacheKey: (params: any) => `${this.chainConfig.name}_tx_${params.address}_${params.since || 'all'}`
      }) as BlockchainTransaction[];

      this.logger.info(`SubstrateAdapter: Found ${transactions.length} transactions for ${this.chainConfig.name} address`);
      return transactions;

    } catch (error) {
      this.logger.error(`Failed to fetch address transactions via provider manager - Address: ${address}, Chain: ${this.chainConfig.name}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  async getAddressBalance(address: string): Promise<Balance[]> {
    this.logger.debug(`SubstrateAdapter.getAddressBalance called - Address: ${address}, Chain: ${this.chainConfig.name}`);

    try {
      // Use provider manager to fetch balance with failover
      const balances = await this.providerManager.executeWithFailover('polkadot', {
        type: 'getAddressBalance',
        params: { address },
        getCacheKey: (params: any) => `${this.chainConfig.name}_balance_${params.address}`
      }) as Balance[];

      this.logger.info(`SubstrateAdapter: Found ${balances.length} balances for ${this.chainConfig.name} address`);
      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch address balance via provider manager - Address: ${address}, Chain: ${this.chainConfig.name}, Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  validateAddress(address: string): boolean {
    // Basic SS58 address validation - could be enhanced with proper SS58 library
    const ss58Regex = /^[1-9A-HJ-NP-Za-km-z]{47,48}$/;
    const isValid = ss58Regex.test(address);

    this.logger.debug(`Address validation - Address: ${address}, IsValid: ${isValid}, Chain: ${this.chainConfig.name}, SS58Format: ${this.chainConfig.ss58Format}`);
    return isValid;
  }

  async testConnection(): Promise<boolean> {
    this.logger.debug(`SubstrateAdapter.testConnection called - Chain: ${this.chainConfig.name}`);

    try {
      // Test connection using provider manager
      const providers = this.providerManager.getProviders('polkadot');
      if (providers.length === 0) {
        this.logger.warn(`No polkadot providers available for connection test`);
        return false;
      }

      // Test the first healthy provider
      for (const provider of providers) {
        try {
          const isHealthy = await provider.isHealthy();
          if (isHealthy) {
            this.logger.info(`Connection test successful with provider: ${provider.name}`);
            return true;
          }
        } catch (error) {
          this.logger.debug(`Provider ${provider.name} failed health check - Error: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      this.logger.warn(`All polkadot providers failed connection test`);
      return false;

    } catch (error) {
      this.logger.error(`Connection test failed - Chain: ${this.chainConfig.name}, Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: this.chainConfig.name,
      name: this.chainConfig.displayName,
      network: this.chainConfig.name,
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: false, // Substrate native tokens only for now
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  // Substrate chains don't typically have separate token transactions like EVM chains
  // They use native token transfers within extrinsics
  async getTokenTransactions(address: string, tokenContract?: string): Promise<BlockchainTransaction[]> {
    this.logger.debug(`SubstrateAdapter.getTokenTransactions called - Address: ${address}, TokenContract: ${tokenContract}, Chain: ${this.chainConfig.name}`);

    // For now, return regular transactions as Substrate chains primarily use native tokens
    // In the future, this could be extended to support parachains with custom tokens
    this.logger.info('Token transactions not implemented for Substrate chains - returning regular transactions');
    return this.getAddressTransactions(address);
  }

  async getTokenBalances(address: string): Promise<Balance[]> {
    this.logger.debug(`SubstrateAdapter.getTokenBalances called - Address: ${address}, Chain: ${this.chainConfig.name}`);

    // For now, return regular balance as Substrate chains primarily use native tokens
    this.logger.info('Token balances not implemented for Substrate chains - returning regular balance');
    return this.getAddressBalance(address);
  }

  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info(`${this.chainConfig.displayName} adapter closed successfully`);
    } catch (error) {
      this.logger.warn(`Error during ${this.chainConfig.displayName} adapter close - Error: ${error}`);
    }
  }
}===== ./src/blockchains/ethereum/providers/EtherscanProvider.ts =====
import { Decimal } from 'decimal.js';

import type { Balance, BlockchainTransaction } from '@crypto/core';
import { ServiceError } from '@crypto/core';
import { createMoney } from '@crypto/shared-utils';
import { BaseRegistryProvider } from '../../shared/registry/base-registry-provider.ts';
import { RegisterProvider } from '../../shared/registry/index.ts';
import type { ProviderOperation } from '../../shared/types.ts';
import type { EtherscanInternalTransaction, EtherscanTokenTransfer, EtherscanTransaction } from '../types.ts';

@RegisterProvider({
  name: 'etherscan',
  blockchain: 'ethereum',
  displayName: 'Etherscan API',
  description: 'Official Ethereum blockchain explorer API with comprehensive transaction data',
  requiresApiKey: true,
  type: 'rest',
  apiKeyEnvVar: 'ETHERSCAN_API_KEY',
  capabilities: {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 1, // Etherscan doesn't support batch operations
    supportsHistoricalData: true,
    supportsPagination: true,
    maxLookbackDays: undefined, // No limit
    supportsRealTimeData: true,
    supportsTokenData: true
  },
  defaultConfig: {
    timeout: 15000,
    retries: 3,
    rateLimit: {
      requestsPerSecond: 0.2,
      requestsPerMinute: 30,
      requestsPerHour: 100,
      burstLimit: 1
    }
  },
  networks: {
    mainnet: {
      baseUrl: 'https://api.etherscan.io/api'
    },
    testnet: {
      baseUrl: 'https://api-goerli.etherscan.io/api'
    }
  }
})
export class EtherscanProvider extends BaseRegistryProvider {
  constructor() {
    super('ethereum', 'etherscan', 'mainnet');
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a simple API call to check chain status
      const response = await this.httpClient.get(`?module=proxy&action=eth_blockNumber&apikey=${this.apiKey}`);
      this.logger.debug(`Health check response`);

      // For proxy calls, success is indicated by having a result, not status='1'
      return response && response.result;
    } catch (error) {
      this.logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    switch (operation.type) {
      case 'getAddressTransactions':
        return this.getAddressTransactions(operation.params as { address: string; since?: number }) as Promise<T>;
      case 'getAddressBalance':
        return this.getAddressBalance(operation.params as { address: string }) as Promise<T>;
      case 'getTokenTransactions':
        return this.getTokenTransactions(operation.params as { address: string; contractAddress?: string; since?: number }) as Promise<T>;
      case 'getTokenBalances':
        return this.getTokenBalances(operation.params as { address: string; contractAddresses?: string[] }) as Promise<T>;
      default:
        throw new ServiceError(`Unsupported operation: ${operation.type}`, 'EtherscanProvider', operation.type);
    }
  }

  private async getAddressTransactions(params: { address: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, since } = params;

    this.validateApiKey();

    try {
      // Fetch only regular transactions (normal + internal)
      // Token transactions are handled separately via getTokenTransactions
      const normalTxs = await this.fetchNormalTransactions(address, since);

      const internalTxs = await this.fetchInternalTransactions(address, since);

      this.logger.debug(`Regular transaction breakdown for ${address} - Normal: ${normalTxs.length}, Internal: ${internalTxs.length}, Total: ${normalTxs.length + internalTxs.length}`);

      const allTransactions = [...normalTxs, ...internalTxs];

      // Sort by timestamp
      allTransactions.sort((a, b) => a.timestamp - b.timestamp);

      // Filter to only include transactions relevant to this address
      const relevantTransactions = allTransactions.filter(tx =>
        this.isTransactionRelevant(tx, address)
      );

      this.logger.debug(`Found ${relevantTransactions.length} relevant regular transactions for ${address}`);
      return relevantTransactions;

    } catch (error) {
      this.logger.error(`Failed to fetch regular transactions for ${address}`);
      throw error;
    }
  }

  private async getAddressBalance(params: { address: string }): Promise<Balance[]> {
    const { address } = params;

    // Get ETH balance
    const ethBalance = await this.getEthBalance(address);

    // Note: Getting all token balances requires knowing which tokens to check
    // For now, just return ETH balance
    return [ethBalance];
  }

  private async getTokenTransactions(params: { address: string; contractAddress?: string; since?: number }): Promise<BlockchainTransaction[]> {
    const { address, contractAddress, since } = params;
    return this.fetchTokenTransfers(address, since, contractAddress);
  }

  private async getTokenBalances(_params: { address: string; contractAddresses?: string[] }): Promise<Balance[]> {
    // This would require specific token contract addresses
    // For now, return empty array as this is typically used with specific tokens
    return [];
  }

  private async fetchNormalTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const startblock = since ? Math.floor(since / 1000) : 0;
    const url = `?module=account&action=txlist&address=${address}&startblock=${startblock}&endblock=99999999&page=1&offset=10000&sort=asc&apikey=${this.apiKey}`;

    const response = await this.httpClient.get(url);

    if (response.status !== '1') {
      if (response.message === 'No transactions found') {
        return [];
      }
      throw new ServiceError(`Etherscan API error: ${response.message}`, 'EtherscanProvider', 'fetchNormalTransactions');
    }

    return response.result.map((tx: EtherscanTransaction) => this.convertNormalTransaction(tx, address));
  }

  private async fetchInternalTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const startblock = since ? Math.floor(since / 1000) : 0;
    const url = `?module=account&action=txlistinternal&address=${address}&startblock=${startblock}&endblock=99999999&page=1&offset=10000&sort=asc&apikey=${this.apiKey}`;

    const response = await this.httpClient.get(url);

    if (response.status !== '1') {
      this.logger.debug(`Internal transactions response not OK: - Status: ${response.status}, Message: ${response.message}`);
      if (response.message === 'No transactions found' || response.message === 'NOTOK') {
        this.logger.debug(`No internal transactions found: ${response.message}`);
        return [];
      }
      throw new ServiceError(`Etherscan API error: ${response.message}`, 'EtherscanProvider', 'fetchInternalTransactions');
    }

    return response.result.map((tx: EtherscanInternalTransaction) => this.convertInternalTransaction(tx, address));
  }

  private async fetchTokenTransfers(address: string, since?: number, contractAddress?: string): Promise<BlockchainTransaction[]> {
    let url = `?module=account&action=tokentx&address=${address}`;

    if (contractAddress) {
      url += `&contractaddress=${contractAddress}`;
    }

    const startblock = since ? Math.floor(since / 1000) : 0;
    url += `&startblock=${startblock}&endblock=99999999&page=1&offset=10000&sort=asc&apikey=${this.apiKey}`;

    const response = await this.httpClient.get(url);

    if (response.status !== '1') {
      this.logger.debug(`Token transfers response not OK: - Status: ${response.status}, Message: ${response.message}`);
      if (response.message === 'No transactions found' || response.message === 'NOTOK') {
        this.logger.debug(`No token transfers found: ${response.message}`);
        return [];
      }
      throw new ServiceError(`Etherscan API error: ${response.message}`, 'EtherscanProvider', 'fetchTokenTransfers');
    }

    return response.result.map((tx: EtherscanTokenTransfer) => this.convertTokenTransfer(tx, address));
  }

  private async getEthBalance(address: string): Promise<Balance> {
    const url = `?module=account&action=balance&address=${address}&tag=latest&apikey=${this.apiKey}`;
    const response = await this.httpClient.get(url);

    if (response.status !== '1') {
      throw new ServiceError(`Etherscan API error: ${response.message}`, 'EtherscanProvider', 'getEthBalance');
    }

    // Convert from wei to ETH
    const balanceWei = new Decimal(response.result);
    const balanceEth = balanceWei.dividedBy(new Decimal(10).pow(18));

    return {
      currency: 'ETH',
      balance: balanceEth.toNumber(),
      used: 0,
      total: balanceEth.toNumber()
    };
  }

  private convertNormalTransaction(tx: EtherscanTransaction, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';
    if (isFromUser && isToUser) {
      type = 'internal_transfer_in'; // Self-transfer, treat as internal
    } else if (isFromUser) {
      type = 'transfer_out';
    } else {
      type = 'transfer_in';
    }

    // Convert value from wei to ETH
    const valueWei = new Decimal(tx.value);
    const valueEth = valueWei.dividedBy(new Decimal(10).pow(18));

    // Calculate fee
    const gasUsed = new Decimal(tx.gasUsed);
    const gasPrice = new Decimal(tx.gasPrice);
    const feeWei = gasUsed.mul(gasPrice);
    const feeEth = feeWei.dividedBy(new Decimal(10).pow(18));

    return {
      hash: tx.hash,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: '',
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(valueEth.toString(), 'ETH'),
      fee: createMoney(feeEth.toString(), 'ETH'),
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: parseInt(gasPrice.toString()),
      status: tx.isError === '0' ? 'success' : 'failed',
      type,
      confirmations: parseInt(tx.confirmations)
    };
  }

  private convertInternalTransaction(tx: EtherscanInternalTransaction, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out' | 'internal_transfer_in' | 'internal_transfer_out';
    if (isFromUser && isToUser) {
      type = 'internal_transfer_in'; // Self-transfer, treat as internal
    } else if (isFromUser) {
      type = 'transfer_out';
    } else {
      type = 'transfer_in';
    }

    // Convert value from wei to ETH
    const valueWei = new Decimal(tx.value);
    const valueEth = valueWei.dividedBy(new Decimal(10).pow(18));

    return {
      hash: `${tx.hash}-internal-${tx.traceId || '0'}`,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: '',
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(valueEth.toString(), 'ETH'),
      fee: createMoney('0', 'ETH'), // Internal transactions don't have separate fees
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: parseInt(tx.gas),
      status: tx.isError === '0' ? 'success' : 'failed',
      type
    };
  }

  private convertTokenTransfer(tx: EtherscanTokenTransfer, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to.toLowerCase() === userAddress.toLowerCase();

    // Note: Transaction direction is determined by from/to addresses but not used in this method

    // Convert value using token decimals
    const decimals = parseInt(tx.tokenDecimal);
    const valueRaw = new Decimal(tx.value);
    const value = valueRaw.dividedBy(new Decimal(10).pow(decimals));

    return {
      hash: `${tx.hash}-token-${tx.tokenSymbol}`,
      blockNumber: parseInt(tx.blockNumber),
      blockHash: '',
      timestamp: parseInt(tx.timeStamp) * 1000,
      from: tx.from,
      to: tx.to,
      value: createMoney(value.toString(), tx.tokenSymbol),
      fee: createMoney('0', 'ETH'), // Token transfers use ETH for gas but that's in main tx
      gasUsed: parseInt(tx.gasUsed),
      gasPrice: parseInt(new Decimal(tx.gasPrice).toString()),
      status: 'success', // Token transfers don't have error status in this API
      type: 'token_transfer',
      tokenContract: tx.contractAddress,
      tokenSymbol: tx.tokenSymbol
    };
  }

  private isTransactionRelevant(tx: BlockchainTransaction, userAddress: string): boolean {
    const targetAddress = userAddress.toLowerCase();
    const fromAddress = tx.from.toLowerCase();
    const toAddress = tx.to.toLowerCase();

    // Include if our address is involved and there's actual value transfer
    const isInvolved = fromAddress === targetAddress || toAddress === targetAddress;
    const hasValue = tx.value.amount.greaterThan(0);

    return isInvolved && hasValue;
  }
}===== ./src/blockchains/ethereum/providers/AlchemyProvider.ts =====
import type { Balance, BlockchainTransaction, RateLimitConfig } from '@crypto/core';
import { ServiceError } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import { HttpClient, createMoney } from '@crypto/shared-utils';
import { Decimal } from 'decimal.js';
import { IBlockchainProvider, ProviderCapabilities, ProviderOperation } from '../../shared/types.ts';

const logger = getLogger('AlchemyProvider');

export interface AlchemyConfig {
  apiKey?: string;
  network?: string;
  baseUrl?: string;
  timeout?: number;
  retries?: number;
}


export class AlchemyProvider implements IBlockchainProvider<AlchemyConfig> {
  readonly name = 'alchemy';
  readonly blockchain = 'ethereum';
  readonly capabilities: ProviderCapabilities = {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 100, // Alchemy supports batch requests
    supportsHistoricalData: true,
    supportsPagination: true,
    maxLookbackDays: undefined, // No limit
    supportsRealTimeData: true,
    supportsTokenData: true
  };
  readonly rateLimit: RateLimitConfig = {
    requestsPerSecond: 5, // Alchemy allows higher rates
    requestsPerMinute: 300,
    requestsPerHour: 3600,
    burstLimit: 10
  };

  private readonly baseUrl: string;
  private readonly apiKey: string;
  private readonly network: string;
  private readonly httpClient: HttpClient;

  constructor(config: AlchemyConfig = {}) {
    this.apiKey = config.apiKey || process.env.ALCHEMY_API_KEY || '';
    this.network = config.network || 'eth-mainnet';
    this.baseUrl = config.baseUrl || `https://${this.network}.g.alchemy.com/v2/${this.apiKey}`;
    this.httpClient = new HttpClient({
      baseUrl: this.baseUrl,
      timeout: config.timeout || 10000,
      retries: config.retries || 3,
      rateLimit: this.rateLimit,
      providerName: this.name
    });

    if (!this.apiKey) {
      throw new Error('Alchemy API key is required - set ALCHEMY_API_KEY environment variable');
    }

    logger.debug(`Initialized AlchemyProvider - Network: ${this.network}, BaseUrl: ${this.baseUrl.replace(this.apiKey, 'HIDDEN')}, Timeout: ${config.timeout || 10000}, Retries: ${config.retries || 3}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a simple JSON-RPC call
      const response = await this.httpClient.post('', {
        jsonrpc: '2.0',
        method: 'eth_blockNumber',
        params: [],
        id: 1
      });
      return response && response.result;
    } catch (error) {
      logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    return this.isHealthy();
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    switch (operation.type) {
      case 'getAddressTransactions':
        return this.getAddressTransactions(operation.params.address, operation.params.since) as Promise<T>;
      case 'getAddressBalance':
        return this.getAddressBalance(operation.params.address) as Promise<T>;
      case 'getTokenTransactions':
        return this.getTokenTransactions(operation.params.address, operation.params.contractAddress, operation.params.since) as Promise<T>;
      case 'getTokenBalances':
        return this.getTokenBalances(operation.params.address, operation.params.contractAddresses) as Promise<T>;
      default:
        throw new ServiceError(`Unsupported operation: ${operation.type}`, this.name, operation.type);
    }
  }

  private async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {

    try {
      // Get only regular transactions (external + internal, no tokens)
      // Token transactions are handled separately via getTokenTransactions
      const transfers = await this.getAssetTransfers(address, since, ['external', 'internal']);

      // Convert to standard blockchain transactions
      const transactions = transfers.map(transfer => this.convertAssetTransfer(transfer, address));

      // Sort by timestamp
      transactions.sort((a, b) => a.timestamp - b.timestamp);

      logger.debug(`Found ${transactions.length} regular transactions for ${address}`);
      return transactions;

    } catch (error) {
      logger.error(`Failed to fetch regular transactions for ${address} - Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(address: string): Promise<Balance[]> {

    try {
      // Get ETH balance
      const ethBalanceResponse = await this.httpClient.post('', {
        jsonrpc: '2.0',
        method: 'eth_getBalance',
        params: [address, 'latest'],
        id: 1
      });
      const ethBalanceWei = new Decimal(ethBalanceResponse.result);
      const ethBalance = ethBalanceWei.dividedBy(new Decimal(10).pow(18));

      const balances: Balance[] = [{
        currency: 'ETH',
        balance: ethBalance.toNumber(),
        used: 0,
        total: ethBalance.toNumber()
      }];

      // Get token balances using Alchemy's enhanced API
      const tokenBalances = await this.getTokenBalancesForAddress(address);
      balances.push(...tokenBalances);

      return balances;
    } catch (error) {
      logger.error(`Failed to fetch balance for ${address} - Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenTransactions(address: string, contractAddress?: string, since?: number): Promise<BlockchainTransaction[]> {

    // Use asset transfers with token category filter
    const transfers = await this.getAssetTransfers(address, since, ['erc20', 'erc721', 'erc1155'], contractAddress);
    return transfers.map(transfer => this.convertAssetTransfer(transfer, address));
  }

  private async getTokenBalances(address: string, contractAddresses?: string[]): Promise<Balance[]> {
    return this.getTokenBalancesForAddress(address, contractAddresses);
  }

  private async getAssetTransfers(
    address: string,
    since?: number,
    category: string[] = ['external', 'internal', 'erc20', 'erc721', 'erc1155'],
    contractAddress?: string
  ): Promise<any[]> {
    const params: any = {
      fromAddress: address,
      toAddress: address,
      category,
      withMetadata: true,
      excludeZeroValue: false,
      maxCount: '0x3e8' // 1000 in hex
    };

    if (contractAddress) {
      params.contractAddresses = [contractAddress];
    }

    if (since) {
      // Convert timestamp to block number (approximate)
      const blockNumber = await this.timestampToBlockNumber(since);
      if (blockNumber) {
        params.fromBlock = `0x${blockNumber.toString(16)}`;
      }
    }

    // Get transfers from address
    const fromResponse = await this.httpClient.post('', {
      jsonrpc: '2.0',
      method: 'alchemy_getAssetTransfers',
      params: [params],
      id: 1
    });

    // Get transfers to address
    const toParams = { ...params };
    delete toParams.fromAddress;
    toParams.toAddress = address;
    const toResponse = await this.httpClient.post('', {
      jsonrpc: '2.0',
      method: 'alchemy_getAssetTransfers',
      params: [toParams],
      id: 1
    });

    const allTransfers = [
      ...(fromResponse.result?.transfers || []),
      ...(toResponse.result?.transfers || [])
    ];

    // Remove duplicates based on hash + category
    const uniqueTransfers = allTransfers.filter((transfer, index, array) =>
      array.findIndex(t => t.hash === transfer.hash && t.category === transfer.category) === index
    );

    return uniqueTransfers;
  }

  private async getTokenBalancesForAddress(address: string, contractAddresses?: string[]): Promise<Balance[]> {
    try {
      const params: any = {
        address,
        tokenType: 'erc20'
      };

      if (contractAddresses) {
        params.contractAddresses = contractAddresses;
      }

      const response = await this.httpClient.post('', {
        jsonrpc: '2.0',
        method: 'alchemy_getTokenBalances',
        params: [address, contractAddresses || 'DEFAULT_TOKENS'],
        id: 1
      });

      const balances: Balance[] = [];

      for (const tokenBalance of response.result?.tokenBalances || []) {
        if (tokenBalance.tokenBalance && tokenBalance.tokenBalance !== '0x0') {
          // Get token metadata
          const metadata = await this.httpClient.post('', {
            jsonrpc: '2.0',
            method: 'alchemy_getTokenMetadata',
            params: [tokenBalance.contractAddress],
            id: 1
          }).then(response => response.result).catch(() => null);

          const balance = new Decimal(tokenBalance.tokenBalance);
          const decimals = metadata?.decimals || 18;
          const symbol = metadata?.symbol || 'UNKNOWN';

          const adjustedBalance = balance.dividedBy(new Decimal(10).pow(decimals));

          balances.push({
            currency: symbol,
            balance: adjustedBalance.toNumber(),
            used: 0,
            total: adjustedBalance.toNumber(),
            contractAddress: tokenBalance.contractAddress
          });
        }
      }

      return balances;
    } catch (error) {
      logger.warn(`Failed to fetch token balances for ${address} - Error: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }


  private async timestampToBlockNumber(_timestamp: number): Promise<number | null> {
    try {
      // This is an approximation - Alchemy doesn't have a direct timestamp to block API
      // We could implement binary search here, but for now return null to get all history
      return null;
    } catch (error) {
      return null;
    }
  }

  private convertAssetTransfer(transfer: any, userAddress: string): BlockchainTransaction {
    const isFromUser = transfer.from.toLowerCase() === userAddress.toLowerCase();
    const isToUser = transfer.to.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out' | 'token_transfer_in' | 'token_transfer_out';
    const isToken = transfer.category === 'token';

    if (isFromUser && isToUser) {
      type = isToken ? 'token_transfer_in' : 'transfer_in'; // Self-transfer, treat as incoming
    } else if (isFromUser) {
      type = isToken ? 'token_transfer_out' : 'transfer_out';
    } else {
      type = isToken ? 'token_transfer_in' : 'transfer_in';
    }

    // Handle different asset types
    let currency = 'ETH';
    let amount = new Decimal(transfer.value || 0);

    if (transfer.category === 'token') {
      currency = transfer.asset || 'UNKNOWN';
      if (transfer.rawContract?.decimal) {
        const decimals = parseInt(transfer.rawContract.decimal);
        amount = amount.dividedBy(new Decimal(10).pow(decimals));
      }
    } else {
      // ETH transfer - value is already in ETH, not wei for Alchemy
      currency = 'ETH';
    }

    const timestamp = transfer.metadata?.blockTimestamp ?
      new Date(transfer.metadata.blockTimestamp).getTime() :
      Date.now();

    return {
      hash: transfer.hash,
      blockNumber: parseInt(transfer.blockNum, 16),
      blockHash: '',
      timestamp,
      from: transfer.from,
      to: transfer.to,
      value: createMoney(amount.toNumber(), currency),
      fee: createMoney(0, 'ETH'),
      status: 'success' as const,
      type,
      tokenContract: transfer.rawContract?.address,
      tokenSymbol: currency !== 'ETH' ? currency : undefined
    };
  }

}===== ./src/blockchains/ethereum/providers/MoralisProvider.ts =====
import type { Balance, BlockchainTransaction, RateLimitConfig } from '@crypto/core';
import { ServiceError } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import { HttpClient, createMoney } from '@crypto/shared-utils';
import { Decimal } from 'decimal.js';
import { IBlockchainProvider, ProviderCapabilities, ProviderOperation } from '../../shared/types.ts';


const logger = getLogger('MoralisProvider');

export interface MoralisConfig {
  apiKey?: string;
  network?: string;
  baseUrl?: string;
  timeout?: number;
  retries?: number;
}

// Moralis API response types
interface MoralisTransaction {
  hash: string;
  nonce: string;
  transaction_index: string;
  from_address: string;
  to_address: string;
  value: string;
  gas: string;
  gas_price: string;
  input: string;
  receipt_cumulative_gas_used: string;
  receipt_gas_used: string;
  receipt_contract_address: string | null;
  receipt_root: string;
  receipt_status: string;
  block_timestamp: string;
  block_number: string;
  block_hash: string;
}

interface MoralisTokenTransfer {
  transaction_hash: string;
  address: string;
  block_timestamp: string;
  block_number: string;
  block_hash: string;
  to_address: string;
  from_address: string;
  value: string;
  token_name: string;
  token_symbol: string;
  token_logo: string;
  token_decimals: string;
  contract_type: string;
}


interface MoralisNativeBalance {
  balance: string;
}

export class MoralisProvider implements IBlockchainProvider<MoralisConfig> {
  readonly name = 'moralis';
  readonly blockchain = 'ethereum';
  readonly capabilities: ProviderCapabilities = {
    supportedOperations: ['getAddressTransactions', 'getAddressBalance', 'getTokenTransactions', 'getTokenBalances'],
    maxBatchSize: 1, // Moralis doesn't support batch operations in free tier
    supportsHistoricalData: true,
    supportsPagination: true,
    maxLookbackDays: undefined, // No limit
    supportsRealTimeData: true,
    supportsTokenData: true
  };
  readonly rateLimit: RateLimitConfig = {
    requestsPerSecond: 2, // Conservative for free tier
    requestsPerMinute: 120,
    requestsPerHour: 1000,
    burstLimit: 5
  };

  private readonly baseUrl: string;
  private readonly apiKey: string;
  private readonly network: string;
  private readonly httpClient: HttpClient;

  constructor(config: MoralisConfig = {}) {
    this.apiKey = config.apiKey || process.env.MORALIS_API_KEY || '';
    this.network = config.network || 'eth'; // eth, polygon, bsc, etc.
    this.baseUrl = config.baseUrl || 'https://deep-index.moralis.io/api/v2';
    this.httpClient = new HttpClient({
      baseUrl: this.baseUrl,
      timeout: config.timeout || 10000,
      retries: config.retries || 3,
      rateLimit: this.rateLimit,
      providerName: this.name,
      defaultHeaders: {
        'Accept': 'application/json',
        'X-API-Key': this.apiKey
      }
    });

    if (!this.apiKey) {
      throw new Error('Moralis API key is required - set MORALIS_API_KEY environment variable');
    }

    logger.debug(`Initialized MoralisProvider - Network: ${this.network}, BaseUrl: ${this.baseUrl}, Timeout: ${config.timeout || 10000}, Retries: ${config.retries || 3}`);
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test with a simple API call to get server time or stats
      const response = await this.httpClient.get('/dateToBlock?chain=eth&date=2023-01-01T00:00:00.000Z');
      return response && response.block;
    } catch (error) {
      logger.warn(`Health check failed - Error: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  async testConnection(): Promise<boolean> {
    return this.isHealthy();
  }

  async execute<T>(operation: ProviderOperation<T>): Promise<T> {
    switch (operation.type) {
      case 'getAddressTransactions':
        return this.getAddressTransactions(operation.params.address, operation.params.since) as Promise<T>;
      case 'getAddressBalance':
        return this.getAddressBalance(operation.params.address) as Promise<T>;
      case 'getTokenTransactions':
        return this.getTokenTransactions(operation.params.address, operation.params.contractAddress, operation.params.since) as Promise<T>;
      case 'getTokenBalances':
        return this.getTokenBalances(operation.params.address, operation.params.contractAddresses) as Promise<T>;
      default:
        throw new ServiceError(`Unsupported operation: ${operation.type}`, this.name, operation.type);
    }
  }

  private async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {

    try {
      // Get only native transactions
      // Token transfers are handled separately via getTokenTransactions
      const nativeTransactions = await this.getNativeTransactions(address, since);

      // Sort by timestamp
      nativeTransactions.sort((a, b) => a.timestamp - b.timestamp);

      logger.debug(`Found ${nativeTransactions.length} native transactions for ${address}`);
      return nativeTransactions;

    } catch (error) {
      logger.error(`Failed to fetch native transactions for ${address} - Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getAddressBalance(address: string): Promise<Balance[]> {

    try {
      const balances: Balance[] = [];

      // Get native balance (ETH)
      const nativeBalance = await this.getNativeBalance(address);
      balances.push(nativeBalance);

      // Get token balances
      const tokenBalances = await this.getTokenBalancesForAddress(address);
      balances.push(...tokenBalances);

      return balances;
    } catch (error) {
      logger.error(`Failed to fetch balances for ${address} - Error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  private async getTokenTransactions(address: string, contractAddress?: string, since?: number): Promise<BlockchainTransaction[]> {
    return this.getTokenTransfers(address, since, contractAddress);
  }

  private async getTokenBalances(address: string, contractAddresses?: string[]): Promise<Balance[]> {
    return this.getTokenBalancesForAddress(address, contractAddresses);
  }

  private async getNativeTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    const params = new URLSearchParams({
      chain: this.network,
      limit: '100'
    });

    if (since) {
      // Convert timestamp to ISO string
      const sinceDate = new Date(since).toISOString();
      params.append('from_date', sinceDate);
    }

    const endpoint = `/${address}?${params.toString()}`;
    const response = await this.httpClient.get(endpoint);

    return (response.result || []).map((tx: MoralisTransaction) => this.convertNativeTransaction(tx, address));
  }

  private async getTokenTransfers(address: string, since?: number, contractAddress?: string): Promise<BlockchainTransaction[]> {
    const params = new URLSearchParams({
      chain: this.network,
      limit: '100'
    });

    if (since) {
      const sinceDate = new Date(since).toISOString();
      params.append('from_date', sinceDate);
    }

    if (contractAddress) {
      params.append('contract_addresses[]', contractAddress);
    }

    const endpoint = `/${address}/erc20?${params.toString()}`;
    const response = await this.httpClient.get(endpoint);

    return (response.result || []).map((tx: MoralisTokenTransfer) => this.convertTokenTransfer(tx, address));
  }

  private async getNativeBalance(address: string): Promise<Balance> {
    const params = new URLSearchParams({
      chain: this.network
    });

    const endpoint = `/${address}/balance?${params.toString()}`;
    const response: MoralisNativeBalance = await this.httpClient.get(endpoint);

    // Convert from wei to ETH
    const balanceWei = new Decimal(response.balance);
    const balanceEth = balanceWei.dividedBy(new Decimal(10).pow(18));

    return {
      currency: 'ETH',
      balance: balanceEth.toNumber(),
      used: 0,
      total: balanceEth.toNumber()
    };
  }

  private async getTokenBalancesForAddress(address: string, contractAddresses?: string[]): Promise<Balance[]> {
    const params = new URLSearchParams({
      chain: this.network
    });

    if (contractAddresses) {
      contractAddresses.forEach(contract => {
        params.append('token_addresses[]', contract);
      });
    }

    const endpoint = `/${address}/erc20?${params.toString()}`;
    const response = await this.httpClient.get(endpoint);

    const balances: Balance[] = [];

    for (const tokenBalance of response || []) {
      if (tokenBalance.balance && tokenBalance.balance !== '0') {
        const balance = new Decimal(tokenBalance.balance);
        const decimals = tokenBalance.decimals || 18;
        const symbol = tokenBalance.symbol || 'UNKNOWN';

        const adjustedBalance = balance.dividedBy(new Decimal(10).pow(decimals));

        balances.push({
          currency: symbol,
          balance: adjustedBalance.toNumber(),
          used: 0,
          total: adjustedBalance.toNumber(),
          contractAddress: tokenBalance.token_address
        });
      }
    }

    return balances;
  }

  private convertNativeTransaction(tx: MoralisTransaction, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from_address.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to_address.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'transfer_in' | 'transfer_out';
    if (isFromUser && isToUser) {
      type = 'transfer_in'; // Self-transfer, treat as incoming
    } else if (isFromUser) {
      type = 'transfer_out';
    } else {
      type = 'transfer_in';
    }

    // Convert value from wei to ETH
    const valueWei = new Decimal(tx.value);
    const valueEth = valueWei.dividedBy(new Decimal(10).pow(18));

    return {
      hash: tx.hash,
      blockNumber: parseInt(tx.block_number),
      blockHash: tx.block_hash,
      timestamp: new Date(tx.block_timestamp).getTime(),
      from: tx.from_address,
      to: tx.to_address,
      value: createMoney(valueEth.toNumber(), 'ETH'),
      fee: createMoney(0, 'ETH'),
      gasUsed: parseInt(tx.receipt_gas_used),
      gasPrice: new Decimal(tx.gas_price).toNumber(),
      status: tx.receipt_status === '1' ? 'success' : 'failed',
      type
    };
  }

  private convertTokenTransfer(tx: MoralisTokenTransfer, userAddress: string): BlockchainTransaction {
    const isFromUser = tx.from_address.toLowerCase() === userAddress.toLowerCase();
    const isToUser = tx.to_address.toLowerCase() === userAddress.toLowerCase();

    // Determine transaction type
    let type: 'token_transfer_in' | 'token_transfer_out';
    if (isFromUser && isToUser) {
      type = 'token_transfer_in'; // Self-transfer, treat as incoming
    } else if (isFromUser) {
      type = 'token_transfer_out';
    } else {
      type = 'token_transfer_in';
    }

    // Convert value using token decimals
    const decimals = parseInt(tx.token_decimals);
    const valueRaw = new Decimal(tx.value);
    const value = valueRaw.dividedBy(new Decimal(10).pow(decimals));

    return {
      hash: tx.transaction_hash,
      blockNumber: parseInt(tx.block_number),
      blockHash: '',
      timestamp: new Date(tx.block_timestamp).getTime(),
      from: tx.from_address,
      to: tx.to_address,
      value: createMoney(value.toNumber(), tx.token_symbol),
      fee: createMoney(0, 'ETH'),
      status: 'success' as const,
      type,
      tokenContract: tx.address,
      tokenSymbol: tx.token_symbol
    };
  }

}===== ./src/blockchains/ethereum/types.ts =====
// Ethereum and EVM blockchain adapter types

export interface EtherscanTransaction {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  transactionIndex: string;
  from: string;
  to: string;
  value: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  cumulativeGasUsed: string;
  input: string;
  confirmations: string;
  isError?: string;
  txreceipt_status?: string;
  functionName?: string;
  methodId?: string;
}

export interface EtherscanInternalTransaction {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  from: string;
  to: string;
  value: string;
  contractAddress: string;
  input: string;
  type: string;
  gas: string;
  gasUsed: string;
  traceId: string;
  isError: string;
  errCode: string;
}

export interface EtherscanTokenTransfer {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  from: string;
  contractAddress: string;
  to: string;
  value: string;
  tokenName: string;
  tokenSymbol: string;
  tokenDecimal: string;
  transactionIndex: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  cumulativeGasUsed: string;
  input: string;
  confirmations: string;
}

export interface EtherscanApiResponse<T> {
  status: string;
  message: string;
  result: T[];
}

export interface EtherscanBalance {
  account: string;
  balance: string;
}

export interface EtherscanTokenBalance {
  TokenAddress: string;
  TokenName: string;
  TokenSymbol: string;
  TokenQuantity: string;
  TokenDivisor: string;
}===== ./src/blockchains/ethereum/adapter.ts =====


import type { Balance, BlockchainInfo, BlockchainTransaction } from '@crypto/core';

import { BaseBlockchainAdapter } from '../shared/base-blockchain-adapter.ts';
import { BlockchainProviderManager } from '../shared/blockchain-provider-manager.ts';
import type { BlockchainExplorersConfig } from '../shared/explorer-config.ts';

export class EthereumAdapter extends BaseBlockchainAdapter {
  private providerManager: BlockchainProviderManager;

  constructor(explorerConfig: BlockchainExplorersConfig) {
    super('ethereum', 'EthereumAdapter');

    this.providerManager = new BlockchainProviderManager(explorerConfig);
    this.providerManager.autoRegisterFromConfig('ethereum', 'mainnet');

    this.logger.info(`Initialized Ethereum adapter with registry-based provider manager - ProvidersCount: ${this.providerManager.getProviders('ethereum').length}`);
  }

  async getAddressTransactions(address: string, since?: number): Promise<BlockchainTransaction[]> {
    this.logger.info(`EthereumAdapter: Fetching transactions for address: ${address.substring(0, 20)}...`);
    this.logger.debug(`EthereumAdapter.getAddressTransactions called - Address: ${address}, Since: ${since}`);

    try {
      // Fetch regular ETH transactions
      const regularTxs = await this.providerManager.executeWithFailover('ethereum', {
        type: 'getAddressTransactions',
        params: { address, since },
        getCacheKey: (params: any) => `eth_tx_${params.address}_${params.since || 'all'}`
      }) as BlockchainTransaction[];

      // Try to fetch ERC-20 token transactions (if provider supports it)
      let tokenTxs: BlockchainTransaction[] = [];
      try {
        tokenTxs = await this.providerManager.executeWithFailover('ethereum', {
          type: 'getTokenTransactions',
          params: { address, since },
          getCacheKey: (params: any) => `eth_token_tx_${params.address}_${params.since || 'all'}`
        }) as BlockchainTransaction[];
      } catch (error) {
        this.logger.debug(`Provider does not support separate token transactions or failed to fetch - Error: ${error instanceof Error ? error.message : String(error)}`);
        // Continue without separate token transactions - provider may already include them in getAddressTransactions
      }

      this.logger.info(`EthereumAdapter transaction breakdown for ${address.substring(0, 20)}... - Regular: ${regularTxs.length}, Token: ${tokenTxs.length}, Total: ${regularTxs.length + tokenTxs.length}`);

      // Combine all transactions (following the same pattern as Solana)
      const allTransactions = [...regularTxs, ...tokenTxs];

      // Sort by timestamp (newest first)
      allTransactions.sort((a, b) => b.timestamp - a.timestamp);

      // Remove any duplicate transactions (by hash) - some providers may include tokens in regular transactions
      const uniqueTransactions = allTransactions.reduce((acc, tx) => {
        if (!acc.find((existing: any) => existing.hash === tx.hash)) {
          acc.push(tx);
        }
        return acc;
      }, [] as BlockchainTransaction[]);

      this.logger.info(`EthereumAdapter: Found ${uniqueTransactions.length} unique transactions for address ${address.substring(0, 20)}...`);
      return uniqueTransactions;

    } catch (error) {
      this.logger.error(`Failed to fetch transactions for ${address} - Error: ${error}`);
      throw error;
    }
  }

  async getAddressBalance(address: string): Promise<Balance[]> {
    this.logger.info(`Getting balance for address: ${address.substring(0, 20)}...`);

    try {
      // Use provider manager to fetch balance with failover
      const balances = await this.providerManager.executeWithFailover('ethereum', {
        type: 'getAddressBalance',
        params: { address },
        getCacheKey: (params: any) => `eth_balance_${params.address}`
      }) as Balance[];

      return balances;

    } catch (error) {
      this.logger.error(`Failed to fetch balance for ${address} - Error: ${error}`);
      throw error;
    }
  }

  validateAddress(address: string): boolean {
    // Ethereum address pattern: 0x followed by 40 hex characters
    const ethereumPattern = /^0x[a-fA-F0-9]{40}$/;
    return ethereumPattern.test(address);
  }

  async testConnection(): Promise<boolean> {
    this.logger.debug('EthereumAdapter.testConnection called');
    try {
      const providers = this.providerManager.getProviders('ethereum');
      this.logger.debug(`Found ${providers.length} providers`);
      if (providers.length === 0) {
        this.logger.warn('No providers available for connection test');
        return false;
      }

      // Test the first provider
      const result = await providers[0]?.testConnection() || false;
      this.logger.debug(`Connection test result: ${result}`);
      return result;
    } catch (error) {
      this.logger.error(`Connection test failed - Error: ${error}`);
      return false;
    }
  }

  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return {
      id: 'ethereum',
      name: 'Ethereum',
      network: 'mainnet',
      capabilities: {
        supportsAddressTransactions: true,
        supportsTokenTransactions: true,
        supportsBalanceQueries: true,
        supportsHistoricalData: true,
        supportsPagination: true,
        maxLookbackDays: undefined
      }
    };
  }

  /**
   * Close adapter and cleanup resources (required by IBlockchainAdapter)
   */
  async close(): Promise<void> {
    try {
      this.providerManager.destroy();
      this.logger.info('Ethereum adapter closed successfully');
    } catch (error) {
      this.logger.warn(`Error during Ethereum adapter close - Error: ${error}`);
    }
  }
}===== ./src/services/deduplicator.ts =====
import type { EnhancedTransaction } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import { moneyToNumber } from '@crypto/shared-utils';

interface DeduplicationResult {
  unique: EnhancedTransaction[];
  duplicates: EnhancedTransaction[];
}

export class Deduplicator {
  private logger = getLogger('Deduplicator');

  async process(transactions: EnhancedTransaction[], sourceId: string): Promise<DeduplicationResult> {
    this.logger.info(`Starting deduplication for ${transactions.length} transactions from ${sourceId}`);

    const result = this.deduplicateByHash(transactions, sourceId);
    this.logDeduplicationStats(result, sourceId);
    
    return result;
  }

  async processAdvanced(transactions: EnhancedTransaction[], sourceId: string): Promise<DeduplicationResult> {
    this.logger.info(`Starting advanced deduplication for ${transactions.length} transactions from ${sourceId}`);

    const result = this.deduplicateBySimilarity(transactions, sourceId);
    this.logDeduplicationStats(result, sourceId, 'advanced');
    
    return result;
  }

  private createPrimaryKey(transaction: EnhancedTransaction): string {
    // Create a key based on core transaction properties
    // This is more flexible than just using the hash
    const keyParts = [
      transaction.source,
      transaction.type,
      Math.floor((transaction.timestamp || 0) / 1000), // Round to seconds to handle minor timestamp differences
      transaction.symbol || '',
      this.normalizeAmount(typeof transaction.amount === 'object' ? moneyToNumber(transaction.amount) : (transaction.amount || 0)),
      transaction.side || ''
    ];

    return keyParts.join('|');
  }

  private areTransactionsSimilar(tx1: EnhancedTransaction, tx2: EnhancedTransaction): boolean {
    // Define similarity criteria
    const timestampDiff = Math.abs((tx1.timestamp || 0) - (tx2.timestamp || 0));
    const timestampTolerance = 5000; // 5 seconds

    const amount1 = typeof tx1.amount === 'object' ? moneyToNumber(tx1.amount) : (tx1.amount || 0);
    const amount2 = typeof tx2.amount === 'object' ? moneyToNumber(tx2.amount) : (tx2.amount || 0);
    const amountDiff = Math.abs(amount1 - amount2);
    const amountTolerance = 0.00000001; // Satoshi-level tolerance

    return (
      tx1.source === tx2.source &&
      tx1.type === tx2.type &&
      tx1.symbol === tx2.symbol &&
      tx1.side === tx2.side &&
      timestampDiff <= timestampTolerance &&
      amountDiff <= amountTolerance
    );
  }

  private normalizeAmount(amount: number): string {
    // Normalize amount to handle floating point precision issues
    return amount.toFixed(8);
  }

  // Method to detect potential data quality issues
  detectAnomalies(transactions: EnhancedTransaction[]): {
    missingIds: EnhancedTransaction[];
    invalidTimestamps: EnhancedTransaction[];
    zeroAmounts: EnhancedTransaction[];
    missingSymbols: EnhancedTransaction[];
  } {
    const anomalies = {
      missingIds: [] as EnhancedTransaction[],
      invalidTimestamps: [] as EnhancedTransaction[],
      zeroAmounts: [] as EnhancedTransaction[],
      missingSymbols: [] as EnhancedTransaction[]
    };

    for (const tx of transactions) {
      // Check for missing IDs
      if (!tx.id && !tx.hash) {
        anomalies.missingIds.push(tx);
      }

      // Check for invalid timestamps
      if (!tx.timestamp || tx.timestamp <= 0 || tx.timestamp > Date.now() + 86400000) { // Future date + 1 day tolerance
        anomalies.invalidTimestamps.push(tx);
      }

      // Check for zero amounts in trades (might be valid for some transaction types)
      const amount = typeof tx.amount === 'object' ? moneyToNumber(tx.amount) : tx.amount;
      if (tx.type === 'trade' && (!amount || amount === 0)) {
        anomalies.zeroAmounts.push(tx);
      }

      // Check for missing symbols in trades
      if (tx.type === 'trade' && !tx.symbol) {
        anomalies.missingSymbols.push(tx);
      }
    }

    if (Object.values(anomalies).some(arr => arr.length > 0)) {
      this.logger.warn(`Data quality issues detected - Missing IDs: ${anomalies.missingIds.length}, Invalid timestamps: ${anomalies.invalidTimestamps.length}, Zero amounts: ${anomalies.zeroAmounts.length}, Missing symbols: ${anomalies.missingSymbols.length}`);
    }

    return anomalies;
  }

  // Get statistics about the deduplication process
  getDeduplicationStats(result: DeduplicationResult): any {
    const total = result.unique.length + result.duplicates.length;

    return {
      total,
      unique: result.unique.length,
      duplicates: result.duplicates.length,
      duplicateRate: total > 0 ? (result.duplicates.length / total) * 100 : 0,
      efficiency: total > 0 ? (result.unique.length / total) * 100 : 0
    };
  }

  private deduplicateByHash(transactions: EnhancedTransaction[], sourceId: string): DeduplicationResult {
    const unique: EnhancedTransaction[] = [];
    const duplicates: EnhancedTransaction[] = [];
    const seenHashes = new Set<string>();

    for (const transaction of transactions) {
      const hash = transaction.hash;

      if (seenHashes.has(hash)) {
        duplicates.push(transaction);
        this.logDuplicateTransaction(transaction.id || hash, sourceId);
      } else {
        seenHashes.add(hash);
        unique.push(transaction);
      }
    }

    return { unique, duplicates };
  }

  private deduplicateBySimilarity(transactions: EnhancedTransaction[], sourceId: string): DeduplicationResult {
    const unique: EnhancedTransaction[] = [];
    const duplicates: EnhancedTransaction[] = [];
    const transactionIndex = new Map<string, EnhancedTransaction>();

    for (const transaction of transactions) {
      const primaryKey = this.createPrimaryKey(transaction);
      const existingTransaction = transactionIndex.get(primaryKey);

      if (existingTransaction) {
        if (this.areTransactionsSimilar(existingTransaction, transaction)) {
          duplicates.push(transaction);
          this.logDuplicateTransaction(transaction.id || transaction.hash, sourceId);
        } else {
          unique.push(transaction);
          transactionIndex.set(primaryKey + '_' + unique.length, transaction);
        }
      } else {
        transactionIndex.set(primaryKey, transaction);
        unique.push(transaction);
      }
    }

    return { unique, duplicates };
  }

  private logDeduplicationStats(result: DeduplicationResult, sourceId: string, mode: string = 'standard'): void {
    const total = result.unique.length + result.duplicates.length;
    const duplicatePercentage = total > 0 ? ((result.duplicates.length / total) * 100).toFixed(2) : '0.00';
    
    this.logger.info(`${mode.charAt(0).toUpperCase() + mode.slice(1)} deduplication completed for ${sourceId} - Total: ${total}, Unique: ${result.unique.length}, Duplicates: ${result.duplicates.length} (${duplicatePercentage}%)`);
  }

  private logDuplicateTransaction(transactionId: string, sourceId: string): void {
    this.logger.debug(`Duplicate transaction skipped - ID: ${transactionId}, Source: ${sourceId}, Timestamp: ${Date.now()}`);
  }
} ===== ./src/services/importer.ts =====
import type { CryptoTransaction, EnhancedTransaction, IBlockchainAdapter, IExchangeAdapter, TransactionNote } from '@crypto/core';
import { getLogger } from '@crypto/shared-logger';
import { type BlockchainExplorersConfig } from '@crypto/shared-utils';
import crypto from 'crypto';
import type { ImportResult, ImportSummary } from '../types.ts';
import { TransactionNoteType } from '../types.ts';

import { Database, TransactionRepository, TransactionService, WalletRepository, WalletService } from '@crypto/data';

import { BlockchainAdapterFactory } from '../blockchains/shared/index.ts';
import { ExchangeAdapterFactory } from '../exchanges/adapter-factory.ts';
import { detectScamFromSymbol } from '../utils/scam-detection.ts';
import { Deduplicator } from './deduplicator.ts';

// Universal adapter imports
import { UniversalAdapterFactory } from '../adapters/universal/adapter-factory.js';
import type { 
  IUniversalAdapter, 
  FetchParams, 
  Transaction as UniversalTransaction,
  ExchangeAdapterConfig,
  BlockchainAdapterConfig
} from '../adapters/universal/index.js';

interface BlockchainImportOptions {
  blockchain: string;
  addresses: string[];
  since?: number;
  network?: string;
}

export class TransactionImporter {
  private logger = getLogger('TransactionImporter');
  
  private transactionService: TransactionService;
  private deduplicator: Deduplicator;
  private adapterFactory: ExchangeAdapterFactory;
  private blockchainAdapterFactory: BlockchainAdapterFactory;
  private walletService: WalletService;

  constructor(
    private readonly database: Database,
    private readonly explorerConfig: BlockchainExplorersConfig
  ) {
    this.database = database;
    const transactionRepository = new TransactionRepository(database);
    const walletRepository = new WalletRepository(database);
    this.transactionService = new TransactionService(transactionRepository, walletRepository);
    this.deduplicator = new Deduplicator();
    this.adapterFactory = new ExchangeAdapterFactory();
    this.blockchainAdapterFactory = new BlockchainAdapterFactory();
    this.walletService = new WalletService(walletRepository);
  }

  async importFromBlockchain(options: BlockchainImportOptions): Promise<ImportSummary> {
    const startTime = Date.now();
    this.logger.info('Starting transaction import from blockchain');

    try {
      await this.ensureWalletAddresses(options.addresses, options.blockchain);
      const adapters = await this.createBlockchainAdapters(options);
      const summary = await this.processBlockchainImports(adapters, options, startTime);
      
      this.logger.info(`Blockchain import completed for ${options.blockchain} - Total: ${summary.totalTransactions}, New: ${summary.newTransactions}, Duration: ${summary.duration}ms`);
      return summary;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`Blockchain import failed: ${error instanceof Error ? error.message : 'Unknown error'} (duration: ${duration}ms)`);
      throw error;
    }
  }

  async importFromBlockchainAdapter(adapter: IBlockchainAdapter, addresses: string[], since?: number): Promise<ImportResult> {
    const startTime = Date.now();
    const blockchainInfo = await adapter.getBlockchainInfo();
    const blockchainId = blockchainInfo.id;

    try {
      // Test connection first
      const isConnected = await adapter.testConnection();
      if (!isConnected) {
        throw new Error(`Failed to connect to ${blockchainId}`);
      }

      const rawTransactions = await this.fetchTransactionsForAddresses(adapter, addresses, since);

      const { transactions, saved, duplicates } = await this.processAndSaveTransactions(rawTransactions, blockchainId);

      const duration = Date.now() - startTime;

      const result: ImportResult = {
        source: blockchainId,
        transactions: transactions.length,
        newTransactions: saved,
        duplicatesSkipped: duplicates.length,
        errors: [],
        duration
      };

      this.logger.info(`Completed import from ${blockchainId} - Transactions: ${transactions.length}, New: ${saved}, Duplicates: ${duplicates.length}, Duration: ${duration}ms`);

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`Import failed for ${blockchainId}: ${error} (duration: ${duration}ms)`);

      return {
        source: blockchainId,
        transactions: 0,
        newTransactions: 0,
        duplicatesSkipped: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error'],
        duration
      };
    }
  }

  async importFromExchangeWithCredentials(options: {
    exchangeId: string;
    adapterType: 'ccxt' | 'csv';
    credentials?: {
      apiKey: string;
      secret: string;
      password?: string;
      sandbox?: boolean;
    };
    csvDirectories?: string[];
    since?: number;
  }): Promise<ImportResult> {
    const adapter = await this.adapterFactory.createAdapterWithCredentials(
      options.exchangeId,
      options.adapterType,
      {
        credentials: options.credentials,
        csvDirectories: options.csvDirectories,
        enableOnlineVerification: false
      }
    );

    return this.importFromExchange(adapter, options.since);
  }

  async importFromExchange(adapter: IExchangeAdapter, since?: number): Promise<ImportResult> {
    const startTime = Date.now();
    const exchangeInfo = await adapter.getExchangeInfo();
    const exchangeId = exchangeInfo.id;

    this.logger.info(`Starting import from ${exchangeId} (since: ${since})`);

    try {
      // Test connection first
      const isConnected = await adapter.testConnection();
      if (!isConnected) {
        throw new Error(`Failed to connect to ${exchangeId}`);
      }

      // Fetch all transactions using the adapter
      const rawTransactions = await adapter.fetchAllTransactions(since);

      const { transactions, saved, duplicates } = await this.processAndSaveTransactions(rawTransactions, exchangeId);


      const duration = Date.now() - startTime;

      const result: ImportResult = {
        source: exchangeId,
        transactions: transactions.length,
        newTransactions: saved,
        duplicatesSkipped: duplicates.length,
        errors: [],
        duration
      };

      this.logger.info(`Completed import from ${exchangeId} - Transactions: ${transactions.length}, New: ${saved}, Duplicates: ${duplicates.length}, Duration: ${duration}ms`);

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`Import failed for ${exchangeId}: ${error} (duration: ${duration}ms)`);

      return {
        source: exchangeId,
        transactions: 0,
        newTransactions: 0,
        duplicatesSkipped: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error'],
        duration
      };
    }
  }

  /**
   * Universal adapter import method - unified interface for all adapter types
   */
  async importFromAdapter(adapter: IUniversalAdapter, params: FetchParams): Promise<ImportResult> {
    const startTime = Date.now();
    const info = await adapter.getInfo();
    this.logger.info(`Starting import from ${info.name} (${info.type})`);

    try {
      // Test connection first
      const isConnected = await adapter.testConnection();
      if (!isConnected) {
        throw new Error(`Failed to connect to ${info.name}`);
      }

      // Fetch transactions using unified interface
      const transactions = await adapter.fetchTransactions(params);
      
      // Convert universal transactions to CryptoTransaction format for existing pipeline
      const cryptoTransactions = transactions.map((tx: UniversalTransaction) => this.convertUniversalToCryptoTransaction(tx));
      
      // Save transactions using existing logic
      const { saved, duplicates } = await this.processAndSaveTransactions(cryptoTransactions, info.id);

      const duration = Date.now() - startTime;

      const result: ImportResult = {
        source: info.id,
        transactions: transactions.length,
        newTransactions: saved,
        duplicatesSkipped: duplicates.length,
        errors: [],
        duration
      };

      this.logger.info(`Completed import from ${info.name} - Transactions: ${transactions.length}, New: ${saved}, Duplicates: ${duplicates.length}, Duration: ${duration}ms`);

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`Import failed for ${info.name}: ${error} (duration: ${duration}ms)`);
      
      return {
        source: info.id,
        transactions: 0,
        newTransactions: 0,
        duplicatesSkipped: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error'],
        duration
      };
    } finally {
      await adapter.close();
    }
  }

  /**
   * Import from exchange using universal interface
   */
  async importFromExchangeUniversal(
    exchangeId: string, 
    adapterType: 'ccxt' | 'csv',
    options: {
      credentials?: {
        apiKey: string;
        secret: string;
        password?: string;
      };
      csvDirectories?: string[];
      since?: number;
      symbols?: string[];
    }
  ): Promise<ImportResult> {
    const config: ExchangeAdapterConfig = {
      type: 'exchange',
      id: exchangeId,
      subType: adapterType,
      credentials: options.credentials,
      csvDirectories: options.csvDirectories
    };
    
    const adapter = await UniversalAdapterFactory.create(config);
    return this.importFromAdapter(adapter, {
      since: options.since || Date.now() - 30 * 24 * 60 * 60 * 1000, // 30 days default
      symbols: options.symbols
    });
  }

  /**
   * Import from blockchain using universal interface
   */
  async importFromBlockchainUniversal(
    blockchain: string, 
    addresses: string[],
    options: {
      since?: number;
      network?: string;
      includeTokens?: boolean;
      symbols?: string[];
    } = {}
  ): Promise<ImportResult> {
    const config: BlockchainAdapterConfig = {
      type: 'blockchain',
      id: blockchain,
      subType: 'rest',
      network: options.network || 'mainnet'
    };
    
    const adapter = await UniversalAdapterFactory.create(config, this.explorerConfig);
    return this.importFromAdapter(adapter, {
      addresses,
      since: options.since || Date.now() - 30 * 24 * 60 * 60 * 1000, // 30 days default
      includeTokens: options.includeTokens,
      symbols: options.symbols
    });
  }

  /**
   * Convert universal transaction format to CryptoTransaction for existing pipeline
   */
  private convertUniversalToCryptoTransaction(universalTx: UniversalTransaction): CryptoTransaction {
    return {
      id: universalTx.id,
      timestamp: universalTx.timestamp,
      datetime: universalTx.datetime,
      type: universalTx.type,
      status: universalTx.status,
      amount: universalTx.amount,
      fee: universalTx.fee,
      price: universalTx.price,
      symbol: universalTx.symbol,
      side: universalTx.metadata?.side,
      info: {
        from: universalTx.from,
        to: universalTx.to,
        source: universalTx.source,
        network: universalTx.network,
        ...universalTx.metadata
      }
    };
  }

  async createBlockchainAdapters(options: BlockchainImportOptions): Promise<Array<{ adapter: IBlockchainAdapter }>> {
    try {
      const adapter = await this.blockchainAdapterFactory.createBlockchainAdapter(
        options.blockchain.toLowerCase(),
        this.explorerConfig
      );

      this.logger.info(`Created blockchain adapter: ${options.blockchain} (addresses: ${options.addresses.length}, network: ${options.network || 'mainnet'})`);

      return [{ adapter }];
    } catch (error) {
      this.logger.error(`Failed to create blockchain adapter for ${options.blockchain}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  }

  private async processBlockchainImports(adapters: Array<{ adapter: IBlockchainAdapter }>, options: BlockchainImportOptions, startTime: number): Promise<ImportSummary> {
    const sourceResults: ImportResult[] = [];
    let totalTransactions = 0;
    let totalNewTransactions = 0;
    let totalDuplicatesSkipped = 0;
    const allErrors: string[] = [];

    for (const { adapter } of adapters) {
      const blockchainInfo = await adapter.getBlockchainInfo();
      this.logger.info(`Starting import from ${blockchainInfo.id}`);

      try {
        const result = await this.importFromBlockchainAdapter(adapter, options.addresses, options.since);
        sourceResults.push(result);
        totalTransactions += result.transactions;
        totalNewTransactions += result.newTransactions;
        totalDuplicatesSkipped += result.duplicatesSkipped;
        allErrors.push(...result.errors);
      } catch (error) {
        const errorMessage = `Failed to import from ${blockchainInfo.id}: ${error instanceof Error ? error.message : 'Unknown error'}`;
        this.logger.error(errorMessage);
        allErrors.push(errorMessage);

        sourceResults.push({
          source: blockchainInfo.id,
          transactions: 0,
          newTransactions: 0,
          duplicatesSkipped: 0,
          errors: [errorMessage],
          duration: 0
        });
      } finally {
        try {
          await adapter.close();
        } catch (closeError) {
          this.logger.warn(`Failed to close adapter for ${blockchainInfo.id}: ${closeError}`);
        }
      }
    }

    const duration = Date.now() - startTime;
    return {
      totalTransactions,
      newTransactions: totalNewTransactions,
      duplicatesSkipped: totalDuplicatesSkipped,
      sourceResults,
      errors: allErrors,
      duration
    };
  }

  private async fetchTransactionsForAddresses(adapter: IBlockchainAdapter, addresses: string[], since?: number): Promise<CryptoTransaction[]> {
    const rawTransactions: CryptoTransaction[] = [];

    for (const address of addresses) {
      this.logger.debug(`Fetching transactions for address: ${address}`);
      const blockchainTxs = await adapter.getAddressTransactions(address, since);
      const cryptoTxs = blockchainTxs.map(tx => adapter.convertToCryptoTransaction(tx, address));
      rawTransactions.push(...cryptoTxs);
      this.logger.debug(`Found ${blockchainTxs.length} transactions for ${address}`);
    }

    this.logger.debug(`Total ${rawTransactions.length} transactions fetched`);
    return rawTransactions;
  }

  private async processAndSaveTransactions(rawTransactions: CryptoTransaction[], sourceId: string): Promise<{ transactions: EnhancedTransaction[]; saved: number; duplicates: EnhancedTransaction[] }> {
    const transactions = rawTransactions.map(tx => this.enhanceTransaction(tx, sourceId));
    const { unique, duplicates } = await this.deduplicator.process(transactions, sourceId);
    const saved = await this.transactionService.saveMany(unique);

    if (saved > 0 && sourceId !== 'exchange') {
      try {
        await this.linkTransactionsToWallets(unique, sourceId);
      } catch (linkError) {
        this.logger.warn(`Failed to link transactions to wallet addresses for ${sourceId}: ${linkError instanceof Error ? linkError.message : String(linkError)}`);
      }
    }

    return { transactions, saved, duplicates };
  }

  private enhanceTransaction(transaction: any, exchangeId: string): EnhancedTransaction {
    // Create a unique hash for deduplication
    const hash = this.createTransactionHash(transaction, exchangeId);

    // Detect scam tokens for blockchain transactions - ONLY flag obvious scam patterns
    let note: TransactionNote | undefined = undefined;
    const isBlockchainTransaction = exchangeId.includes('mainnet') || ['ethereum', 'bitcoin', 'solana'].includes(exchangeId);
    if (isBlockchainTransaction && transaction.symbol && transaction.type === 'deposit') {
      // Only check for direct scam patterns in token symbol (no airdrop detection)
      const scamCheck = detectScamFromSymbol(transaction.symbol);

      if (scamCheck.isScam) {
        note = {
          type: TransactionNoteType.SCAM_TOKEN,
          message: `🚨 Scam token detected: ${scamCheck.reason} - Do not interact`,
          severity: 'error' as const,
          metadata: {
            tokenSymbol: transaction.symbol,
            amount: transaction.amount?.amount,
            blockchain: exchangeId,
            scamReason: scamCheck.reason,
            isKnownScamPattern: true
          }
        };
      }
    }

    return {
      ...transaction,
      source: exchangeId,
      hash,
      importedAt: Date.now(),
      verified: false,
      originalData: transaction.info || transaction,
      note
    };
  }


  private createTransactionHash(transaction: any, exchangeId: string): string {
    // Create a hash from key transaction properties for deduplication
    const hashData = JSON.stringify({
      id: transaction.id,
      timestamp: transaction.timestamp,
      symbol: transaction.symbol,
      amount: transaction.amount,
      side: transaction.side,
      type: transaction.type,
      exchange: exchangeId
    });

    return crypto.createHash('sha256').update(hashData).digest('hex').slice(0, 16);
  }


  /**
   * Link transactions to wallet addresses by matching from/to addresses
   */
  private async linkTransactionsToWallets(transactions: EnhancedTransaction[], blockchain: string): Promise<void> {
    this.logger.info(`Linking ${transactions.length} transactions to wallet addresses for ${blockchain}`);

    for (const transaction of transactions) {
      try {
        // Extract from and to addresses from the transaction
        const { from: fromAddress, to: toAddress } = this.extractTransactionAddresses(transaction);

        if (!fromAddress && !toAddress) {
          continue; // Skip transactions without addresses
        }

        // Link transaction to wallet addresses
        await this.transactionService.linkTransactionToWallets(
          transaction.id,
          fromAddress || undefined,
          toAddress || undefined
        );

      } catch (error) {
        this.logger.warn(`Failed to link transaction ${transaction.id} to wallets: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }

  /**
   * Extract transaction addresses from various data sources
   */
  private extractTransactionAddresses(transaction: EnhancedTransaction): { from: string | null; to: string | null } {
    const sources = [transaction.originalData, transaction.info];

    let from: string | null = null;
    let to: string | null = null;

    for (const source of sources) {
      if (source?.from && !from) from = source.from;
      if (source?.to && !to) to = source.to;
      if (from && to) break;
    }

    return { from, to };
  }

  /**
   * Ensure wallet addresses exist for the given blockchain
   */
  private async ensureWalletAddresses(addresses: string[], blockchain: string): Promise<void> {
    if (!addresses?.length) return;

    this.logger.debug(`Creating wallet records for ${addresses.length} ${blockchain} addresses`);

    const createPromises = addresses.map(address =>
      this.walletService.createWalletAddressFromTransaction(address, blockchain, {
        label: `${blockchain} wallet (CLI)`,
        addressType: 'personal',
        notes: 'Added from CLI arguments'
      }).catch(error => {
        this.logger.debug(`Address ${address} may already exist: ${error instanceof Error ? error.message : String(error)}`);
      })
    );

    await Promise.allSettled(createPromises);
  }

}